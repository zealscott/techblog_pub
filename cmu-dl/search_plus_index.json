{"./":{"url":"./","title":"Introduction","keywords":"","body":"Guideline for CMU Deep Learning This GitBook notes are maintained by zealscott. Course matrial 11-785 Introduction to Deep Learning Videos Notes L02 What can a network represent As an universal Boolean function / classifiers / approximators Discuss the depth and width in network L03 Learning the network Empirical Risk Optimization problem statement L03.5 A brief note on derivatives Multiple variables Minimization L04 Backpropagation Chain rule / Subgradient Backpropagation / Vector formulation L05 Convergence Backpropagation prefers consistency over perfection(which is good) Second-order method problem / learning rate choose L06 Optimization Rprop / Quickprop Momentum / Nestorovâ€™s Accelerated Gradient Batch / Stochastic / Mini-batch gradient descent L07 Optimizers and regularizers Second moments: RMS Prop / Adam Batch normalization Regularizer / dropout L08 Motivation of CNN The need for shift invariance Scan network / Why distributing scan / Receptive Field / Stride / Pooling L09 Cascade Correlation Why Is Backprop So Slow? The advantages of cascade correlation L10 CNN architecture Architecture / size of parameters / convolution layer / maxpooling L11 Using CNNs to understand the neural basis of vision (guest lecture) L12 Backpropagation in CNNs Computing âˆ‡Z(l)Div\\nabla_{Z(l)} D i vâˆ‡Z(l)â€‹Div / âˆ‡Y(lâˆ’1)Div\\nabla_{Y(l-1)} D i vâˆ‡Y(lâˆ’1)â€‹Div / âˆ‡w(l)Div\\nabla_{w(l)} D i vâˆ‡w(l)â€‹Div Regular convolution running on shifted derivative maps using flipped filter Derivative of Max pooling / Mean pooling Transposed Convolution / Depth-wise convolution Le-net 5 / AlexNet / VGGNet / Googlenet / Resnet / Densenet L13 Recurrent Networks Model / Architecture Back Propagation Through Time Bidirectional RNN L14 Stability analysis and LSTMs Stability: memory ability / saturate / different activation Vanishing gradient LSTM: architecture / forward / backward Gated Recurrent Units (GRU) L15 Divergence of RNN One to one / Many to many / Many to one / Seq2seq divergence Language modelling: Representing words L16 Connectionist Temporal Classification Sequence to sequence model / time synchronous / order synchronous Iterative estimate output table: viterbi algorithm / expected divergence Repetitive decoding problem / Beam search L17 Seq2seq & Attention Autoencoder / attention weight / beam search L18 Representation Autoencoder / non-linear manifold L19 Hopfield network Loopy network / energy / content-addressable memory Store a specific pattern / orthogonal patterns L20 Boltzmann machines 1 Training hopfield nets: Geometric approach / Optimization Boltzmann Distribution L21 Boltzmann machines 2 Stochastic system: Boltzmann machines Training / Sampling of this model , as well as Restricted Boltzmann Machines L22 Variational Autoencoders 1 Generative models: PCA, Mixture Gaussian, Factor analysis, Autoencoder EM algorithm for generative model L23 Variational Autoencoders 1 Non-linear Gaussian Model VAEs Ref ä¼˜åŒ–å™¨å¯¹æ¯” BGD / SGD / MBGD / Momentum / NAG / Adagrad / Adadelta / RMSprop / Adam Activation Functions Sigmoid / Relu / Leaky ReLU Vanishing gradient problem CS224d The Vanishing Gradient Problem A good illustration of NN KLæ•£åº¦ä¸äº¤å‰ç†µåŒºåˆ«ä¸è”ç³» @Last updated at 5/11/2021 "},"L02 Network represent.html":{"url":"L02 Network represent.html","title":"1 Network Represent","keywords":"","body":"Preliminary Perceptron Threshold unit â€œFiresâ€ if the weighted sum of inputs exceeds a threshold Soft perceptron Using sigmoid function instead of a threshold at the output Activation: The function that acts on the weighted combination of inputs (and threshold) Affine combination Different from Linear combination: the result of mapping zero is not zero. Multi-layer perceptron Depth Is the length of the longest path from a source to a sink Deep: Depth greater than 2 Inputs/Outputs are real or Boolean stimuli What can this network compute? Universal Boolean functions A perceptron can model any simple binary Boolean gate Using weight 1 or -1 to model function The universal AND gate: (â‹€i=1LXi)âˆ§(â‹€i=L+1NXË‰i)(\\bigwedge_{i=1}^{L} X_{i}) \\wedge(\\bigwedge_{i=L+1}^{N} \\bar{X}_{i})(â‹€i=1Lâ€‹Xiâ€‹)âˆ§(â‹€i=L+1Nâ€‹XË‰iâ€‹) The universal OR gate: (â‹i=1LXi)âˆ¨(â‹i=L+1NXË‰i)(\\bigvee_{i=1}^{L} X_{i}) \\vee(\\bigvee_{i=L+1}^{N} \\bar{X}_{i})(â‹i=1Lâ€‹Xiâ€‹)âˆ¨(â‹i=L+1Nâ€‹XË‰iâ€‹) Cannot compute an XOR MLPs can compute the XOR MLPs are universal Boolean functions Can compute any Boolean function A Boolean function is just a truth table So expressed the result in disjunctive normal form, like Y=XË‰1XË‰2X3X4XË‰5+XË‰1X2XË‰3X4X5+XË‰1X2X3XË‰4XË‰5+X1XË‰2XË‰3XË‰4X5+X1XË‰2X3X4X5+X1X2XË‰3XË‰4X5 \\begin{aligned} Y=& \\bar{X}_1 \\bar{X}_2 X_3 X_4 \\bar{X}_5+\\bar{X}_1 X_2 \\bar{X}_3 X_4 X_5+\\bar{X}_1 X_2 X_3 \\bar{X}_4 \\bar{X}_5+X_1 \\bar{X}_2 \\bar{X}_3 \\bar{X}_4 X_5+X_1 \\bar{X}_2 X_3 X_4 X_5+X_1 X_2 \\bar{X}_3 \\bar{X}_4 X_5 \\end{aligned} Y=â€‹XË‰1â€‹XË‰2â€‹X3â€‹X4â€‹XË‰5â€‹+XË‰1â€‹X2â€‹XË‰3â€‹X4â€‹X5â€‹+XË‰1â€‹X2â€‹X3â€‹XË‰4â€‹XË‰5â€‹+X1â€‹XË‰2â€‹XË‰3â€‹XË‰4â€‹X5â€‹+X1â€‹XË‰2â€‹X3â€‹X4â€‹X5â€‹+X1â€‹X2â€‹XË‰3â€‹XË‰4â€‹X5â€‹â€‹ In this case, need 5 neurons in the hidden layer. Need for depth A one-hidden-layer MLP is a Universal Boolean Function But the largest number of perceptrons is expontial: 2N2^N2N How about depth? Will require 3(Nâˆ’1)3(N-1)3(Nâˆ’1) perceptrons, linear in NNN to express the same function Using associatable rules, can be arranged in 2logâ¡2N2\\log_2 N2log2â€‹N layers eg. model O=WâŠ•XâŠ•YâŠ•ZO=W \\oplus X \\oplus Y \\oplus ZO=WâŠ•XâŠ•YâŠ•Z The challenge of depth Using only KKK hidden layers will require O(2CN)O(2^{CN})O(2CN) neurons in the KKKth layer, where C=2âˆ’(kâˆ’1)/2C = 2^{-(k-1)/2}C=2âˆ’(kâˆ’1)/2 A network with fewer than the minimum required number of neurons cannot model the function Universal classifiers Composing complicated â€œdecisionâ€ boundaries Using OR to create more decision boundaries Can compose arbitrarily complex decision boundaries Even using one-layer MLP Need for depth A naiÌˆve one-hidden-layer neural network will required infinite hidden neurons Construct basic unit and add more layers to decrese #neurons The number of neurons required in a shallow network is potentially exponential in the dimensionality of the input Universal approximators A one-layer MLP can model an arbitrary function of a single input MLPs can actually compose arbitrary functions in any number of dimensions Even without \"activation\" Activation A universal map from the entire domain of input values to the entire range of the output activation Optimal depth and width Deeper networks will require far fewer neurons for the same approximation error Sufficiency of architecture Not all architectures can represent any function Continuous activation functions result in graded output at the layer To capture information \"missed\" by the lower layer Width vs. Activations vs. Depth Narrow layers can still pass information to subsequent layers if the activation function is sufficiently graded But will require greater depth, to permit later layers to capture patterns Capacity of the network Information or Storage: how many patterns can it remember VC dimension: bounded by the square of the number of ..weights.. in the network Straight forward: largest number of disconnected convex regions it can represent A network with insufficient capacity cannot exactly model a function that requires a greater minimal number of convex hulls than the capacity of the network "},"L03 A brief note on derivatives.html":{"url":"L03 A brief note on derivatives.html","title":"2 A Brief Note On Derivatives","keywords":"","body":"What is derivatives? A derivative of a function at any point tells us how much a minute increment to the argument of the function will increment the value of the function To be clear, what we want is not differentiable, but how the change effects the outputs. Based on the fact that at a fine enough resolution, any smooth, continuous function is locally linear at any point. So we can express like this Î”y=Î±Î”x \\Delta y=\\alpha \\Delta x Î”y=Î±Î”x Multivariate scalar function Î”y=Î±1Î”x1+Î±2Î”x2+â‹¯+Î±DÎ”xD \\Delta y=\\alpha_{1} \\Delta x_{1}+\\alpha_{2} \\Delta x_{2}+\\cdots+\\alpha_{D} \\Delta x_{D} Î”y=Î±1â€‹Î”x1â€‹+Î±2â€‹Î”x2â€‹+â‹¯+Î±Dâ€‹Î”xDâ€‹ The partial derivative Î±i\\alpha_iÎ±iâ€‹ gives us how yyy increments when only xix_ixiâ€‹ is incremented It can be expressed as: Î”y=âˆ‡xyÎ”x \\Delta y=\\nabla_{x} y \\Delta x Î”y=âˆ‡xâ€‹yÎ”x where âˆ‡xy=[âˆ‚yâˆ‚x1â‹¯âˆ‚yâˆ‚xD] \\nabla_{\\mathrm{x}} y=\\left[\\frac{\\partial y}{\\partial x_{1}} \\quad \\cdots \\quad \\frac{\\partial y}{\\partial x_{D}}\\right] âˆ‡xâ€‹y=[âˆ‚x1â€‹âˆ‚yâ€‹â‹¯âˆ‚xDâ€‹âˆ‚yâ€‹] Optimization Single variable Three different critical point with zero derivative The second derivative is â‰¥0\\ge 0â‰¥0 at minima â‰¤0\\le 0â‰¤0 at maxima =0=0=0 at inflection points multiple variables df(X)=âˆ‡Xf(X)dX d f(X)=\\nabla_{X} f(X) d X df(X)=âˆ‡Xâ€‹f(X)dX The gradient is the transpose of the derivative âˆ‡Xf(X)T\\nabla_{X} f(X)^{T}âˆ‡Xâ€‹f(X)T(give us the change in f(x)f(x)f(x) for tiny variations in XXX) This is a vector inner product df(x)d f(x)df(x) is max if dXdXdX is aligned with âˆ‡Xf(X)T\\nabla_{X} f(X)^{\\mathrm{T}}âˆ‡Xâ€‹f(X)T âˆ (âˆ‡Xf(X)T,dX)=0\\angle\\left(\\nabla_{X} f(X)^{\\mathrm{T}}, d X\\right)=0âˆ (âˆ‡Xâ€‹f(X)T,dX)=0 The gradient is the direction of fastest increase in f(x)f(x)f(x) Hessian Unconstrained Minimization of function Solve for ZZZ where the derivative equals to zero: âˆ‡Xf(X)=0 \\nabla_{X} f(X)=0 âˆ‡Xâ€‹f(X)=0 Compute the Hessian Matrix at the candidate solution and verify that Hessian is positive definite (eigenvalues positive) -> to identify local minima Hessian is negative definite (eigenvalues negative) -> to identify local maxima Closed form are not available To find a maximum move in the direction of the gradient xk+1=xk+Î·kâˆ‡xf(xk)T x^{k+1}=x^{k}+\\eta^{k} \\nabla_{x} f\\left(x^{k}\\right)^{T} xk+1=xk+Î·kâˆ‡xâ€‹f(xk)T To find a minimum move exactly opposite the direction of the gradient xk+1=xkâˆ’Î·kâˆ‡xf(xk)T x^{k+1}=x^{k}-\\eta^{k} \\nabla_{x} f\\left(x^{k}\\right)^{T} xk+1=xkâˆ’Î·kâˆ‡xâ€‹f(xk)T Choose steps fixed step size iteration-dependent step size: critical for fast optimization Convergence For convex functions gradient descent will always find the minimum. For non-convex functions it will find a local minimum or an inflection point "},"L03 Learning the network.html":{"url":"L03 Learning the network.html","title":"3 Learning The Network","keywords":"","body":" How do we compose the network that performs the requisite function? Preliminary The bias can also be viewed as the weight of another input component that is always set to 1 z=âˆ‘iwixiz=\\sum_{i} w_{i} x_{i}z=âˆ‘iâ€‹wiâ€‹xiâ€‹ What we learn: The ..parameters.. of the network Learning the network: Determining the values of these parameters such that the network computes the desired function How to learn a network? W^=argminâ¡Wâˆ«Xdivâ¡(f(X;W),g(X))d \\widehat{\\boldsymbol{W}}=\\underset{W}{\\operatorname{argmin}} \\int_{X} \\operatorname{div}(f(X ; W), g(X)) d W=Wargminâ€‹âˆ«Xâ€‹div(f(X;W),g(X))d div() is a divergence function thet goes to zero when f(X;W)=g(X)f(X ; W)=g(X)f(X;W)=g(X) But in practice g(x)g(x)g(x) will not have such specification Sample g(x)g(x)g(x): just gather training data Learning Simple perceptron do For i=1..Ntraini = 1.. N_{train}i=1..Ntrainâ€‹ O(xi)=sign(WTXi)O(x_i) = sign(W^TX_i)O(xiâ€‹)=sign(WTXiâ€‹) if O(xi)â‰ yiO(x_i) \\neq y_iO(xiâ€‹)â‰ yiâ€‹ W=W+YiXiW = W+Y_iX_iW=W+Yiâ€‹Xiâ€‹ until no more classification errors A more complex problem This can be perfectly represented using an MLP But perveptron algorithm require linearly separated labels to be learned in lower-level neurons An exponential search over inputs So we need differentiable function to compute the change in the output for ..small.. changes in either the input or the weights Empirical Risk Minimization Assuming XXX is a random variable: W^=argminâ¡Wâˆ«Xdivâ¡(f(X;W),g(X))P(X)dX=argminâ¡WE[divâ¡(f(X;W),g(X))] \\begin{aligned} \\widehat{\\boldsymbol{W}}=& \\underset{W}{\\operatorname{argmin}} \\int_{X} \\operatorname{div}(f(X ; W), g(X)) P(X) d X \\\\\\\\ &=\\underset{W}{\\operatorname{argmin}} E[\\operatorname{div}(f(X ; W), g(X))] \\end{aligned} W=â€‹Wargminâ€‹âˆ«Xâ€‹div(f(X;W),g(X))P(X)dX=Wargminâ€‹E[div(f(X;W),g(X))]â€‹ Sample g(X)g(X)g(X), where di=g(Xi)+noised_{i}=g\\left(X_{i}\\right)+ noisediâ€‹=g(Xiâ€‹)+noise, estimate function from the samples The empirical estimate of the expected error is the average error over the samples E[divâ¡(f(X;W),g(X))]â‰ˆ1Nâˆ‘i=1Ndivâ¡(f(Xi;W),di) E[\\operatorname{div}(f(X ; W), g(X))] \\approx \\frac{1}{N} \\sum_{i=1}^{N} \\operatorname{div}\\left(f\\left(X_{i} ; W\\right), d_{i}\\right) E[div(f(X;W),g(X))]â‰ˆN1â€‹i=1âˆ‘Nâ€‹div(f(Xiâ€‹;W),diâ€‹) Empirical average error (Empirical Risk) on all training data Lossâ¡(W)=1Nâˆ‘idivâ¡(f(Xi;W),di) \\operatorname{Loss}(W)=\\frac{1}{N} \\sum_{i} \\operatorname{div}\\left(f\\left(X_{i} ; W\\right), d_{i}\\right) Loss(W)=N1â€‹iâˆ‘â€‹div(f(Xiâ€‹;W),diâ€‹) Estimate the parameters to minimize the empirical estimate of expected error W^=argminâ¡WLossâ¡(W) \\widehat{\\boldsymbol{W}}=\\underset{W}{\\operatorname{argmin}} \\operatorname{Loss}(W) W=Wargminâ€‹Loss(W) Problem statement Given a training set of input-output pairs (X_1,d_1),(X_2,d_2),â€¦,(X_N,d_N) \\left(\\boldsymbol{X}\\_{1}, \\boldsymbol{d}\\_{1}\\right),\\left(\\boldsymbol{X}\\_{2}, \\boldsymbol{d}\\_{2}\\right), \\ldots,\\left(\\boldsymbol{X}\\_{N}, \\boldsymbol{d}\\_{N}\\right) (X_1,d_1),(X_2,d_2),â€¦,(X_N,d_N) Minimize the following function Lossâ¡(W)=1Nâˆ‘idivâ¡(f(Xi;W),di) \\operatorname{Loss}(W)=\\frac{1}{N} \\sum_{i} \\operatorname{div}\\left(f\\left(X_{i} ; W\\right), d_{i}\\right) Loss(W)=N1â€‹iâˆ‘â€‹div(f(Xiâ€‹;W),diâ€‹) This is problem of function minimization An instance of optimization "},"L04 Backpropagation.html":{"url":"L04 Backpropagation.html","title":"4 Backpropagation","keywords":"","body":" a way to solve minimization problem Problem setup Input-output pairs: not to mention Representing the output: one-hot vector yi=expâ¡(zi)âˆ‘jexpâ¡(zj) y_{i}=\\frac{\\exp \\left(z_{i}\\right)}{\\sum_{j} \\exp \\left(z_{j}\\right)} yiâ€‹=âˆ‘jâ€‹exp(zjâ€‹)exp(ziâ€‹)â€‹ two classes of softmax = sigmoid Divergence: must be differentiable For real-valued output vectors, the (scaled) L2L_2L2â€‹ divergence Divâ¡(Y,d)=12âˆ¥Yâˆ’dâˆ¥2=12âˆ‘i(yiâˆ’di)2 \\operatorname{Div}(Y, d)=\\frac{1}{2}\\|Y-d\\|^{2}=\\frac{1}{2} \\sum_{i}\\left(y_{i}-d_{i}\\right)^{2} Div(Y,d)=21â€‹âˆ¥Yâˆ’dâˆ¥2=21â€‹iâˆ‘â€‹(yiâ€‹âˆ’diâ€‹)2 For binary classifier Divâ¡(Y,d)=âˆ’dlogâ¡Yâˆ’(1âˆ’d)logâ¡(1âˆ’Y) \\operatorname{Div}(Y, d)=-\\operatorname{dlog} Y-(1-d) \\log (1-Y) Div(Y,d)=âˆ’dlogYâˆ’(1âˆ’d)log(1âˆ’Y) Note: the derivative is not zero even d=Yd = Yd=Y, but it can converge very quickly For multi-class classification Divâ¡(Y,d)=âˆ’âˆ‘idilogâ¡yi=âˆ’logâ¡yc \\operatorname{Div}(Y, d)=-\\sum_{i} d_{i} \\log y_{i}=-\\log y_{c} Div(Y,d)=âˆ’iâˆ‘â€‹diâ€‹logyiâ€‹=âˆ’logycâ€‹ If yc1y_c ycâ€‹1 , the slope is negative w.r.t. ycy_cycâ€‹, indicates increasing ycy_cycâ€‹ will reduce divergence Train the network Distributed Chain rule y=f(g1(x),g1(x),â€¦,gM(x)) y=f\\left(g_{1}(x), g_{1}(x), \\ldots, g_{M}(x)\\right) y=f(g1â€‹(x),g1â€‹(x),â€¦,gMâ€‹(x)) dydx=âˆ‚fâˆ‚g1(x)dg1(x)dx+âˆ‚fâˆ‚g2(x)dg2(x)dx+â‹¯+âˆ‚fâˆ‚gM(x)dgM(x)dx \\frac{d y}{d x}=\\frac{\\partial f}{\\partial g_{1}(x)} \\frac{d g_{1}(x)}{d x}+\\frac{\\partial f}{\\partial g_{2}(x)} \\frac{d g_{2}(x)}{d x}+\\cdots+\\frac{\\partial f}{\\partial g_{M}(x)} \\frac{d g_{M}(x)}{d x} dxdyâ€‹=âˆ‚g1â€‹(x)âˆ‚fâ€‹dxdg1â€‹(x)â€‹+âˆ‚g2â€‹(x)âˆ‚fâ€‹dxdg2â€‹(x)â€‹+â‹¯+âˆ‚gMâ€‹(x)âˆ‚fâ€‹dxdgMâ€‹(x)â€‹ Backpropagation For each layer: we caculate âˆ‚Divâˆ‚yi\\frac{\\partial D i v}{\\partial y_{i}}âˆ‚yiâ€‹âˆ‚Divâ€‹,âˆ‚Dicvâˆ‚z\\frac{\\partial Dicv}{\\partial z}âˆ‚zâˆ‚Dicvâ€‹, and âˆ‚Divâˆ‚wij\\frac{\\partial Div}{\\partial w_{ij}}âˆ‚wijâ€‹âˆ‚Divâ€‹ For ouput layer It is easy to caculate âˆ‚Divâˆ‚yi(N)\\frac{\\partial D i v}{\\partial y_{i}^{(N)}}âˆ‚yi(N)â€‹âˆ‚Divâ€‹ So: âˆ‚Divâˆ‚zi(N)=fNâ€²(zi(N))âˆ‚Divâˆ‚yi(N)\\frac{\\partial D i v}{\\partial z_{i}^{(N)}}=f_{N}^{\\prime}\\left(z_{i}^{(N)}\\right) \\frac{\\partial D i v}{\\partial y_{i}^{(N)}}âˆ‚zi(N)â€‹âˆ‚Divâ€‹=fNâ€²â€‹(zi(N)â€‹)âˆ‚yi(N)â€‹âˆ‚Divâ€‹ âˆ‚Divâˆ‚wij(N)=âˆ‚zj(N)âˆ‚wij(N)âˆ‚Divâˆ‚zj(N)\\frac{\\partial D i v}{\\partial w_{ij}^{(N)}}=\\frac{\\partial z_{j}^{(N)}}{\\partial w_{ij}^{(N)}} \\frac{\\partial D i v}{\\partial z_{j}^{(N)}}âˆ‚wij(N)â€‹âˆ‚Divâ€‹=âˆ‚wij(N)â€‹âˆ‚zj(N)â€‹â€‹âˆ‚zj(N)â€‹âˆ‚Divâ€‹, where âˆ‚zj(N)âˆ‚wij(N)=yi(N)\\frac{\\partial z_{j}^{(N)}}{\\partial w_{ij}^{(N)}} = y_i^{(N)}âˆ‚wij(N)â€‹âˆ‚zj(N)â€‹â€‹=yi(N)â€‹ Pass on zj(N)=âˆ‘iwij(2)yi(vâˆ’1)z_{j}^{(N)}=\\sum_{i} w_{i j}^{(2)} y_{i}^{(v-1)}zj(N)â€‹=âˆ‘iâ€‹wij(2)â€‹yi(vâˆ’1)â€‹, so âˆ‚zj(N)âˆ‚y1(Nâˆ’1)=wij(N)\\frac{\\partial z_{j}^{(N)}}{\\partial y_{1}^{(N-1)}} = w_{ij}^{(N)}âˆ‚y1(Nâˆ’1)â€‹âˆ‚zj(N)â€‹â€‹=wij(N)â€‹ âˆ‚Divâˆ‚yi(Nâˆ’1)=âˆ‘jwij(N)âˆ‚Divâˆ‚zj(N)\\frac{\\partial D i v}{\\partial y_{i}^{(N-1)}}=\\sum_{j} w_{i j}^{(N)} \\frac{\\partial D i v}{\\partial z_{j}^{(N)}}âˆ‚yi(Nâˆ’1)â€‹âˆ‚Divâ€‹=âˆ‘jâ€‹wij(N)â€‹âˆ‚zj(N)â€‹âˆ‚Divâ€‹ âˆ‚Divâˆ‚zi(Nâˆ’1)=fNâˆ’1â€²(zi(Nâˆ’1))âˆ‚Divâˆ‚yi(Nâˆ’1)\\frac{\\partial D i v}{\\partial z_{i}^{(N-1)}}=f_{N-1}^{\\prime}(z_{i}^{(N-1)}) \\frac{\\partial D i v}{\\partial y_{i}^{(N-1)}}âˆ‚zi(Nâˆ’1)â€‹âˆ‚Divâ€‹=fNâˆ’1â€²â€‹(zi(Nâˆ’1)â€‹)âˆ‚yi(Nâˆ’1)â€‹âˆ‚Divâ€‹ âˆ‚Divâˆ‚wij(Nâˆ’1)=yi(Nâˆ’2)âˆ‚Divâˆ‚zj(Nâˆ’1)\\frac{\\partial D i v}{\\partial w_{i j}^{(N-1)}}=y_{i}^{(N-2)} \\frac{\\partial D i v}{\\partial z_{j}^{(N-1)}}âˆ‚wij(Nâˆ’1)â€‹âˆ‚Divâ€‹=yi(Nâˆ’2)â€‹âˆ‚zj(Nâˆ’1)â€‹âˆ‚Divâ€‹ Special case Vector activations Vector activations: all outputs are functions of all inputs So the derivatives need to change a little âˆ‚Divâˆ‚zi(k)=âˆ‘jâˆ‚Divâˆ‚yj(k)âˆ‚yj(k)âˆ‚zi(k) \\frac{\\partial D i v}{\\partial z_{i}^{(k)}}=\\sum_{j} \\frac{\\partial D i v}{\\partial y_{j}^{(k)}} \\frac{\\partial y_{j}^{(k)}}{\\partial z_{i}^{(k)}} âˆ‚zi(k)â€‹âˆ‚Divâ€‹=jâˆ‘â€‹âˆ‚yj(k)â€‹âˆ‚Divâ€‹âˆ‚zi(k)â€‹âˆ‚yj(k)â€‹â€‹ Note: derivatives of scalar activations are just a special case of vector activations: âˆ‚yj(k)âˆ‚zi(k)=0Â forÂ iâ‰ j \\frac{\\partial y_{j}^{(k)}}{\\partial z_{i}^{(k)}}=0 \\text { for } i \\neq j âˆ‚zi(k)â€‹âˆ‚yj(k)â€‹â€‹=0Â forÂ iâ‰ j For example, Softmax: yi(k)=expâ¡(zi(k))âˆ‘jexpâ¡(zj(k)) y_{i}^{(k)}=\\frac{\\exp \\left(z_{i}^{(k)}\\right)}{\\sum_{j} \\exp \\left(z_{j}^{(k)}\\right)} yi(k)â€‹=âˆ‘jâ€‹exp(zj(k)â€‹)exp(zi(k)â€‹)â€‹ âˆ‚Divâˆ‚zi(k)=âˆ‘jâˆ‚Divâˆ‚yj(k)âˆ‚yj(k)âˆ‚zi(k) \\frac{\\partial D i v}{\\partial z_{i}^{(k)}}=\\sum_{j} \\frac{\\partial D i v}{\\partial y_{j}^{(k)}} \\frac{\\partial y_{j}^{(k)}}{\\partial z_{i}^{(k)}} âˆ‚zi(k)â€‹âˆ‚Divâ€‹=jâˆ‘â€‹âˆ‚yj(k)â€‹âˆ‚Divâ€‹âˆ‚zi(k)â€‹âˆ‚yj(k)â€‹â€‹ âˆ‚yj(k)âˆ‚zi(k)={yi(k)(1âˆ’yi(k))Â ifÂ i=jâˆ’yi(k)yj(k)Â ifÂ iâ‰ j \\frac{\\partial y_{j}^{(k)}}{\\partial z_{i}^{(k)}}=\\left\\{\\begin{array}{c} y_{i}^{(k)}\\left(1-y_{i}^{(k)}\\right) \\quad \\text { if } i=j \\\\ -y_{i}^{(k)} y_{j}^{(k)} \\quad \\text { if } i \\neq j \\end{array}\\right. âˆ‚zi(k)â€‹âˆ‚yj(k)â€‹â€‹={yi(k)â€‹(1âˆ’yi(k)â€‹)Â ifÂ i=jâˆ’yi(k)â€‹yj(k)â€‹Â ifÂ iâ‰ jâ€‹ Using Keonecker delta Î´ij=1\\delta_{i j}=1Î´ijâ€‹=1 if i=j,0i=j, \\quad 0i=j,0 if iâ‰ ji \\neq jiâ‰ j âˆ‚Divâˆ‚zi(k)=âˆ‘jâˆ‚Divâˆ‚yj(k)yi(k)(Î´ijâˆ’yj(k)) \\frac{\\partial D i v}{\\partial z_{i}^{(k)}}=\\sum_{j} \\frac{\\partial D i v}{\\partial y_{j}^{(k)}} y_{i}^{(k)}\\left(\\delta_{i j}-y_{j}^{(k)}\\right) âˆ‚zi(k)â€‹âˆ‚Divâ€‹=jâˆ‘â€‹âˆ‚yj(k)â€‹âˆ‚Divâ€‹yi(k)â€‹(Î´ijâ€‹âˆ’yj(k)â€‹) Multiplicative networks Some types of networks have multiplicative combination(instead of additive combination) Seen in networks such as LSTMs, GRUs, attention models, etc. So the derivatives need to change âˆ‚Divâˆ‚oi(k)=âˆ‘jwij(k+1)âˆ‚Divâˆ‚zj(k+1) \\frac{\\partial D i v}{\\partial o_{i}^{(k)}}=\\sum_{j} w_{i j}^{(k+1)} \\frac{\\partial D i v}{\\partial z_{j}^{(k+1)}} âˆ‚oi(k)â€‹âˆ‚Divâ€‹=jâˆ‘â€‹wij(k+1)â€‹âˆ‚zj(k+1)â€‹âˆ‚Divâ€‹ âˆ‚Divâˆ‚yj(kâˆ’1)=âˆ‚oi(k)âˆ‚yj(kâˆ’1)âˆ‚Divâˆ‚oi(k)=yl(kâˆ’1)âˆ‚Divâˆ‚oi(k) \\frac{\\partial D i v}{\\partial y_{j}^{(k-1)}}=\\frac{\\partial o_{i}^{(k)}}{\\partial y_{j}^{(k-1)}} \\frac{\\partial D i v}{\\partial o_{i}^{(k)}}=y_{l}^{(k-1)} \\frac{\\partial D i v}{\\partial o_{i}^{(k)}} âˆ‚yj(kâˆ’1)â€‹âˆ‚Divâ€‹=âˆ‚yj(kâˆ’1)â€‹âˆ‚oi(k)â€‹â€‹âˆ‚oi(k)â€‹âˆ‚Divâ€‹=yl(kâˆ’1)â€‹âˆ‚oi(k)â€‹âˆ‚Divâ€‹ A layer of multiplicative combination is a special case of vector activation Non-differentiable activations Activation functions are sometimes not actually differentiable The RELU (Rectified Linear Unit) And its variants: leaky RELU, randomized leaky RELU The â€œmaxâ€ function Subgradient (f(x)âˆ’f(x0))â‰¥vT(xâˆ’x0) \\left(f(x)-f\\left(x_{0}\\right)\\right) \\geq v^{T}\\left(x-x_{0}\\right) (f(x)âˆ’f(x0â€‹))â‰¥vT(xâˆ’x0â€‹) The subgradient is a direction in which the function is guaranteed to increase If the function is differentiable at xxx , the subgradient is the gradient But gradient is not always the subgradient though Vector formulation Define the vectors: Forward pass Backward pass Chain rule y=f(g(x))\\mathbf{y}=\\boldsymbol{f}(\\boldsymbol{g}(\\mathbf{x}))y=f(g(x)) Let z=g(x)z = g(x)z=g(x),y=f(z)y = f(z)y=f(z) So Jy(x)=Jy(z)Jz(x)J_{\\mathbf{y}}(\\mathbf{x})=J_{\\mathbf{y}}(\\mathbf{z}) J_{\\mathbf{z}}(\\mathbf{x})Jyâ€‹(x)=Jyâ€‹(z)Jzâ€‹(x) For scalar functions: D=f(Wy+b)D = f(Wy + b)D=f(Wy+b) Let z=Wy+bz = Wy + bz=Wy+b, D=f(z)D = f(z)D=f(z) âˆ‡xD=âˆ‡z(D)Jz(x)\\nabla_{x} D = \\nabla_z(D)J_z(x)âˆ‡xâ€‹D=âˆ‡zâ€‹(D)Jzâ€‹(x) So for backward process âˆ‡ZNDiv=âˆ‡YDivâˆ‡ZNY\\nabla_{Z_N} Div = \\nabla_Y Div \\nabla_{Z_N}Yâˆ‡ZNâ€‹â€‹Div=âˆ‡Yâ€‹Divâˆ‡ZNâ€‹â€‹Y âˆ‡yNâˆ’1Div=âˆ‡ZNDivâˆ‡yNâˆ’1zN\\nabla_{y_{N-1}}Div = \\nabla_{Z_N} Div \\nabla_{y_{N-1}} z_N âˆ‡yNâˆ’1â€‹â€‹Div=âˆ‡ZNâ€‹â€‹Divâˆ‡yNâˆ’1â€‹â€‹zNâ€‹ âˆ‡WNDiv=yNâˆ’1âˆ‡ZNDiv\\nabla_{W_N} Div = y_{N-1} \\nabla_{Z_N} Divâˆ‡WNâ€‹â€‹Div=yNâˆ’1â€‹âˆ‡ZNâ€‹â€‹Div âˆ‡bNDiv=âˆ‡ZNDiv\\nabla_{b_N} Div = \\nabla_{Z_N} Divâˆ‡bNâ€‹â€‹Div=âˆ‡ZNâ€‹â€‹Div For each layer First compute âˆ‡yDiv\\nabla_{y} Divâˆ‡yâ€‹Div Then compute âˆ‡zDiv\\nabla_{z}Divâˆ‡zâ€‹Div Finally âˆ‡WDiv\\nabla_{W} Divâˆ‡Wâ€‹Div, âˆ‡bDiv\\nabla_{b} Divâˆ‡bâ€‹Div Training Analogy to forward pass "},"L05 Convergence.html":{"url":"L05 Convergence.html","title":"5 Convergence","keywords":"","body":" Convergence issue of gradient descent Backpropagation The divergence function minimized is only a proxy for classification error(like Softmax) Minimizing divergence may not minimize classification error Does not separate the points even though the points are linearly separable This is because the separating solution is not a feasible optimum for the loss function Compare to perceptron Perceptron rule has low bias(makes no errors if possible) But high variance(swings wildly in response to small changes to input) Backprop is minimally changed by new training instances Prefers consistency over perfection(which is good) Convergence Univariate inputs For quadratic surfaces MinimizeÂ E=12aw2+bw+c \\text {Minimize } E=\\frac{1}{2} a w^{2}+b w+c MinimizeÂ E=21â€‹aw2+bw+c w(k+1)=w(k)âˆ’Î·dE(w(k))dw \\mathrm{w}^{(k+1)}=\\mathrm{w}^{(k)}-\\eta \\frac{d E\\left(\\mathrm{w}^{(k)}\\right)}{d \\mathrm{w}} w(k+1)=w(k)âˆ’Î·dwdE(w(k))â€‹ Gradient descent with fixed step size Î·\\etaÎ· to estimate scalar parameter www Using Taylor expansion E(w)=E(w(k))+Eâ€²(w(k))(wâˆ’w(k))+Eâ€²â€²(w(k))(wâˆ’w(k))2 E(w)=E\\left(\\mathbf{w}^{(k)}\\right)+E^{\\prime}\\left(\\mathbf{w}^{(k)}\\right)\\left(w-\\mathbf{w}^{(k)}\\right)+E^{\\prime\\prime}\\left(\\mathbf{w}^{(k)}\\right)\\left(w-\\mathbf{w}^{(k)}\\right)^2 E(w)=E(w(k))+Eâ€²(w(k))(wâˆ’w(k))+Eâ€²â€²(w(k))(wâˆ’w(k))2 So we can get the optimum step size Î·opt=Eâ€²â€²(w(k))âˆ’1\\eta_{opt} = E^{\\prime\\prime}(w^{(k)})^{-1}Î·optâ€‹=Eâ€²â€²(w(k))âˆ’1 For Î·Î·opt\\eta Î·Î·optâ€‹ the algorithm will converge monotonically For 2Î·opt>Î·>Î·opt2\\eta_{opt} > \\eta > \\eta_{opt}2Î·optâ€‹>Î·>Î·optâ€‹, we have oscillating convergence For Î·>2Î·opt\\eta > 2\\eta_{opt}Î·>2Î·optâ€‹, we get divergence For generic differentiable convex objectives also can use Taylor expansion to estimate Using Newton's method Î·opt=(d2E(w(k))dw2)âˆ’1 \\eta_{o p t}=\\left(\\frac{d^{2} E\\left(\\mathrm{w}^{(k)}\\right)}{d w^{2}}\\right)^{-1} Î·optâ€‹=(dw2d2E(w(k))â€‹)âˆ’1 Multivariate inputs Quadratic convex function E=12wTAw+wTb+c E=\\frac{1}{2} \\mathbf{w}^{T} \\mathbf{A} \\mathbf{w}+\\mathbf{w}^{T} \\mathbf{b}+c E=21â€‹wTAw+wTb+c If AAA is diagonal E=12âˆ‘i(aiiwi2+biwi)+c E=\\frac{1}{2} \\sum_{i}\\left(a_{i i} w_{i}^{2}+b_{i} w_{i}\\right)+c E=21â€‹iâˆ‘â€‹(aiiâ€‹wi2â€‹+biâ€‹wiâ€‹)+c We can optimize each coordinate independently Like Î·1,opt=a11âˆ’1\\eta_{1,opt} = a^{-1}_{11}Î·1,optâ€‹=a11âˆ’1â€‹, Î·2,opt=a22âˆ’1\\eta_{2,opt} = a^{-1}_{22}Î·2,optâ€‹=a22âˆ’1â€‹ But Optimal learning rate is different for the different coordinates If updating gradient descent for entire vector, need to satisfy Î·2minâ¡iÎ·i,opt \\eta Î·2iminâ€‹Î·i,optâ€‹ This, however, makes the learning very slow if maxâ¡iÎ·i,optminâ¡iÎ·i,opt\\frac{\\max_i \\eta_{i,opt}}{\\min_i\\eta_{i,opt}}miniâ€‹Î·i,optâ€‹maxiâ€‹Î·i,optâ€‹â€‹ is large Solution: Normalize the objective to have identical eccentricity in all directions Then all of them will have identical optimal learning rates Easier to find a working learning rate Target E=12w^Tw^+b^Tw^+c E=\\frac{1}{2} \\widehat{\\mathbf{w}}^{T} \\widehat{\\mathbf{w}}+\\hat{\\mathbf{b}}^{T} \\widehat{\\mathbf{w}}+c E=21â€‹wTw+b^Tw+c So let w^=Sw\\widehat{\\mathbf{w}}=\\mathbf{S} \\mathbf{w}w=Sw, and S=A0.5S = A^{0.5}S=A0.5, b^=Aâˆ’0.5b\\hat{b} = A^{-0.5}bb^=Aâˆ’0.5b ,w^=A0.5w\\widehat{\\mathbf{w}} = A^{0.5} \\mathbf{w}w=A0.5w Gradient descent rule w^(k+1)=w^(k)âˆ’Î·âˆ‡w^E(w^(k))T \\widehat{\\mathbf{w}}^{(k+1)}=\\widehat{\\mathbf{w}}^{(k)}-\\eta \\nabla_{\\widehat{\\mathbf{w}}} E\\left(\\widehat{\\mathbf{w}}^{(k)}\\right)^{T} w(k+1)=w(k)âˆ’Î·âˆ‡wâ€‹E(w(k))T w(k+1)=w(k)âˆ’Î·Aâˆ’1âˆ‡wE(w(k))T \\mathbf{w}^{(k+1)}=\\mathbf{w}^{(k)}-\\eta \\mathbf{A}^{-1} \\nabla_{\\mathbf{w}} E\\left(\\mathbf{w}^{(k)}\\right)^{T} w(k+1)=w(k)âˆ’Î·Aâˆ’1âˆ‡wâ€‹E(w(k))T So we just need to caculate Aâˆ’1\\mathbf{A}^{-1} Aâˆ’1, and the step size of each direction is all the same(1) For generic differentiable multivariate convex functions Also use Taylor expansion E(w)â‰ˆE(w(k))+âˆ‡wE(w(k))(wâˆ’w(k))+12(wâˆ’w(k))THE(w(k))(wâˆ’w(k))+â‹¯ E(\\mathbf{w}) \\approx E\\left(\\mathbf{w}^{(k)}\\right)+\\nabla_{\\mathbf{w}} E\\left(\\mathbf{w}^{(k)}\\right)\\left(\\mathbf{w}-w^{(k)}\\right)+\\frac{1}{2}\\left(\\mathbf{w}-w^{(k)}\\right)^{T} H_{E}\\left(w^{(k)}\\right)\\left(\\mathbf{w}-w^{(k)}\\right)+\\cdots E(w)â‰ˆE(w(k))+âˆ‡wâ€‹E(w(k))(wâˆ’w(k))+21â€‹(wâˆ’w(k))THEâ€‹(w(k))(wâˆ’w(k))+â‹¯ We get the normalized update rule w(k+1)=w(k)âˆ’Î·HE(w(k))âˆ’1âˆ‡wE(w(k))T \\mathbf{w}^{(k+1)}=\\mathbf{w}^{(k)}-\\eta H_{E}\\left(\\boldsymbol{w}^{(k)}\\right)^{-1} \\nabla_{\\mathbf{w}} E\\left(\\mathbf{w}^{(k)}\\right)^{T} w(k+1)=w(k)âˆ’Î·HEâ€‹(w(k))âˆ’1âˆ‡wâ€‹E(w(k))T Use quadratic approximations to get the maximum Issues Hessian For complex models such as neural networks, with a very large number of parameters, the Hessian is extremely difficult to compute For non-convex functions, the Hessian may not be positive semi-definite, in which case the algorithm can diverge Learning rate For complex models such as neural networks the loss function is often not convex Î·>2Î·opt\\eta > 2\\eta_{opt}Î·>2Î·optâ€‹ can actually help escape local optima However always having Î·>2Î·opt\\eta > 2\\eta_{opt}Î·>2Î·optâ€‹ will ensure that you never ever actually find a solution Using Decaying learning rate "},"L06 Optimization.html":{"url":"L06 Optimization.html","title":"6 Optimization","keywords":"","body":"Problems Decaying learning rates provide googd compromise between escaping poor local minima and convergence Many of the convergence issues arise because we force the same learning rate on all parameters Try to releasing the requirement that a fixed step size is used across all dimensions To be clear, backpropagation is a way to compute derivative, not a algorithm The below is NOT grident desent algorithm Better convergence strategy Derivative-inspired algorithms RProp Resilient propagation Simple first-order algorithm, to be followed independently for each component Steps in different directions are not coupled At each time If the derivative at the current location recommends continuing in the same direction as before (i.e. has not changed sign from earlier): Increase the step(Î±\\alphaÎ± > 1), and continue in the same direction If the derivative has changed sign (i.e. weâ€™ve overshot a minimum) Reduce the step(Î²1\\beta Î²1) and reverse direction Features It is frequently much more efficient than gradient descent No convexity assumption QuickProp Newton updates w(k+1)=w(k)âˆ’Î·Aâˆ’1âˆ‡wE(w(k))T \\mathbf{w}^{(k+1)}=\\mathbf{w}^{(k)}-\\eta \\mathbf{A}^{-1} \\nabla_{\\mathbf{w}} E\\left(\\mathbf{w}^{(k)}\\right)^{T} w(k+1)=w(k)âˆ’Î·Aâˆ’1âˆ‡wâ€‹E(w(k))T Quickprop employs the Newton updates with two modifications It treats each dimension independently wik+1=wikâˆ’Eâ€²â€²(wikâˆ£wjk,jâ‰ i)âˆ’1Eâ€²(wikâˆ£wjk,jâ‰ i) w_{i}^{k+1}=w_{i}^{k}-E^{\\prime \\prime}\\left(w_{i}^{k} | w_{j}^{k}, j \\neq i\\right)^{-1} E^{\\prime}\\left(w_{i}^{k} | w_{j}^{k}, j \\neq i\\right) wik+1â€‹=wikâ€‹âˆ’Eâ€²â€²(wikâ€‹âˆ£wjkâ€‹,jâ‰ i)âˆ’1Eâ€²(wikâ€‹âˆ£wjkâ€‹,jâ‰ i) It approximates the second derivative through finite differences wl,ij(k+1)=wl,ij(k)âˆ’Î”wl,ij(kâˆ’1)Errâ€²(wl,ij(k))âˆ’Errâ€²(wl,ij(kâˆ’1))Errâ¡â€²(wl,ij(k)) w_{l, i j}^{(k+1)}=w_{l, i j}^{(k)}-\\frac{\\Delta w_{l, i j}^{(k-1)}}{E r r^{\\prime}\\left(w_{l, i j}^{(k)}\\right)-E r r^{\\prime}\\left(w_{l, i j}^{(k-1)}\\right)} \\operatorname{Err}^{\\prime}\\left(w_{l, i j}^{(k)}\\right) wl,ij(k+1)â€‹=wl,ij(k)â€‹âˆ’Errâ€²(wl,ij(k)â€‹)âˆ’Errâ€²(wl,ij(kâˆ’1)â€‹)Î”wl,ij(kâˆ’1)â€‹â€‹Errâ€²(wl,ij(k)â€‹) Features Employs Newton updates with empirically derived derivatives Prone to some instability for non-convex objective functions But is still one of the fastest training algorithms for many problems Momentum methods Insight In the direction that converges, it keeps pointing in the same direction Need keep track of oscillations Emphasize steps in directions that converge smoothly In the direction that overshoots, it steps back and forth Shrink steps in directions that bounce around Maintain a running average of all past steps Get longer in directions where gradient stays in the same sign Become shorter in directions where the sign keep flipping Update with the running average, rather than the current gradient Emphasize directions of steady improvement are demonstrably superior to other methods Momentum Update Î”W(k)=Î²Î”W(kâˆ’1)âˆ’Î·âˆ‡WLossâ¡(W(kâˆ’1))T \\Delta W^{(k)}=\\beta \\Delta W^{(k-1)}-\\eta \\nabla_{W} \\operatorname{Loss}\\left(W^{(k-1)}\\right)^{T} Î”W(k)=Î²Î”W(kâˆ’1)âˆ’Î·âˆ‡Wâ€‹Loss(W(kâˆ’1))T W(k)=W(kâˆ’1)+Î”W(k) {W^{(k)}=W^{(k-1)}+\\Delta W^{(k)}} W(k)=W(kâˆ’1)+Î”W(k) First computes the gradient step at the current location: âˆ’Î·âˆ‡WLossâ¡(W(kâˆ’1))T-\\eta \\nabla_{W} \\operatorname{Loss}\\left(W^{(k-1)}\\right)^{T}âˆ’Î·âˆ‡Wâ€‹Loss(W(kâˆ’1))T Then adds in the scaled previous step: Î²Î”W(kâˆ’1)\\beta \\Delta W^{(k-1)}Î²Î”W(kâˆ’1) Nestorovâ€™s Accelerated Gradient Change the order of operations Î”W(k)=Î²Î”W(kâˆ’1)âˆ’Î·âˆ‡WLossâ¡(W(kâˆ’1)+Î²Î”W(kâˆ’1))T \\Delta W^{(k)}=\\beta \\Delta W^{(k-1)}-\\eta \\nabla_{W} \\operatorname{Loss}\\left(W^{(k-1)}+\\beta \\Delta W^{(k-1)}\\right)^{T} Î”W(k)=Î²Î”W(kâˆ’1)âˆ’Î·âˆ‡Wâ€‹Loss(W(kâˆ’1)+Î²Î”W(kâˆ’1))T W(k)=W(kâˆ’1)+Î”W(k) {W^{(k)}=W^{(k-1)}+\\Delta W^{(k)}} W(k)=W(kâˆ’1)+Î”W(k) First extend the previous step: Î²Î”W(kâˆ’1)\\beta \\Delta W^{(k-1)}Î²Î”W(kâˆ’1) Then compute the gradient step at the resultant position: âˆ’Î·âˆ‡WLossâ¡(W(kâˆ’1)+Î²Î”W(kâˆ’1))T-\\eta \\nabla_{W} \\operatorname{Loss}\\left(W^{(k-1)}+\\beta \\Delta W^{(k-1)}\\right)^{T}âˆ’Î·âˆ‡Wâ€‹Loss(W(kâˆ’1)+Î²Î”W(kâˆ’1))T Add the two to obtain the final step Converges much faster than momentum Summary Try the step size for all dimension is bad Treat each dimension independently Try to normalize curvature in all directions Second order methods, e.g. Newton's method Too expensive: require inversion of a giant Hessian Treat each dimension independently RProp / QucikProp Works, but ignores dependence between dimensions Can still be too slow Momentum methods which emphasize directions of steady improvement are demonstrably superior to other methods Incremental updates Batch gradient descent Try to simultaneously adjust the function at all training points We must process all training points before making a single adjustment Stochastic gradient descent Adjust the function at one training point at a time A single pass through the entire training data is called an â€œepochâ€ An epoch over a training set with TTT samples result in TTT updates of parameters We must go through them randomly to get more convergent behavior Otherwise we may get cyclic behavior (hard to converge) Learning rate Correcting the function for individual instances will lead to never-ending, non-convergent updates (correct one, and miss the other) The learning will continuously â€œchaseâ€ the latest sample Correction for individual instances with the eventual miniscule learning rates will not modify the function Drewbacks Batch / Stochastic gradient descent is an unbiased estimate of the expected loss E[Lossâ¡(f(X;W),g(X))]=E[divâ¡(f(X;W),g(X))] E[\\operatorname{Loss}(f(X ; W), g(X))]=E[\\operatorname{div}(f(X ; W), g(X))] E[Loss(f(X;W),g(X))]=E[div(f(X;W),g(X))] But the variance of the empirical risk in batch gradient is {% math_inline %}\\frac{1}{N}{% endmath_inline %} times compared to stochastic gradient descent Like using {% math_inline %}\\frac{1}{N}\\sum{X}{% endmath_inline %} and {% math_inline %}X_i{% endmath_inline %} to estimate {% math_inline %}\\bar{X}{% endmath_inline %} Mini-batch gradient descent Adjust the function at a small, randomly chosen subset of points Also an unbiased estimate of the expected error, and the variance is relatively small compared to SGD The mini-batch size is a hyper parameter to be optimized Convergence depends on learning rate Simple technique: fix learning rate until the error plateaus, then reduce learning rate by a fixed factor (e.g. 10) Advanced methods: Adaptive updates, where the learning rate is itself determined as part of the estimation "},"L07 Optimizater.html":{"url":"L07 Optimizater.html","title":"7 Optimizater","keywords":"","body":"Optimizers Momentum and Nestorovâ€™s method improve convergence by normalizing the mean (first moment) of the derivatives Considering the second moments RMS Prop / Adagrad / AdaDelta / ADAM1 Simple gradient and momentum methods still demonstrate oscillatory behavior in some directions2 Depends on magic step size parameters (learning rate) Need to dampen step size in directions with high motion Second order term (use variation to smooth it) Scale down updates with large mean squared derivatives scale up updates with small mean squared derivatives RMS Prop Notion The squared derivative is âˆ‚w2D=(âˆ‚wD)2\\partial_{w}^{2} D=\\left(\\partial_{w} D\\right)^{2}âˆ‚w2â€‹D=(âˆ‚wâ€‹D)2 The mean squared derivative is E[âˆ‚W2D]E\\left[\\partial_{W}^{2} D\\right]E[âˆ‚W2â€‹D] This is a variant on the basic mini-batch SGD algorithm Updates are by parameter E[âˆ‚w2D]k=Î³E[âˆ‚w2D]kâˆ’1+(1âˆ’Î³)(âˆ‚w2D)k E\\left[\\partial_{w}^{2} D\\right]_{k}=\\gamma E\\left[\\partial_{w}^{2} D\\right]_{k-1}+(1-\\gamma)\\left(\\partial_{w}^{2} D\\right)_{k} E[âˆ‚w2â€‹D]kâ€‹=Î³E[âˆ‚w2â€‹D]kâˆ’1â€‹+(1âˆ’Î³)(âˆ‚w2â€‹D)kâ€‹ wk+1=wkâˆ’Î·E[âˆ‚w2D]k+Ïµâˆ‚wD w_{k+1}=w_{k}-\\frac{\\eta}{\\sqrt{E\\left[\\partial_{w}^{2} D\\right]_{k}+\\epsilon}} \\partial_{w} D wk+1â€‹=wkâ€‹âˆ’E[âˆ‚w2â€‹D]kâ€‹+Ïµâ€‹Î·â€‹âˆ‚wâ€‹D If using the same step over a long period, E[âˆ‚w2D]k+Ïµâ‰ˆâˆ£âˆ‚wDâˆ£\\sqrt{E\\left[\\partial_{w}^{2} D\\right]_{k}+\\epsilon} \\approx |\\partial_{w} D|E[âˆ‚w2â€‹D]kâ€‹+Ïµâ€‹â‰ˆâˆ£âˆ‚wâ€‹Dâˆ£ So wk+1=wkâˆ’sign(âˆ‚wD)Î·w_{k+1}=w_{k}-\\text{sign} (\\partial_{w} D )\\etawk+1â€‹=wkâ€‹âˆ’sign(âˆ‚wâ€‹D)Î· Only the sign remain, similar to RProp Adam RMS prop only considers a second-moment normalized version of the current gradient ADAM utilizes a smoothed version of the momentum-augmented gradient Considers both first and second moments mk=Î´mkâˆ’1+(1âˆ’Î´)(âˆ‚wD)k m_{k}=\\delta m_{k-1}+(1-\\delta)\\left(\\partial_{w} D\\right)_{k} mkâ€‹=Î´mkâˆ’1â€‹+(1âˆ’Î´)(âˆ‚wâ€‹D)kâ€‹ vk=Î³vkâˆ’1+(1âˆ’Î³)(âˆ‚w2D)k v_{k}=\\gamma v_{k-1}+(1-\\gamma)\\left(\\partial_{w}^{2} D\\right)_{k} vkâ€‹=Î³vkâˆ’1â€‹+(1âˆ’Î³)(âˆ‚w2â€‹D)kâ€‹ mk^=mk1âˆ’Î´k,v^k=vk1âˆ’Î³k \\hat{m_k}=\\frac{m_{k}}{1-\\delta^{k}}, \\quad \\quad \\hat{v}_{k}=\\frac{v_{k}}{1-\\gamma^{k}} mkâ€‹^â€‹=1âˆ’Î´kmkâ€‹â€‹,v^kâ€‹=1âˆ’Î³kvkâ€‹â€‹ wk+1=wkâˆ’Î·v^k+Ïµm^k w_{k+1}=w_{k}-\\frac{\\eta}{\\sqrt{\\hat{v}_{k}+\\epsilon}} \\hat{m}_{k} wk+1â€‹=wkâ€‹âˆ’v^kâ€‹+Ïµâ€‹Î·â€‹m^kâ€‹ Typically Î´â‰ˆ1\\delta \\approx 1Î´â‰ˆ1, initalize mkâˆ’1,vkâˆ’1â‰ˆ0m_{k-1}, v_{k-1} \\approx 0 mkâˆ’1â€‹,vkâˆ’1â€‹â‰ˆ0, so 1âˆ’Î´â‰ˆ01- \\delta \\approx 01âˆ’Î´â‰ˆ0, will be very slow to update in the beginning So we need mk^=mk1âˆ’Î´k\\hat{m_k}=\\frac{m_{k}}{1-\\delta^{k}}mkâ€‹^â€‹=1âˆ’Î´kmkâ€‹â€‹ term to scale up in the beginning Tricks To make the network converge better, we can consider the following aspects The Divergence Dropout Batch normalization Gradient clipping Data augmentation Divergence What shape do we want the divergence function would be? Must be smooth and not have many poor local optima The best type of divergence is steep far from the optimum, but shallow at the optimum But not too shallow(hard to converge to minimum) The choice of divergence affects both the learned network and results Common choices L2 divergence Div=12âˆ‘i(yiâˆ’di)2 D i v=\\frac{1}{2} \\sum_{i}\\left(y_{i}-d_{i}\\right)^{2} Div=21â€‹iâˆ‘â€‹(yiâ€‹âˆ’diâ€‹)2 KL divergence Div=âˆ‘idilogâ¡(di)âˆ’âˆ‘idilogâ¡(yi) \tD i v=\\sum_{i} d_{i} \\log \\left(d_{i}\\right)-\\sum_{i} d_{i} \\log \\left(y_{i}\\right) \tDiv=iâˆ‘â€‹diâ€‹log(diâ€‹)âˆ’iâˆ‘â€‹diâ€‹log(yiâ€‹) L2 is particularly appropriate when attempting to perform regression Numeric prediction For L2 divergence the derivative w.r.t. the pre-activation of the output layer is : âˆ‡z12âˆ¥yâˆ’dâˆ¥2=(yâˆ’d)Jy(z)\\nabla_{z} \\frac{1}{2}\\|y-d\\|^{2}=(y-d) J_{y}(z)âˆ‡zâ€‹21â€‹âˆ¥yâˆ’dâˆ¥2=(yâˆ’d)Jyâ€‹(z) We literally â€œpropagateâ€ the error (yâˆ’d)(y-d)(yâˆ’d) backward Which is why the method is sometimes called â€œerror backpropagationâ€ The KL divergence is better when the intent is classification The output is a probability vector Batch normalization Covariate shifts problem Training assumes the training data are all similarly distributed (So as mini-batch) In practice, each minibatch may have a different distribution Which may occur in each layer of the network Minimize one batch cannot give the correction of other batches Solution Move all batches to have a mean of 0 and unit standard deviation Eliminates covariate shift between batches Batch normalization is a covariate adjustment unit that happens after the weighted addition of inputs (affine combination) but before the application of activation 5 Steps Covariate shift to standard position ui=ziâˆ’Î¼BÏƒB2+Ïµ u_{i}=\\frac{z_{i}-\\mu_{B}}{\\sqrt{\\sigma_{B}^{2}+\\epsilon}} uiâ€‹=ÏƒB2â€‹+Ïµâ€‹ziâ€‹âˆ’Î¼Bâ€‹â€‹ Shift to right position zi^=Î³ui+Î² \t\\hat{z_i} = \\gamma u_i + \\beta \tziâ€‹^â€‹=Î³uiâ€‹+Î² Backpropagation The outputs are now functions of Î¼B\\mu_BÎ¼Bâ€‹ and ÏƒB2\\sigma_B^2ÏƒB2â€‹ which are functions of the entire minibatch Divâ¡(MB)=1Bâˆ‘tDivâ¡(Yt(Xt,Î¼B,ÏƒB2),dt(Xt)) \\operatorname{Div}(M B)=\\frac{1}{B} \\sum_{t} \\operatorname{Div}\\left(Y_{t}\\left(X_{t}, \\mu_{B}, \\sigma_{B}^{2}\\right), d_{t}\\left(X_{t}\\right)\\right) Div(MB)=B1â€‹tâˆ‘â€‹Div(Ytâ€‹(Xtâ€‹,Î¼Bâ€‹,ÏƒB2â€‹),dtâ€‹(Xtâ€‹)) The divergence for each YtY_tYtâ€‹ depends on all the XtX_tXtâ€‹ within the mini-batch Is a vector function over the mini-batch Using influence diagram to caculate derivatives3 Goal We need to caculate the learnable parameters dDivÎ³,dDivÎ²\\frac{d D i v}{\\gamma}, \\frac{d D i v}{\\beta}Î³dDivâ€‹,Î²dDivâ€‹, and the affine combination dDivzi\\frac{d D i v}{z_i}ziâ€‹dDivâ€‹ âˆ‚Divâˆ‚zi=âˆ‚Divâˆ‚uiâ‹…âˆ‚uiâˆ‚zi+âˆ‚Divâˆ‚ÏƒB2â‹…âˆ‚ÏƒB2âˆ‚zi+âˆ‚Divâˆ‚Î¼Bâ‹…âˆ‚Î¼Bâˆ‚zi \\frac{\\partial D i v}{\\partial z_{i}}=\\frac{\\partial D i v}{\\partial u_{i}} \\cdot \\frac{\\partial u_{i}}{\\partial z_{i}}+\\frac{\\partial D i v}{\\partial \\sigma_{B}^{2}} \\cdot \\frac{\\partial \\sigma_{B}^{2}}{\\partial z_{i}}+\\frac{\\partial D i v}{\\partial \\mu_{B}} \\cdot \\frac{\\partial \\mu_{B}}{\\partial z_{i}} âˆ‚ziâ€‹âˆ‚Divâ€‹=âˆ‚uiâ€‹âˆ‚Divâ€‹â‹…âˆ‚ziâ€‹âˆ‚uiâ€‹â€‹+âˆ‚ÏƒB2â€‹âˆ‚Divâ€‹â‹…âˆ‚ziâ€‹âˆ‚ÏƒB2â€‹â€‹+âˆ‚Î¼Bâ€‹âˆ‚Divâ€‹â‹…âˆ‚ziâ€‹âˆ‚Î¼Bâ€‹â€‹ So we need extra âˆ‚Divâˆ‚ui,âˆ‚Divâˆ‚ÏƒB2,âˆ‚Divâˆ‚Î¼B\\frac{\\partial D i v}{\\partial u_{i}},\\frac{\\partial D i v}{\\partial \\sigma_{B}^{2}},\\frac{\\partial D i v}{\\partial \\mu_{B}} âˆ‚uiâ€‹âˆ‚Divâ€‹,âˆ‚ÏƒB2â€‹âˆ‚Divâ€‹,âˆ‚Î¼Bâ€‹âˆ‚Divâ€‹ Preparation Î¼B=1Bâˆ‘i=1BziÏƒB2=1Bâˆ‘i=1B(ziâˆ’Î¼B)2 \\mu_{B}=\\frac{1}{B} \\sum_{i=1}^{B} z_{i}\\quad \\quad \\sigma_{B}^{2}=\\frac{1}{B} \\sum_{i=1}^{B}\\left(z_{i}-\\mu_{B}\\right)^{2} Î¼Bâ€‹=B1â€‹i=1âˆ‘Bâ€‹ziâ€‹ÏƒB2â€‹=B1â€‹i=1âˆ‘Bâ€‹(ziâ€‹âˆ’Î¼Bâ€‹)2 ui=ziâˆ’Î¼BÏƒB2+Ïµzi^=Î³ui+Î² u_{i}=\\frac{z_{i}-\\mu_{B}}{\\sqrt{\\sigma_{B}^{2}+\\epsilon}} \\quad \\quad \\hat{z_i} = \\gamma u_i + \\beta uiâ€‹=ÏƒB2â€‹+Ïµâ€‹ziâ€‹âˆ’Î¼Bâ€‹â€‹ziâ€‹^â€‹=Î³uiâ€‹+Î² For the first term âˆ‚Divâˆ‚uiâ‹…âˆ‚uiâˆ‚zi\\frac{\\partial D i v}{\\partial u_{i}} \\cdot \\frac{\\partial u_{i}}{\\partial z_{i}}âˆ‚uiâ€‹âˆ‚Divâ€‹â‹…âˆ‚ziâ€‹âˆ‚uiâ€‹â€‹ First caculate dDivÎ³,dDivÎ²\\frac{d D i v}{\\gamma}, \\frac{d D i v}{\\beta}Î³dDivâ€‹,Î²dDivâ€‹ dDivdÎ²=dDivdz^dDivdÎ³=udDivdz^ \\frac{d D i v}{d \\beta}=\\frac{d D i v}{d \\hat{z}} \\quad \\quad \\frac{d D i v}{d \\gamma}=u \\frac{d D i v}{d \\hat{z}} dÎ²dDivâ€‹=dz^dDivâ€‹dÎ³dDivâ€‹=udz^dDivâ€‹ âˆ‚uiâˆ‚zi=1ÏƒB2+Ïµ\\frac{\\partial u_{i}}{\\partial z_{i}} = \\frac{1}{\\sqrt{\\sigma^2_B +\\epsilon}}âˆ‚ziâ€‹âˆ‚uiâ€‹â€‹=ÏƒB2â€‹+Ïµâ€‹1â€‹, so the first term = âˆ‚Divâˆ‚uiâ‹…1ÏƒB2+Ïµ\\frac{\\partial D i v}{\\partial u_{i}} \\cdot \\frac{1}{\\sqrt{\\sigma_{B}^{2}+\\epsilon}}âˆ‚uiâ€‹âˆ‚Divâ€‹â‹…ÏƒB2â€‹+Ïµâ€‹1â€‹ For the second term âˆ‚Divâˆ‚ÏƒB2â‹…âˆ‚ÏƒB2âˆ‚zi\\frac{\\partial D i v}{\\partial \\sigma_{B}^{2}} \\cdot \\frac{\\partial \\sigma_{B}^{2}}{\\partial z_{i}}âˆ‚ÏƒB2â€‹âˆ‚Divâ€‹â‹…âˆ‚ziâ€‹âˆ‚ÏƒB2â€‹â€‹ Caculate âˆ‚Divâˆ‚ÏƒB2\\frac{\\partial D i v}{\\partial \\sigma_{B}^{2}}âˆ‚ÏƒB2â€‹âˆ‚Divâ€‹ âˆ‚Divâˆ‚ÏƒB2=âˆ‘âˆ‚Divâˆ‚uiâˆ‚uiâˆ‚ÏƒB2 \\frac{\\partial Div}{\\partial \\sigma_{B}^{2}}=\\sum \\frac{\\partial Div}{\\partial u_{i}} \\frac{\\partial u_{i}}{\\partial \\sigma_{B}^{2}} âˆ‚ÏƒB2â€‹âˆ‚Divâ€‹=âˆ‘âˆ‚uiâ€‹âˆ‚Divâ€‹âˆ‚ÏƒB2â€‹âˆ‚uiâ€‹â€‹ âˆ‚Divâˆ‚ÏƒB2=âˆ’12(ÏƒB2+Ïµ)âˆ’3/2âˆ‘i=1Bâˆ‚Divâˆ‚ui(ziâˆ’Î¼B) \\frac{\\partial D i v}{\\partial \\sigma_{B}^{2}}=\\frac{-1}{2}\\left(\\sigma_{B}^{2}+\\epsilon\\right)^{-3 / 2} \\sum_{i=1}^{B} \\frac{\\partial D i v}{\\partial u_{i}}\\left(z_{i}-\\mu_{B}\\right) âˆ‚ÏƒB2â€‹âˆ‚Divâ€‹=2âˆ’1â€‹(ÏƒB2â€‹+Ïµ)âˆ’3/2i=1âˆ‘Bâ€‹âˆ‚uiâ€‹âˆ‚Divâ€‹(ziâ€‹âˆ’Î¼Bâ€‹) And âˆ‚ÏƒB2âˆ‚zi\\frac{\\partial \\sigma_{B}^{2}}{\\partial z_{i}}âˆ‚ziâ€‹âˆ‚ÏƒB2â€‹â€‹ âˆ‚ÏƒB2âˆ‚zi=2(ziâˆ’Î¼B)B \\frac{\\partial \\sigma_{B}^{2}}{\\partial z_{i}}=\\frac{2\\left(z_{i}-\\mu_{B}\\right)}{B} âˆ‚ziâ€‹âˆ‚ÏƒB2â€‹â€‹=B2(ziâ€‹âˆ’Î¼Bâ€‹)â€‹ So the second term = âˆ‚Divâˆ‚ÏƒB2â‹…2(ziâˆ’Î¼B)B\\frac{\\partial D i v}{\\partial \\sigma_{B}^{2}} \\cdot \\frac{2\\left(z_{i}-\\mu_{B}\\right)}{B}âˆ‚ÏƒB2â€‹âˆ‚Divâ€‹â‹…B2(ziâ€‹âˆ’Î¼Bâ€‹)â€‹ Finally for the third term âˆ‚Divâˆ‚Î¼Bâ‹…âˆ‚Î¼Bâˆ‚zi\\frac{\\partial D i v}{\\partial \\mu_{B}} \\cdot \\frac{\\partial \\mu_{B}}{\\partial z_{i}}âˆ‚Î¼Bâ€‹âˆ‚Divâ€‹â‹…âˆ‚ziâ€‹âˆ‚Î¼Bâ€‹â€‹ Caculate âˆ‚Divâˆ‚Î¼B\\frac{\\partial D i v}{\\partial \\mu_{B}}âˆ‚Î¼Bâ€‹âˆ‚Divâ€‹ âˆ‚Divâˆ‚Î¼B=âˆ‘âˆ‚Divâˆ‚Î¼iâˆ‚Î¼iâˆ‚Î¼B+âˆ‚Divâˆ‚ÏƒB2âˆ‚ÏƒB2âˆ‚Î¼B \\frac{\\partial D i v}{\\partial \\mu_B}=\\sum \\frac{\\partial Div}{\\partial \\mu_{i}} \\frac{\\partial \\mu_{i}}{\\partial \\mu_{B}}+\\frac{\\partial Div}{\\partial\\sigma_{B}^{2} } \\frac{\\partial \\sigma_{B}^{2}}{\\partial \\mu_{B}} âˆ‚Î¼Bâ€‹âˆ‚Divâ€‹=âˆ‘âˆ‚Î¼iâ€‹âˆ‚Divâ€‹âˆ‚Î¼Bâ€‹âˆ‚Î¼iâ€‹â€‹+âˆ‚ÏƒB2â€‹âˆ‚Divâ€‹âˆ‚Î¼Bâ€‹âˆ‚ÏƒB2â€‹â€‹ âˆ‚Divâˆ‚Î¼B=(âˆ‘i=1Bâˆ‚Divâˆ‚uiâ‹…âˆ’1ÏƒB2+Ïµ)+âˆ‚Divâˆ‚ÏƒB2â‹…âˆ‘i=1Bâˆ’2(ziâˆ’Î¼B)B \\frac{\\partial D i v}{\\partial \\mu_{B}}=\\left(\\sum_{i=1}^{B} \\frac{\\partial D i v}{\\partial u_{i}} \\cdot \\frac{-1}{\\sqrt{\\sigma_{B}^{2}+\\epsilon}}\\right)+\\frac{\\partial D i v}{\\partial \\sigma_{B}^{2}} \\cdot \\frac{\\sum_{i=1}^{B}-2\\left(z_{i}-\\mu_{B}\\right)}{B} âˆ‚Î¼Bâ€‹âˆ‚Divâ€‹=(i=1âˆ‘Bâ€‹âˆ‚uiâ€‹âˆ‚Divâ€‹â‹…ÏƒB2â€‹+Ïµâ€‹âˆ’1â€‹)+âˆ‚ÏƒB2â€‹âˆ‚Divâ€‹â‹…Bâˆ‘i=1Bâ€‹âˆ’2(ziâ€‹âˆ’Î¼Bâ€‹)â€‹ The last term is zero, and because Î¼z=1Bâˆ‘zi\\mu_z = \\frac{1}{B} \\sum z_iÎ¼zâ€‹=B1â€‹âˆ‘ziâ€‹ âˆ‚Î¼Bâˆ‚zi=1B \\frac{\\partial \\mu_{B}}{\\partial z_{i}}=\\frac{1}{B} âˆ‚ziâ€‹âˆ‚Î¼Bâ€‹â€‹=B1â€‹ So the third term = âˆ‚Divâˆ‚Î¼Bâ‹…1B\\frac{\\partial D i v}{\\partial \\mu_{B}} \\cdot \\frac{1}{B}âˆ‚Î¼Bâ€‹âˆ‚Divâ€‹â‹…B1â€‹ Overall âˆ‚Divâˆ‚zi=âˆ‚Divâˆ‚uiâ‹…1ÏƒB2+Ïµ+âˆ‚Divâˆ‚ÏƒB2â‹…2(ziâˆ’Î¼B)B+âˆ‚Divâˆ‚Î¼Bâ‹…1B \\frac{\\partial D i v}{\\partial z_{i}}=\\frac{\\partial D i v}{\\partial u_{i}} \\cdot \\frac{1}{\\sqrt{\\sigma_{B}^{2}+\\epsilon}}+\\frac{\\partial D i v}{\\partial \\sigma_{B}^{2}} \\cdot \\frac{2\\left(z_{i}-\\mu_{B}\\right)}{B}+\\frac{\\partial D i v}{\\partial \\mu_{B}} \\cdot \\frac{1}{B} âˆ‚ziâ€‹âˆ‚Divâ€‹=âˆ‚uiâ€‹âˆ‚Divâ€‹â‹…ÏƒB2â€‹+Ïµâ€‹1â€‹+âˆ‚ÏƒB2â€‹âˆ‚Divâ€‹â‹…B2(ziâ€‹âˆ’Î¼Bâ€‹)â€‹+âˆ‚Î¼Bâ€‹âˆ‚Divâ€‹â‹…B1â€‹ âˆ‚Divâˆ‚ÏƒB2=âˆ’12(ÏƒB2+Ïµ)âˆ’3/2âˆ‘i=1Bâˆ‚Divâˆ‚ui(ziâˆ’Î¼B) \\frac{\\partial D i v}{\\partial \\sigma_{B}^{2}}=\\frac{-1}{2}\\left(\\sigma_{B}^{2}+\\epsilon\\right)^{-3 / 2} \\sum_{i=1}^{B} \\frac{\\partial D i v}{\\partial u_{i}}\\left(z_{i}-\\mu_{B}\\right) âˆ‚ÏƒB2â€‹âˆ‚Divâ€‹=2âˆ’1â€‹(ÏƒB2â€‹+Ïµ)âˆ’3/2i=1âˆ‘Bâ€‹âˆ‚uiâ€‹âˆ‚Divâ€‹(ziâ€‹âˆ’Î¼Bâ€‹) âˆ‚Divâˆ‚Î¼B=âˆ’1ÏƒB2+Ïµâˆ‘i=1Bâˆ‚Divâˆ‚ui \\frac{\\partial D i v}{\\partial \\mu_{B}}=\\frac{-1}{\\sqrt{\\sigma_{B}^{2}+\\epsilon}}\\sum_{i=1}^{B} \\frac{\\partial D i v}{\\partial u_{i}} âˆ‚Î¼Bâ€‹âˆ‚Divâ€‹=ÏƒB2â€‹+Ïµâ€‹âˆ’1â€‹i=1âˆ‘Bâ€‹âˆ‚uiâ€‹âˆ‚Divâ€‹ Inference On test data, BN requires Î¼B\\mu_BÎ¼Bâ€‹ and ÏƒB2\\sigma_B^2ÏƒB2â€‹ We will use the average over all training minibatches Î¼BN=1Nbatchesâˆ‘batÎ¼B(batch) \\mu_{B N}=\\frac{1}{\\text {Nbatches}} \\sum_{b a t} \\mu_{B}(\\text {batch}) Î¼BNâ€‹=Nbatches1â€‹batâˆ‘â€‹Î¼Bâ€‹(batch) ÏƒBN2=B(Bâˆ’1)Nbatchesâˆ‘batchÏƒB2(batch) \\sigma_{B N}^{2}=\\frac{B}{(B-1) N b a t c h e s} \\sum_{b a t c h} \\sigma_{B}^{2}(\\text {batch}) ÏƒBN2â€‹=(Bâˆ’1)NbatchesBâ€‹batchâˆ‘â€‹ÏƒB2â€‹(batch) Note: these are neuron-specific Î¼B(batch),ÏƒBbatch\\mu_B(batch), \\sigma_B{batch}Î¼Bâ€‹(batch),ÏƒBâ€‹batch are obtained from the final converged network The ğµ/(ğµ âˆ’ 1) term gives us an unbiased estimator for the variance What can it do Improves both convergence rate and neural network performance Anecdotal evidence that BN eliminates the need for dropout To get maximum benefit from BN, learning rates must be increased and learning rate decay can be faster Since the data generally remain in the high-gradient regions of the activations e.g. For sigmoid function, move data to the linear part, the gradient is high Also needs better randomization of training data order Smoothness Smoothness through network structure MLPs are universal approximators For a given number of parameters, deeper networks impose more smoothness than shallow&wide ones Each layer restricts the shape of the function Smoothness through weight constrain Regularizer The \"desiredâ€ output is generally smooth Capture statistical or average trends Overfitting But an unconstrained model will model individual instances instead Why overfitting?4 Using a sigmoid activation, as âˆ£wâˆ£|w|âˆ£wâˆ£ increases, the response becomes steeper Constraining the weights to be low will force slower perceptrons and smoother output response Regularized training: minimize the loss while also minimizing the weights L(W1,W2,â€¦,WK)=Lossâ¡(W1,W2,â€¦,WK)+12Î»âˆ‘kâˆ¥Wkâˆ¥22 L\\left(W_{1}, W_{2}, \\ldots, W_{K}\\right)=\\operatorname{Loss}\\left(W_{1}, W_{2}, \\ldots, W_{K}\\right)+\\frac{1}{2} \\lambda \\sum_{k}\\left\\|W_{k}\\right\\|_{2}^{2} L(W1â€‹,W2â€‹,â€¦,WKâ€‹)=Loss(W1â€‹,W2â€‹,â€¦,WKâ€‹)+21â€‹Î»kâˆ‘â€‹âˆ¥Wkâ€‹âˆ¥22â€‹ Î»\\lambdaÎ» is the regularization parameter whose value depends on how important it is for us to want to minimize the weights Increasing assigns greater importance to shrinking the weights Make greater error on training data, to obtain a more acceptable network Dropout â€œDropoutâ€ is a stochastic data/model erasure method that sometimes forces the network to learn more robust models Bagging method Using ensemble classifiers to improve prediction Dropout For each input, at each iteration, â€œturn offâ€ each neuron with a probability 1âˆ’Î±1-\\alpha1âˆ’Î± Also turn off inputs similarly Backpropagation is effectively performed only over the remaining network The effective network is different for different inputs Effectively learns a network that averages over all possible networks (Bagging) Dropout as a mechanism to increase pattern density Dropout forces the neurons to learn â€œrichâ€ and redundant patterns E.g. without dropout, a noncompressive layer may just â€œcloneâ€ its input to its output Transferring the task of learning to the rest of the network upstream Implementation The expected output of the neuron is yi(k)=Î±Ïƒ(âˆ‘jwji(k)yj(kâˆ’1)+bi(k)) y_{i}^{(k)}=\\alpha \\sigma\\left(\\sum_{j} w_{j i}^{(k)} y_{j}^{(k-1)}+b_{i}^{(k)}\\right) yi(k)â€‹=Î±Ïƒ(jâˆ‘â€‹wji(k)â€‹yj(kâˆ’1)â€‹+bi(k)â€‹) During test, push the a to all outgoing weights zi(k)=âˆ‘jwji(k)yj(kâˆ’1)+bi(k)=âˆ‘jwji(k)Î±Ïƒ(zj(kâˆ’1))+bi(k)=âˆ‘j(Î±wji(k))Ïƒ(zj(kâˆ’1))+bi(k) \\begin{aligned} z_{i}^{(k)} &=\\sum_{j} w_{j i}^{(k)} y_{j}^{(k-1)}+b_{i}^{(k)} \\\\\\\\ &=\\sum_{j} w_{j i}^{(k)} \\alpha \\sigma\\left(z_{j}^{(k-1)}\\right)+b_{i}^{(k)} \\\\\\\\ &=\\sum_{j}\\left(\\alpha w_{j i}^{(k)}\\right) \\sigma\\left(z_{j}^{(k-1)}\\right)+b_{i}^{(k)} \\end{aligned} zi(k)â€‹â€‹=jâˆ‘â€‹wji(k)â€‹yj(kâˆ’1)â€‹+bi(k)â€‹=jâˆ‘â€‹wji(k)â€‹Î±Ïƒ(zj(kâˆ’1)â€‹)+bi(k)â€‹=jâˆ‘â€‹(Î±wji(k)â€‹)Ïƒ(zj(kâˆ’1)â€‹)+bi(k)â€‹â€‹ So Wtest=Î±WtrainedW_{test} = \\alpha W_{trained}Wtestâ€‹=Î±Wtrainedâ€‹ Instead of multiplying every output by all weights by Î±\\alphaÎ±, multiply all weight by Î±\\alphaÎ± Alternate implementation During training, replace the activation of all neurons in the network by Î±âˆ’1Ïƒ(.)\\alpha ^{-1} \\sigma(.)Î±âˆ’1Ïƒ(.) Use Ïƒ(.)\\sigma(.)Ïƒ(.) as the activation during testing, and not modify the weights More tricks Obtain training data Use appropriate representation for inputs and outputs Data Augmentation Choose network architecture More neurons need more data Deep is better, but harder to train Choose the appropriate divergence function Choose regularization Choose heuristics batch norm, dropout ... Choose optimization algorithm Adagrad / Adam / SGD Perform a grid search for hyper parameters (learning rate, regularization parameter, â€¦) on held-out data Train Evaluate periodically on validation data, for early stopping if required 1. A good summary of recent optimizers can be seen in here. â†© 2. Animations for optimization algorithms â†© 3. A simple and clear demostration of 2 variables in a single network â†© 4. The perceptrons in the network are individually capable of sharp changes in output â†© 5. Batch normalization in Neural Networks â†© "},"L08 Motivation of CNN.html":{"url":"L08 Motivation of CNN.html","title":"8 Motivation Of CNN","keywords":"","body":" ã€ŒScan for patternsã€ Movivation Find a word in a signal of find a item in picture The need for shift invariance The location of a pattern is not important So we can scan with a same MLP for the pattern Just one giant network Restriction: All subnets are identical Regular networks vs. scanning networks In a regular MLP every neuron in a layer is connected by a unique weight to every unit in the previous layer In a scanning MLP each neuron is connected to a subset of neurons in the previous layer The weights matrix is sparse The weights matrix is block structured with identical blocks The network is a shared-parameter model Modifications Order changed Intuitivly, scan at one position and get output, then scan next place But we can also first scan all the position at one layer, then the next layer The result is the same Distrubuting the scan Evaluate small pattern in the first layer The higher layer implicitly learns the arrangement of sub patterns that represents the larger pattern Why distribute? More generalizable Distribution forces localized patterns in lower layers Number of parameters Fewer parameters Significant gains from shared computation Terminology The pattern in the input image that each filter sees is its ã€ŒReceptive Fieldã€ Stride Effectively increasing the granularity of the scan This will result in a reduction of the size of the resulting maps Non-overlapped strides Partition the output of the layer into blocks, no overlap Within each block only retain the highest value Pooling We would like to account for some jitter in the first-level patterns Max pooling Is just a neuron This entire structure is called a Convolutional Neural Network The 1-D scan version of the convolutional neural network is the time-delay neural network Used primarily for speech recognition Max pooling optional: jitter matters in speech "},"L09 Cascade Correlation.html":{"url":"L09 Cascade Correlation.html","title":"9 Cascade Correlation","keywords":"","body":" A alternate way to think the architecture of network Cascade-Correlation Algorithm Start with direct I/O connections only. No hidden units. Train output-layer weights using BP or Quickprop. If error is now acceptable, quit. Else, Create one new hidden unit offline. Create a pool of candidate units. Each gets all available inputs. Outputs are not yet connected to anything. Train the incoming weights to maximize the match (covariance) between each unitâ€™s output and the residual error: When all are quiescent, tenure the winner and add it to active net. Kill all the other candidates. Re-train output layer weights and repeat the cycle until done. Why Is Backprop So Slow? Moving Targets All hidden units are being trained at once, changing the environment seen by the other units as they train. Herd Effect Each unit must find a distinct job -- some component of the error to correct. All units scramble for the most important jobs. No central authority or communication. Once a job is taken, it disappears and units head for the next-best job, including the unit that took the best job. This is a very inefficient way to assign a distinct useful job to each unit. Advantages of Cascade Correlation No need to guess size and topology of net in advance. Can build deep nets with higher-order features. Much faster than Backprop or Quickprop. Trains just one layer of weights at a time (fast). Works on smaller training sets (in some cases, at least). Old feature detectors are frozen, not cannibalized, so good for incremental â€œcurriculumâ€ training. Good for parallel implementation. "},"L10 CNN architecture.html":{"url":"L10 CNN architecture.html","title":"10 CNN Architecture","keywords":"","body":"Architecture A convolutional neural network comprises â€œconvolutionalâ€ and â€œdownsampling â€ layers Convolutional layers comprise neurons that scan their input for patterns Downsampling layers perform max operations on groups of outputs from the convolutional layers Perform on individual map For reduce the number of parameters The two may occur in any sequence, but typically they alternate Followed by an MLP with one or more layers A convolutional layer Each activation map has two components An affine map, obtained by convolution over maps in the previous layer Each affine map has, associated with it, a learnable filter An activation that operates on the output of the convolution What is a convolution Scanning an image with a â€œfilterâ€ Equivalent to scanning with an MLP Weights size of the filter Ã—\\timesÃ— no. of maps in previous layer Size Image size: NÃ—NN\\times NNÃ—N Filter: MÃ—MM\\times MMÃ—M Stride: SSS Output size = âŒŠ(Nâˆ’M)/SâŒ‹+1\\lfloor(N-M) / S\\rfloor+1âŒŠ(Nâˆ’M)/SâŒ‹+1 Jargon Filters are often called â€œKernelsâ€ The outputs of individual filters are called â€œchannelsâ€ Notion Each convolution layer maintains the size of the image With appropriate zero padding If performed without zero padding it will decrease the size of the input Each convolution layer may increase the number of maps from the previous layer Depends on the number of filters Each pooling layer with hop DDD decreases the size of the maps by a factor of DDD Filters within a layer must all be the same size, but sizes may vary with layer Similarly for pooling, DDD may vary with layer In general the number of convolutional filters increases with layers Because the patterns gets more complex, hence larger combinations of patterns to capture Training is as in the case of the regular MLP The only difference is in the structure of the network "},"L12 Prop of CNN.html":{"url":"L12 Prop of CNN.html","title":"11 Prop Of CNN","keywords":"","body":"Convolution Each position in zzz consists of convolution result in previous map Way for shrinking the maps Stride greater than 1 Downsampling (not necessary) Typically performed with strides > 1 Pooling Maxpooling Note: keep tracking of location of max (needed while back prop) Mean pooling Learning the CNN Training is as in the case of the regular MLP The only difference is in the structure of the network Define a divergence between the desired output and true output of the network in response to any input Network parameters are trained through variants of gradient descent Gradients are computed through backpropagation Final flat layers Backpropagation continues in the usual manner until the computation of the derivative of the divergence Recall in Backpropagation Step 1: compute âˆ‚Divâˆ‚zn\\frac{\\partial Div}{\\partial z^{n}}âˆ‚znâˆ‚Divâ€‹ã€âˆ‚Divâˆ‚yn\\frac{\\partial Div}{\\partial y^{n}}âˆ‚ynâˆ‚Divâ€‹ Step 2: compute âˆ‚Divâˆ‚wn\\frac{\\partial Div}{\\partial w^{n}}âˆ‚wnâˆ‚Divâ€‹ according to step 1 Convolutional layer Computing âˆ‡Z(l)Div\\nabla_{Z(l)} D i vâˆ‡Z(l)â€‹Div dDivdz(l,m,x,y)=dDivdY(l,m,x,y)fâ€²(z(l,m,x,y)) \\frac{d D i v}{d z(l, m, x, y)}=\\frac{d D i v}{d Y(l, m, x, y)} f^{\\prime}(z(l, m, x, y)) dz(l,m,x,y)dDivâ€‹=dY(l,m,x,y)dDivâ€‹fâ€²(z(l,m,x,y)) Simple compont-wise computation Computing âˆ‡Y(lâˆ’1)Div\\nabla_{Y(l-1)} D i vâˆ‡Y(lâˆ’1)â€‹Div Each Y(lâˆ’1,m,x,y)Y(l-1,m,x,y)Y(lâˆ’1,m,x,y) affects several z(l,n,xâ€²,yâ€²)z(l,n,x\\prime,y\\prime)z(l,n,xâ€²,yâ€²) terms for every nnn (map) Through wl(m,n,xâˆ’xâ€²,yâˆ’yâ€²)w_l(m,n,x-x\\prime,y-y\\prime)wlâ€‹(m,n,xâˆ’xâ€²,yâˆ’yâ€²) Affects terms in all lthl^{th}lth layer maps All of them contribute to the derivative of the divergence Y(lâˆ’1,m,x,y)Y(l-1,m,x,y)Y(lâˆ’1,m,x,y) Derivative w.r.t a specific yyy term dDivdY(lâˆ’1,m,x,y)=âˆ‘nâˆ‘xâ€²,yâ€²dDivdz(l,n,xâ€²,yâ€²)dz(l,n,xâ€²,yâ€²)dY(lâˆ’1,m,x,y) \\frac{d D i v}{d Y(l-1, m, x, y)}=\\sum_{n} \\sum_{x^{\\prime}, y^{\\prime}} \\frac{d D i v}{d z\\left(l, n, x^{\\prime}, y^{\\prime}\\right)} \\frac{d z\\left(l, n, x^{\\prime}, y^{\\prime}\\right)}{d Y(l-1, m, x, y)} dY(lâˆ’1,m,x,y)dDivâ€‹=nâˆ‘â€‹xâ€²,yâ€²âˆ‘â€‹dz(l,n,xâ€²,yâ€²)dDivâ€‹dY(lâˆ’1,m,x,y)dz(l,n,xâ€²,yâ€²)â€‹ dDivdY(lâˆ’1,m,x,y)=âˆ‘nâˆ‘xâ€²,yâ€²dDivdz(l,n,xâ€²,yâ€²)wl(m,n,xâˆ’xâ€²,yâˆ’yâ€²) \\frac{d D i v}{d Y(l-1, m, x, y)}=\\sum_{n} \\sum_{x \\prime, y^{\\prime}} \\frac{d D i v}{d z\\left(l, n, x^{\\prime}, y^{\\prime}\\right)} w_{l}\\left(m, n, x-x^{\\prime}, y-y^{\\prime}\\right) dY(lâˆ’1,m,x,y)dDivâ€‹=nâˆ‘â€‹xâ€²,yâ€²âˆ‘â€‹dz(l,n,xâ€²,yâ€²)dDivâ€‹wlâ€‹(m,n,xâˆ’xâ€²,yâˆ’yâ€²) Computing âˆ‡w(l)Div\\nabla_{w(l)} D i vâˆ‡w(l)â€‹Div Each weight wl(m,n,xâ€²,yâ€²)w_l(m,n,x\\prime,y\\prime)wlâ€‹(m,n,xâ€²,yâ€²) also affects several z(l,n,x,y)z(l,n,x,y)z(l,n,x,y) term for every nnn Affects terms in only one ZZZ map (the nth map) All entries in the map contribute to the derivative of the divergence w.r.t. wl(m,n,xâ€²,yâ€²)w_l(m,n,x\\prime,y\\prime)wlâ€‹(m,n,xâ€²,yâ€²) Derivative w.r.t a specific www term dDivdwl(m,n,x,y)=âˆ‘xâ€²,yâ€²dDivdz(l,n,xâ€²,yâ€²)dz(l,n,xâ€²,yâ€²)dwl(m,n,x,y) \\frac{d D i v}{d w_{l}(m, n, x, y)}=\\sum_{x^{\\prime}, y^{\\prime}} \\frac{d D i v}{d z\\left(l, n, x^{\\prime}, y^{\\prime}\\right)} \\frac{d z\\left(l, n, x^{\\prime}, y^{\\prime}\\right)}{d w_{l}(m, n, x, y)} dwlâ€‹(m,n,x,y)dDivâ€‹=xâ€²,yâ€²âˆ‘â€‹dz(l,n,xâ€²,yâ€²)dDivâ€‹dwlâ€‹(m,n,x,y)dz(l,n,xâ€²,yâ€²)â€‹ dDivdwl(m,n,x,y)=âˆ‘xâ€²,yâ€²dDivdz(l,n,xâ€²,yâ€²)Y(lâˆ’1,m,xâ€²+x,yâ€²+y) \\frac{d D i v}{d w_{l}(m, n, x, y)}=\\sum_{x \\prime, y^{\\prime}} \\frac{d D i v}{d z\\left(l, n, x^{\\prime}, y^{\\prime}\\right)} Y\\left(l-1, m, x^{\\prime}+x, y^{\\prime}+y\\right) dwlâ€‹(m,n,x,y)dDivâ€‹=xâ€²,yâ€²âˆ‘â€‹dz(l,n,xâ€²,yâ€²)dDivâ€‹Y(lâˆ’1,m,xâ€²+x,yâ€²+y) Summary In practice dDivdY(lâˆ’1,m,x,y)=âˆ‘nâˆ‘xâ€²,yâ€²dDivdz(l,n,xâ€²,yâ€²)wl(m,n,xâˆ’xâ€²,yâˆ’yâ€²) \\frac{d D i v}{d Y(l-1, m, x, y)}=\\sum_{n} \\sum_{x \\prime, y^{\\prime}} \\frac{d D i v}{d z\\left(l, n, x^{\\prime}, y^{\\prime}\\right)} w_{l}\\left(m, n, x-x^{\\prime}, y-y^{\\prime}\\right) dY(lâˆ’1,m,x,y)dDivâ€‹=nâˆ‘â€‹xâ€²,yâ€²âˆ‘â€‹dz(l,n,xâ€²,yâ€²)dDivâ€‹wlâ€‹(m,n,xâˆ’xâ€²,yâˆ’yâ€²) This is a convolution, with defferent order Use mirror image to do normal convolution (flip up down / flip left right) In practice, the derivative at each (x,y) location is obtained from all ZZZ maps This is just a convolution of âˆ‚Divâˆ‚z(l,n,x,y)\\frac{\\partial Div}{\\partial z(l,n,x,y)}âˆ‚z(l,n,x,y)âˆ‚Divâ€‹ by the inverted filter After zero padding it first with Lâˆ’1L-1Lâˆ’1 zeros on every side Note: the xâ€²,yâ€²x\\prime, y\\primexâ€²,yâ€² refer to the location in filter Shifting down and right by Kâˆ’1K-1Kâˆ’1, such that 0,00,00,0 becomes Kâˆ’1,Kâˆ’1K-1,K-1Kâˆ’1,Kâˆ’1 zshift(l,n,m,x,y)=z(l,n,xâˆ’K+1,yâˆ’K+1) z_{\\text {shift}}(l, n, m, x, y)=z(l, n, x-K+1, y-K+1) zshiftâ€‹(l,n,m,x,y)=z(l,n,xâˆ’K+1,yâˆ’K+1) âˆ‚Divâˆ‚y(lâˆ’1,m,x,y)=âˆ‘nâˆ‘xâ€²,yâ€²w^(l,n,m,xâ€²,yâ€²)âˆ‚Divâˆ‚zshift(l,n,x+xâ€²,y+yâ€²) \\frac{\\partial D i v}{\\partial y(l-1, m, x, y)}=\\sum_{n} \\sum_{x^{\\prime}, y^{\\prime}} \\widehat{w}\\left(l, n, m, x^{\\prime}, y^{\\prime}\\right) \\frac{\\partial D i v}{\\partial z_{s h i f t}\\left(l, n, x+x^{\\prime}, y+y^{\\prime}\\right)} âˆ‚y(lâˆ’1,m,x,y)âˆ‚Divâ€‹=nâˆ‘â€‹xâ€²,yâ€²âˆ‘â€‹w(l,n,m,xâ€²,yâ€²)âˆ‚zshiftâ€‹(l,n,x+xâ€²,y+yâ€²)âˆ‚Divâ€‹ Regular convolution running on shifted derivative maps using flipped filter Pooling Pooling is typically performed with strides > 1 Results in shrinking of the map Downsampling Derivative of Max pooling dDivdY(l,m,k,l)={dDivdU(l,m,i,j)Â ifÂ (k,l)=P(l,m,i,j)0Â otherwiseÂ  \\frac{d D i v}{d Y(l, m, k, l)}=\\left\\{\\begin{array}{c} \\frac{d D i v}{d U(l, m, i, j)} \\text { if }(k, l)=P(l, m, i, j) \\\\ 0 \\text { otherwise } \\end{array}\\right. dY(l,m,k,l)dDivâ€‹={dU(l,m,i,j)dDivâ€‹Â ifÂ (k,l)=P(l,m,i,j)0Â otherwiseÂ â€‹ Max pooling selects the largest from a pool of elements 1 Derivative of Mean pooling The derivative of mean pooling is distributed over the pool dy(l,m,k,n)=1Klpool2du(l,m,k,n) d y(l, m, k, n)=\\frac{1}{K_{l p o o l}^{2}} d u(l, m, k, n) dy(l,m,k,n)=Klpool2â€‹1â€‹du(l,m,k,n) Transposed Convolution Weâ€™ve always assumed that subsequent steps shrink the size of the maps Can subsequent maps increase in size 2 Output size is typically an integer multiple of input +1 if filter width is odd Model variations Very deep networks 100 or more layers in MLP Formalism called â€œResnetâ€ Depth-wise convolutions Instead of multiple independent filters with independent parameters, use common layer-wise weights and combine the layers differently for each filter Depth-wise convolutions In depth-wise convolution the convolution step is performed only once The simple summation is replaced by a weighted sum across channels Different weights (for summation) produce different output channels Models For CIFAR 10 Le-net 5 3 For ILSVRC(Imagenet Large Scale Visual Recognition Challenge) AlexNet NN contains 60 million parameters and 650,000 neurons 5 convolutional layers, some of which are followed by max-pooling layers 3 fully-connected layers VGGNet Only used 3x3 filters, stride 1, pad 1 Only used 2x2 pooling filters, stride 2 ~140 million parameters in all Googlenet Multiple filter sizes simultaneously For ImageNet Resnet Last layer before addition must have the same number of filters as the input to the module Batch normalization after each convolution Densenet All convolutional Each layer looks at the union of maps from all previous layers Instead of just the set of maps from the immediately previous layer 1. Backprop Through Max-Pooling Layers? â†© 2. Transposed Convolution Demystified â†© 3. https://cs.stanford.edu/people/karpathy/convnetjs/demo/cifar10.html â†© "},"L13 RNN.html":{"url":"L13 RNN.html","title":"12 RNN","keywords":"","body":"Modelling Series In many situations one must consider a series of inputs to produce an output Outputs too may be a series Finite response model Can use convolutional neural net applied to series data (slide) Also called a Time-Delay neural network Something that happens today only affects the output of the system for days into the future Yt=f(Xt,Xtâˆ’1,â€¦,Xtâˆ’N) Y_{t}=f\\left(X_{t}, X_{t-1}, \\ldots, X_{t-N}\\right) Ytâ€‹=f(Xtâ€‹,Xtâˆ’1â€‹,â€¦,Xtâˆ’Nâ€‹) Infinite response systems Systems often have long-term dependencies What happens today can continue to affect the output forever Yt=f(Xt,Xtâˆ’1,â€¦,Xtâˆ’âˆ) Y_{t}=f\\left(X_{t}, X_{t-1}, \\ldots, X_{t-\\infty}\\right) Ytâ€‹=f(Xtâ€‹,Xtâˆ’1â€‹,â€¦,Xtâˆ’âˆâ€‹) Infinite response systems A one-tap NARX network ã€Œnonlinear autoregressive network with exogenous inputsã€ Yt=f(Xt,Ytâˆ’1)Y_t = f(X_t,Y_{t-1})Ytâ€‹=f(Xtâ€‹,Ytâˆ’1â€‹) An input at t=0 affects outputs forever An explicit memory variable whose job it is to remember mt=r(ytâˆ’1,htâˆ’1â€²,mtâˆ’1)ht=f(xt,mt)yt=g(ht) \\begin{array}{c} m_{t}=r\\left(y_{t-1}, h_{t-1}^{\\prime}, m_{t-1}\\right) \\\\\\\\ h_{t}=f\\left(x_{t}, m_{t}\\right) \\\\\\\\ y_{t}=g\\left(h_{t}\\right) \\end{array} mtâ€‹=r(ytâˆ’1â€‹,htâˆ’1â€²â€‹,mtâˆ’1â€‹)htâ€‹=f(xtâ€‹,mtâ€‹)ytâ€‹=g(htâ€‹)â€‹ Jordan Network Memory unit simply retains a running average of past outputs Memory has fixed structure; does not â€œlearnâ€ to remember Elman Networks Separate memory state from output Only the weight from the memory unit to the hidden unit is learned But during training no gradient is backpropagated over the â€œ1â€ link (Just cloned state) Problem â€œSimpleâ€ (or partially recurrent) because during learning current error does not actually propagate to the past State-space model ht=f(xt,htâˆ’1)yt=g(ht) \\begin{array}{c} h_{t}=f\\left(x_{t}, h_{t-1}\\right) \\\\\\\\ y_{t}=g\\left(h_{t}\\right) \\end{array} htâ€‹=f(xtâ€‹,htâˆ’1â€‹)ytâ€‹=g(htâ€‹)â€‹ hth_thtâ€‹ is the state of the network Model directly embeds the memory in the state State summarizes information about the entire past Recurrent neural network1 Variants All columns are identical The simplest structures are most popular Recurrent neural network Forward pass Backward pass BPTT Back Propagation Through Time Defining a divergence between the actual and desired output sequences Backpropagating gradients over the entire chain of recursion Backpropagation through time Pooling gradients with respect to individual parameters over time Notion The divergence computed is between the sequence of outputs by the network and the desired sequence of outputs DIV is a scalar function of a ..series.. of vectors This is not just the sum of the divergences at individual times Y(t)Y(t)Y(t) is the output at time ttt Yi(t)Y_i(t)Yiâ€‹(t) is the ith output Z(2)(t)Z^{(2)}(t)Z(2)(t) is the pre-activation value of the neurons at the output layer at time ttt h(t)h(t)h(t) is the output of the hidden layer at time ttt BPTT Y(t)Y(t)Y(t) is a column vector DIVDIVDIV is a scalar dDivdY(t)\\frac{d Div}{d Y(t)}dY(t)dDivâ€‹ is a row vector Derivative at time TTT Compute dDIVdYi(T)\\frac{d DIV}{d Y_i(T)}dYiâ€‹(T)dDIVâ€‹ for all iii In general we will be required to compute dDIVdYi(t)\\frac{d DIV}{d Y_i(t)}dYiâ€‹(t)dDIVâ€‹ for all iii and ttt as we will see This can be a source of significant difficulty in many scenarios Special case, when the overall divergence is a simple sum of local divergences at each time dDIVdYi(t)=dDiv(t)dYi(t) \\frac{d D I V}{d Y_{i}(t)}=\\frac{d D i v(t)}{d Y_{i}(t)} dYiâ€‹(t)dDIVâ€‹=dYiâ€‹(t)dDiv(t)â€‹ Compute âˆ‡Z(2)(T)DIV\\nabla_{Z^{(2)}(T)}{D I V}âˆ‡Z(2)(T)â€‹DIV âˆ‡Z(2)(T)DIV=âˆ‡Y(T)DIVâˆ‡Z(2)(T)Y(T) \\nabla_{Z^{(2)}(T)}{D I V}=\\nabla_{Y(T)} D I V \\nabla_{Z^{(2)}(T)} Y(T) âˆ‡Z(2)(T)â€‹DIV=âˆ‡Y(T)â€‹DIVâˆ‡Z(2)(T)â€‹Y(T) For scalar output activation dDIVdZi(2)(T)=dDIVdYi(T)dYi(T)dZi(2)(T) \\frac{d D I V}{d Z_{i}^{(2)}(T)}=\\frac{d D I V}{d Y_{i}(T)} \\frac{d Y_{i}(T)}{d Z_{i}^{(2)}(T)} dZi(2)â€‹(T)dDIVâ€‹=dYiâ€‹(T)dDIVâ€‹dZi(2)â€‹(T)dYiâ€‹(T)â€‹ For vector output activation dDIVdZi(2)(T)=âˆ‘idDIVdYj(T)dYj(T)dZi(2)(T) \\frac{d D I V}{d Z_{i}^{(2)}(T)}=\\sum_{i} \\frac{d D I V}{d Y_{j}(T)} \\frac{d Y_{j}(T)}{d Z_{i}^{(2)}(T)} dZi(2)â€‹(T)dDIVâ€‹=iâˆ‘â€‹dYjâ€‹(T)dDIVâ€‹dZi(2)â€‹(T)dYjâ€‹(T)â€‹ Compute âˆ‡h(T)DIV\\nabla_{h_(T)}{D I V}âˆ‡h(â€‹T)â€‹DIV W(2)h(T)=Z(2)(T) W^{(2)} h(T) = Z^{(2)}(T) W(2)h(T)=Z(2)(T) dDIVdhi(T)=âˆ‘jdDIVdZj(2)(T)dZj(2)(T)dhi(T)=âˆ‘jwij(2)dDIVdZj(2)(T) \\frac{d D I V}{d h_{i}(T)}=\\sum_{j} \\frac{d D I V}{d Z_{j}^{(2)}(T)} \\frac{d Z_{j}^{(2)}(T)}{d h_{i}(T)}=\\sum_{j} w_{i j}^{(2)} \\frac{d D I V}{d Z_{j}^{(2)}(T)} dhiâ€‹(T)dDIVâ€‹=jâˆ‘â€‹dZj(2)â€‹(T)dDIVâ€‹dhiâ€‹(T)dZj(2)â€‹(T)â€‹=jâˆ‘â€‹wij(2)â€‹dZj(2)â€‹(T)dDIVâ€‹ âˆ‡h(T)DIV=âˆ‡Z(2)(T)DIVW(2) \\nabla_{h(T)} D I V=\\nabla_{Z^{(2)}(T)} D I V W^{(2)} âˆ‡h(T)â€‹DIV=âˆ‡Z(2)(T)â€‹DIVW(2) Compute âˆ‡W(2)DIV\\nabla_{W^{(2)}}{D I V}âˆ‡W(2)â€‹DIV dDIVdwij(2)=dDIVdZj(2)(T)hi(T) \\frac{d D I V}{d w_{i j}^{(2)}}=\\frac{d D I V}{d Z_{j}^{(2)}(T)} h_{i}(T) dwij(2)â€‹dDIVâ€‹=dZj(2)â€‹(T)dDIVâ€‹hiâ€‹(T) âˆ‡W(2)DIV=h(T)âˆ‡Z(2)(T)DIV \\nabla_{W^{(2)}} D I V=h(T) \\nabla_{Z^{(2)}(T)} D I V âˆ‡W(2)â€‹DIV=h(T)âˆ‡Z(2)(T)â€‹DIV Compute âˆ‡Z(1)(T)DIV\\nabla_{Z^{(1)}(T)}{D I V}âˆ‡Z(1)(T)â€‹DIV dDIVdZi(1)(T)=dDIVdhi(T)dhi(T)dZi(1)(T) \\frac{d D I V}{d Z_{i}^{(1)}(T)}=\\frac{d D I V}{d h_{i}(T)} \\frac{d h_{i}(T)}{d Z_{i}^{(1)}(T)} dZi(1)â€‹(T)dDIVâ€‹=dhiâ€‹(T)dDIVâ€‹dZi(1)â€‹(T)dhiâ€‹(T)â€‹ âˆ‡Z(1)(T)DIV=âˆ‡h(T)DIVâˆ‡Z(1)(T)h(T) \\nabla_{Z^{(1)}(T)} D I V=\\nabla_{h(T)} D I V \\nabla_{Z^{(1)}(T)} h(T) âˆ‡Z(1)(T)â€‹DIV=âˆ‡h(T)â€‹DIVâˆ‡Z(1)(T)â€‹h(T) Compute âˆ‡W(1)DIV\\nabla_{W^{(1)}}{D I V}âˆ‡W(1)â€‹DIV W(1)X(T)+W(11)h(Tâˆ’1)=Z(1)(T) W^{(1)} X(T) + W^{(11)} h(T-1)= Z^{(1)}(T) W(1)X(T)+W(11)h(Tâˆ’1)=Z(1)(T) dDIVdwij(1)=dDIVdZj(1)(T)Xi(T) \\frac{d D I V}{d w_{i j}^{(1)}}=\\frac{d D I V}{d Z_{j}^{(1)}(T)} X_{i}(T) dwij(1)â€‹dDIVâ€‹=dZj(1)â€‹(T)dDIVâ€‹Xiâ€‹(T) âˆ‡W(1)DIV=X(T)âˆ‡Z(1)(T)DIV \\nabla_{W^{(1)}} D I V=X(T) \\nabla_{Z^{(1)}(T)} D I V âˆ‡W(1)â€‹DIV=X(T)âˆ‡Z(1)(T)â€‹DIV Compute âˆ‡W(11)DIV\\nabla_{W^{(11)}}{D I V}âˆ‡W(11)â€‹DIV dDIVdwii(11)=dDIVdZi(1)(T)hi(Tâˆ’1) \\frac{d D I V}{d w_{i i}^{(11)}}=\\frac{d D I V}{d Z_{i}^{(1)}(T)} h_{i}(T-1) dwii(11)â€‹dDIVâ€‹=dZi(1)â€‹(T)dDIVâ€‹hiâ€‹(Tâˆ’1) âˆ‡W(11)DIV=h(Tâˆ’1)âˆ‡Z(1)(T)DIV \\nabla_{W}^{(11)} D I V=h(T-1) \\nabla_{Z^{(1)}(T)} D I V âˆ‡W(11)â€‹DIV=h(Tâˆ’1)âˆ‡Z(1)(T)â€‹DIV Derivative at time Tâˆ’1T-1Tâˆ’1 Compute âˆ‡Z(2)(Tâˆ’1)DIV\\nabla_{Z^{(2)}(T-1)}{D I V}âˆ‡Z(2)(Tâˆ’1)â€‹DIV âˆ‡Z(2)(Tâˆ’1)DIV=âˆ‡Y(Tâˆ’1)DIVâˆ‡Z(2)(Tâˆ’1)Y(Tâˆ’1) \\nabla_{Z^{(2)}(T-1)}{D I V}=\\nabla_{Y(T-1)} D I V \\nabla_{Z^{(2)}(T-1)} Y(T-1) âˆ‡Z(2)(Tâˆ’1)â€‹DIV=âˆ‡Y(Tâˆ’1)â€‹DIVâˆ‡Z(2)(Tâˆ’1)â€‹Y(Tâˆ’1) For scalar output activation dDIVdZi(2)(Tâˆ’1)=dDIVdYi(Tâˆ’1)dYi(Tâˆ’1)dZi(2)(Tâˆ’1) \\frac{d D I V}{d Z_{i}^{(2)}(T-1)}=\\frac{d D I V}{d Y_{i}(T-1)} \\frac{d Y_{i}(T-1)}{d Z_{i}^{(2)}(T-1)} dZi(2)â€‹(Tâˆ’1)dDIVâ€‹=dYiâ€‹(Tâˆ’1)dDIVâ€‹dZi(2)â€‹(Tâˆ’1)dYiâ€‹(Tâˆ’1)â€‹ For vector output activation dDIVdZi(2)(Tâˆ’1)=âˆ‘jdDIVdYj(Tâˆ’1)dYj(Tâˆ’1)dZi(2)(Tâˆ’1) \\frac{d D I V}{d Z_{i}^{(2)}(T-1)}=\\sum_{j} \\frac{d D I V}{d Y_{j}(T-1)} \\frac{d Y_{j}(T-1)}{d Z_{i}^{(2)}(T-1)} dZi(2)â€‹(Tâˆ’1)dDIVâ€‹=jâˆ‘â€‹dYjâ€‹(Tâˆ’1)dDIVâ€‹dZi(2)â€‹(Tâˆ’1)dYjâ€‹(Tâˆ’1)â€‹ Compute âˆ‡h(Tâˆ’1)DIV\\nabla_{h_(T-1)}{D I V}âˆ‡h(â€‹Tâˆ’1)â€‹DIV dDIVdhi(Tâˆ’1)=âˆ‘jwij(2)dDIVdZj(2)(Tâˆ’1)+âˆ‘jwij(11)dDIVdZj(1)(T) \\frac{d D I V}{d h_{i}(T-1)}=\\sum_{j} w_{i j}^{(2)} \\frac{d D I V}{d Z_{j}^{(2)}(T-1)}+\\sum_{j} w_{i j}^{(11)} \\frac{d D I V}{d Z_{j}^{(1)}(T)} dhiâ€‹(Tâˆ’1)dDIVâ€‹=jâˆ‘â€‹wij(2)â€‹dZj(2)â€‹(Tâˆ’1)dDIVâ€‹+jâˆ‘â€‹wij(11)â€‹dZj(1)â€‹(T)dDIVâ€‹ âˆ‡h(Tâˆ’1)DIV=âˆ‡Z(2)(Tâˆ’1)DIVW(2)+âˆ‡Z(1)(T)DIVW(11) \\nabla_{h(T-1)} D I V=\\nabla_{Z^{(2)}(T-1)} D I V W^{(2)}+\\nabla_{Z^{(1)}(T)} D I V W^{(11)} âˆ‡h(Tâˆ’1)â€‹DIV=âˆ‡Z(2)(Tâˆ’1)â€‹DIVW(2)+âˆ‡Z(1)(T)â€‹DIVW(11) Compute âˆ‡W(2)DIV\\nabla_{W^{(2)}}{D I V}âˆ‡W(2)â€‹DIV dDIVdwij(2)+=dDIVdZj(2)(Tâˆ’1)hi(Tâˆ’1) \\frac{d D I V}{d w_{i j}^{(2)}}+=\\frac{d D I V}{d Z_{j}^{(2)}(T-1)} h_{i}(T-1) dwij(2)â€‹dDIVâ€‹+=dZj(2)â€‹(Tâˆ’1)dDIVâ€‹hiâ€‹(Tâˆ’1) âˆ‡W(2)DIV+=h(Tâˆ’1)âˆ‡Z(2)(Tâˆ’1)DIV \\nabla_{W^{(2)}} D I V+=h(T-1) \\nabla_{Z^{(2)}(T-1)} D I V âˆ‡W(2)â€‹DIV+=h(Tâˆ’1)âˆ‡Z(2)(Tâˆ’1)â€‹DIV Compute âˆ‡Z(1)(Tâˆ’1)DIV\\nabla_{Z^{(1)}(T-1)}{D I V}âˆ‡Z(1)(Tâˆ’1)â€‹DIV dDIVdZi(1)(Tâˆ’1)=dDIVdhi(Tâˆ’1)dhi(Tâˆ’1)dZi(1)(Tâˆ’1) \\frac{d D I V}{d Z_{i}^{(1)}(T-1)}=\\frac{d D I V}{d h_{i}(T-1)} \\frac{d h_{i}(T-1)}{d Z_{i}^{(1)}(T-1)} dZi(1)â€‹(Tâˆ’1)dDIVâ€‹=dhiâ€‹(Tâˆ’1)dDIVâ€‹dZi(1)â€‹(Tâˆ’1)dhiâ€‹(Tâˆ’1)â€‹ âˆ‡Z(1)(Tâˆ’1)DIV=âˆ‡h(Tâˆ’1)DIVâˆ‡Z(1)(Tâˆ’1)h(Tâˆ’1) \\nabla_{Z^{(1)}(T-1)} D I V=\\nabla_{h(T-1)} D I V \\nabla_{Z^{(1)}(T-1)} h(T-1) âˆ‡Z(1)(Tâˆ’1)â€‹DIV=âˆ‡h(Tâˆ’1)â€‹DIVâˆ‡Z(1)(Tâˆ’1)â€‹h(Tâˆ’1) Compute âˆ‡W(1)DIV\\nabla_{W^{(1)}}{D I V}âˆ‡W(1)â€‹DIV dDIVdwij(1)+=dDIVdZj(1)(Tâˆ’1)Xi(Tâˆ’1) \\frac{d D I V}{d w_{i j}^{(1)}}+=\\frac{d D I V}{d Z_{j}^{(1)}(T-1)} X_{i}(T-1) dwij(1)â€‹dDIVâ€‹+=dZj(1)â€‹(Tâˆ’1)dDIVâ€‹Xiâ€‹(Tâˆ’1) âˆ‡W(1)DIV+=X(Tâˆ’1)âˆ‡Z(1)(Tâˆ’1)DIV \\nabla_{W^{(1)}} D I V+=X(T-1) \\nabla_{Z^{(1)}(T-1)} D I V âˆ‡W(1)â€‹DIV+=X(Tâˆ’1)âˆ‡Z(1)(Tâˆ’1)â€‹DIV Compute âˆ‡W(11)DIV\\nabla_{W^{(11)}}{D I V}âˆ‡W(11)â€‹DIV dDIVdwij(11)+=dDIVdZj(1)(Tâˆ’1)hi(Tâˆ’2) \\frac{d D I V}{d w_{i j}^{(11)}}+=\\frac{d D I V}{d Z_{j}^{(1)}(T-1)} h_{i}(T-2) dwij(11)â€‹dDIVâ€‹+=dZj(1)â€‹(Tâˆ’1)dDIVâ€‹hiâ€‹(Tâˆ’2) {% math %} \\nabla{W^{(11)}} D I V+=h(T-2) \\nabla{Z^{(1)}(T-1)} D I V {% endmath %} Back Propagation Through Time dDIVdhi(âˆ’1)=âˆ‘iwij(11)dDIVdZj(1)(0) \\frac{d D I V}{d h_{i}(-1)}=\\sum_{i} w_{i j}^{(11)} \\frac{d D I V}{d Z_{j}^{(1)}(0)} dhiâ€‹(âˆ’1)dDIVâ€‹=iâˆ‘â€‹wij(11)â€‹dZj(1)â€‹(0)dDIVâ€‹ dDIVdhi(k)(t)=âˆ‘jwi,j(k+1)dDIVdZj(k+1)(t)+âˆ‘jwi,j(k,k)dDIVdZj(k)(t+1) \\frac{d D I V}{d h_{i}^{(k)}(t)}=\\sum_{j} w_{i, j}^{(k+1)} \\frac{d D I V}{d Z_{j}^{(k+1)}(t)}+\\sum_{j} w_{i, j}^{(k, k)} \\frac{d D I V}{d Z_{j}^{(k)}(t+1)} dhi(k)â€‹(t)dDIVâ€‹=jâˆ‘â€‹wi,j(k+1)â€‹dZj(k+1)â€‹(t)dDIVâ€‹+jâˆ‘â€‹wi,j(k,k)â€‹dZj(k)â€‹(t+1)dDIVâ€‹ dDIVdZi(k)(t)=dDIVdhi(k)(t)fkâ€²(Zi(k)(t)) \\frac{d D I V}{d Z_{i}^{(k)}(t)}=\\frac{d D I V}{d h_{i}^{(k)}(t)} f_{k}^{\\prime}\\left(Z_{i}^{(k)}(t)\\right) dZi(k)â€‹(t)dDIVâ€‹=dhi(k)â€‹(t)dDIVâ€‹fkâ€²â€‹(Zi(k)â€‹(t)) dDIVdwij(1)=âˆ‘tdDIVdZj(1)(t)Xi(t) \\frac{d D I V}{d w_{i j}^{(1)}}=\\sum_{t} \\frac{d D I V}{d Z_{j}^{(1)}(t)} X_{i}(t) dwij(1)â€‹dDIVâ€‹=tâˆ‘â€‹dZj(1)â€‹(t)dDIVâ€‹Xiâ€‹(t) dDIVdwij(11)=âˆ‘tdDIVdZj(1)(t)hi(tâˆ’1) \\frac{d D I V}{d w_{i j}^{(11)}}=\\sum_{t} \\frac{d D I V}{d Z_{j}^{(1)}(t)} h_{i}(t-1) dwij(11)â€‹dDIVâ€‹=tâˆ‘â€‹dZj(1)â€‹(t)dDIVâ€‹hiâ€‹(tâˆ’1) Algorithm Bidirectional RNN Two independent RNN Clearly, this is not an online process and requires the entire input data It is easy to learning two RNN independently Forward pass: Compute both forward and backward networks and final output Backpropagation A basic backprop routine that we will call Two calls to the routine within a higher-level wrapper 1:The Unreasonable Effectiveness of Recurrent Neural Networks "},"L14 Stability analysis and LSTMs.html":{"url":"L14 Stability analysis and LSTMs.html","title":"13 Stability Analysis And LST Ms","keywords":"","body":"Stability Will this necessarily beã€ŒBounded Input Bounded Outputã€? Guaranteed if output and hidden activations are bounded But will it saturateï¼Ÿ Analyzing Recursion Sufficient to analyze the behavior of the hidden layer since it carries the relevant information Assumed linear systems zk=Whhkâˆ’1+Wxxk,hk=zk z_{k}=W_{h} h_{k-1}+W_{x} x_{k}, \\quad h_{k}=z_{k} zkâ€‹=Whâ€‹hkâˆ’1â€‹+Wxâ€‹xkâ€‹,hkâ€‹=zkâ€‹ Sufficient to analyze the response to a single input at t=0t =0t=0 (else is zero input) Simple scalar linear recursion h(t)=wh(tâˆ’1)+cx(t)h(t) = wh(t-1) + cx(t)h(t)=wh(tâˆ’1)+cx(t) h0(t)=wtcx(0)h_0(t) = w^tcx(0)h0â€‹(t)=wtcx(0) If w>1w > 1w>1 it will blow up Simple Vector linear recursion h(t)=Wh(tâˆ’1)+Cx(t)h(t) = Wh(t-1) + Cx(t)h(t)=Wh(tâˆ’1)+Cx(t) h0(t)=WtCx(0)h_0(t) = W^tCx(0)h0â€‹(t)=WtCx(0) For any input, for large the length of the hidden vector will expand or contract according to the tâˆ’t-tâˆ’ th power of the largest eigen value of the hidden-layer weight matrix If âˆ£Î»max>1âˆ£|\\lambda_{max} > 1|âˆ£Î»maxâ€‹>1âˆ£ it will blow up, otherwise it will contract and shrink to 0 rapidly Non-linearities Sigmoid: Saturates in a limited number of steps, regardless of www To a value dependent only on www (and bias, if any) Rate of saturation depends on www Tanh: Sensitive to www, but eventually saturates â€œPrefersâ€ weights close to 1.0 Relu: Sensitive to www, can blow up Lessons Recurrent networks retain information from the infinite past in principle In practice, they tend to blow up or forget If the largest Eigen value of the recurrent weights matrix is greater than 1, the network response may blow up If itâ€™s less than one, the response dies down very quickly The â€œmemoryâ€ of the network also depends on the parameters (and activation) of the hidden units Sigmoid activations saturate and the network becomes unable to retain new information RELU activations blow up or vanish rapidly Tanh activations are the most effective at storing memory And still has very short â€œmemoryâ€ Still sensitive to Eigenvalues of WWW Vanishing gradient A particular problem with training deep networks is the gradient of the error with respect to weights is unstable For Divâ¡(X)=D(fN(WNâˆ’1fNâˆ’1(WNâˆ’2fNâˆ’2(â€¦W0X))))\\operatorname{Div}(X)=D\\left(f_{N}\\left(W_{N-1} f_{N-1}\\left(W_{N-2} f_{N-2}\\left(\\ldots W_{0} X\\right)\\right)\\right)\\right)Div(X)=D(fNâ€‹(WNâˆ’1â€‹fNâˆ’1â€‹(WNâˆ’2â€‹fNâˆ’2â€‹(â€¦W0â€‹X)))) We get âˆ‡fkDivâ¡=âˆ‡D.âˆ‡fN.WNâˆ’1.âˆ‡fNâˆ’1.WNâˆ’2â€¦âˆ‡fk+1Wk\\nabla_{f_{k}} \\operatorname{Div}=\\nabla D . \\nabla f_{N} . W_{N-1} . \\nabla f_{N-1} . W_{N-2} \\ldots \\nabla f_{k+1} W_{k}âˆ‡fkâ€‹â€‹Div=âˆ‡D.âˆ‡fNâ€‹.WNâˆ’1â€‹.âˆ‡fNâˆ’1â€‹.WNâˆ’2â€‹â€¦âˆ‡fk+1â€‹Wkâ€‹ Where âˆ‡fn\\nabla{f_{n}}âˆ‡fnâ€‹ is jacobian of fN()f_N()fNâ€‹() to its current input For activation For RNN âˆ‡ft(zi)=[ft,1â€²(z1)0â‹¯00ft,2â€²(z2)â‹¯0â‹®â‹®â‹±â‹®00â‹¯ft,Nâ€²(zN)]\\nabla f_{t}\\left(z_{i}\\right)=\\left[\\begin{array}{cccc}f_{t, 1}^{\\prime}\\left(z_{1}\\right) & 0 & \\cdots & 0 \\\\\\\\ 0 & f_{t, 2}^{\\prime}\\left(z_{2}\\right) & \\cdots & 0 \\\\\\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\\\\\ 0 & 0 & \\cdots & f_{t, N}^{\\prime}\\left(z_{N}\\right)\\end{array}\\right]âˆ‡ftâ€‹(ziâ€‹)=â£â¢â¢â¢â¢â¢â¢â¢â¢â¡â€‹ft,1â€²â€‹(z1â€‹)0â‹®0â€‹0ft,2â€²â€‹(z2â€‹)â‹®0â€‹â‹¯â‹¯â‹±â‹¯â€‹00â‹®ft,Nâ€²â€‹(zNâ€‹)â€‹â¦â¥â¥â¥â¥â¥â¥â¥â¥â¤â€‹ For vector activations: A full matrix For scalar activations: A matrix where the diagonal entries are the derivatives of the activation of the recurrent hidden layer The derivative (or subgradient) of the activation function is always bounded Most common activation functions, such as sigmoid, tanh() and RELU have derivatives that are always less than 1 Multiplication by the Jacobian is always a shrinking operation After a few layers the derivative of the divergence at any time is totally â€œforgottenâ€ For weights In a single-layer RNN, the weight matrices are identical The conclusion below holds for any deep network, though The chain product for âˆ‡fkDiv\\nabla_{f_k} Divâˆ‡fkâ€‹â€‹Div will Expand âˆ‡D\\nabla Dâˆ‡D along directions in which the singular values of the weight matrices are greater than 1 Shrink âˆ‡D\\nabla Dâˆ‡D in directions where the singular values are less than 1 Repeated multiplication by the weights matrix will result in Exploding or vanishing gradients LSTM Problem Recurrent nets are very deep nets Stuff gets forgotten in the forward pass too Each weights matrix and activation can shrink components of the input Need the long-term dependency The memory retention of the network depends on the behavior of the weights and jacobian Which in turn depends on the parameters WWW rather than what it is trying to remember We need Not be directly dependent on vagaries of network parameters, but rather on input-based determination of whether it must be remembered Retain memories until a switch based on the input flags them as ok to forget ã€ŒCurly brace must remember until curly brace is closedã€ LSTM Address the problem of input-dependent memory behavior Architecture The Ïƒ\\sigmaÏƒ are multiplicative gates that decide if something is important or not Key component Remembered cell state Mutiply is a switch Should I continue remember or not? (scale up / down) Acddition Should I agument the memory? CtC_tCtâ€‹ is the linear history carried by the constant-error carousel Carries information through, only affected by a gate And addition of history, which too is gated.. Gates Gates are simple sigmoidal units with outputs in the range (0,1) Controls how much of the information is to be let through Forget gate The first gate determines whether to carry over the history or to forget it More precisely, how much of the history to carry over Also called the â€œforgetâ€ gate Note, weâ€™re actually distinguishing between the cell memory CCC and the state hhh that is coming over time! Theyâ€™re related though Hidden state is compute from memory (which is stored) Input gate The second input has two parts A perceptron layer that determines if thereâ€™s something new and interesting in the input ã€ŒSee a curly braceã€ A gate that decides if its worth remembering ã€ŒCurly brace is in comment section, ignore itã€ Memory cell update If something new and worth remembering Added to the current memory cell Output and Output gate The output of the cell Simply compress it with tanh to make it lie between 1 and -1 Note that this compression no longer affects our ability to carry memory forward Controlled by an output gate To decide if the memory contents are worth reporting at this time The â€œPeepholeâ€ Connection The raw memory is informative by itself and can also be input Note, weâ€™re using both CCC and hhh Forward Backward1 âˆ‡CtDiv=âˆ‡htDivâˆ˜(otâˆ˜tanhâ¡â€²(.)+tanhâ¡(.)âˆ˜Ïƒâ€²(.)WCo)+âˆ‡Ct+1Divâˆ˜(ft+1+Ctâˆ˜Ïƒâ€²(.)WCf+C~t+1âˆ˜Ïƒâ€²(.)WCiâˆ˜tanhâ¡(.)â€¦) \\begin{array}{l} \\nabla_{C_{t}} D i v=&\\nabla_{h_{t}} D i v \\circ\\left(o_{t} \\circ \\tanh ^{\\prime}(.)+\\tanh (.) \\circ \\sigma^{\\prime}(.) W_{C o}\\right)+ \\\\\\\\ &\\nabla_{C_{t+1}} D i v \\circ\\left(f_{t+1}+C_{t} \\circ \\sigma^{\\prime}(.) W_{C f}+\\tilde{C}_{t+1} \\circ \\sigma^{\\prime}(.) W_{C i} \\circ \\tanh (.) \\ldots\\right) \\end{array} âˆ‡Ctâ€‹â€‹Div=â€‹âˆ‡htâ€‹â€‹Divâˆ˜(otâ€‹âˆ˜tanhâ€²(.)+tanh(.)âˆ˜Ïƒâ€²(.)WCoâ€‹)+âˆ‡Ct+1â€‹â€‹Divâˆ˜(ft+1â€‹+Ctâ€‹âˆ˜Ïƒâ€²(.)WCfâ€‹+C~t+1â€‹âˆ˜Ïƒâ€²(.)WCiâ€‹âˆ˜tanh(.)â€¦)â€‹ âˆ‡htDiv=âˆ‡ztDivâˆ‡htzt+âˆ‡Ct+1Divâˆ˜(Ctâˆ˜Ïƒâ€²(.)Whf+C~t+1âˆ˜Ïƒâ€²(.)Whi)+âˆ‡Ct+1Divâˆ˜ot+1âˆ˜tanhâ¡â€²(.)Whi+âˆ‡ht+1Divâˆ˜tanhâ¡(.)âˆ˜Ïƒâ€²(.)Who \\begin{aligned} \\nabla_{h_{t}} D i v=& \\nabla_{z_{t}} D i v \\nabla_{h_{t}} z_{t}+\\nabla_{C_{t+1}} D i v \\circ\\left(C_{t} \\circ \\sigma^{\\prime}(.) W_{h f}+\\tilde{C}_{t+1} \\circ \\sigma^{\\prime}(.) W_{h i}\\right)+\\\\\\\\ &\\nabla_{C_{t+1}} D i v \\circ o_{t+1} \\circ \\tanh ^{\\prime}(.) W_{h i}+\\nabla_{h_{t+1}} D i v \\circ \\tanh (.) \\circ \\sigma^{\\prime}(.) W_{h o} \\end{aligned} âˆ‡htâ€‹â€‹Div=â€‹âˆ‡ztâ€‹â€‹Divâˆ‡htâ€‹â€‹ztâ€‹+âˆ‡Ct+1â€‹â€‹Divâˆ˜(Ctâ€‹âˆ˜Ïƒâ€²(.)Whfâ€‹+C~t+1â€‹âˆ˜Ïƒâ€²(.)Whiâ€‹)+âˆ‡Ct+1â€‹â€‹Divâˆ˜ot+1â€‹âˆ˜tanhâ€²(.)Whiâ€‹+âˆ‡ht+1â€‹â€‹Divâˆ˜tanh(.)âˆ˜Ïƒâ€²(.)Whoâ€‹â€‹ And weights? Gated Recurrent Units Combine forget and input gates In new input is to be remembered, then this means old memory is to be forgotten No need to compute twice Donâ€™t bother to separately maintain compressed and regular memories Redundant representation Summary LSTMs are an alternative formalism where memory is made more directly dependent on the input, rather than network parameters/structure Through a â€œConstant Error Carouselâ€ memory structure with no weights or activations, but instead direct switching and â€œincrement/decrementâ€ from pattern recognizers Do not suffer from a vanishing gradient problem but do suffer from exploding gradient issue 1. http://arunmallya.github.io/writeups/nn/lstm/index.html#/ â†© "},"L15 Divergence of RNN.html":{"url":"L15 Divergence of RNN.html","title":"14 Divergence Of RNN","keywords":"","body":"Variants on recurrent nets Architectures How to train recurrent networks of different architectures Synchrony The target output is time-synchronous with the input The target output is order-synchronous, but not time synchronous One to one No recurrence in model Exactly as many outputs as inputs One to one correspondence between desired output and actual output Common assumption âˆ‡Y(t)Divâ¡(Ytarget(1â€¦T),Y(1â€¦T))=wtâˆ‡Y(t)Divâ¡(Ytarget(t),Y(t)) \\nabla_{Y(t)} \\operatorname{Div}\\left(Y_{\\text {target}}(1 \\ldots T), Y(1 \\ldots T)\\right)=w_{t} \\nabla_{Y(t)} \\operatorname{Div}\\left(Y_{\\text {target}}(t), Y(t)\\right) âˆ‡Y(t)â€‹Div(Ytargetâ€‹(1â€¦T),Y(1â€¦T))=wtâ€‹âˆ‡Y(t)â€‹Div(Ytargetâ€‹(t),Y(t)) wtw_twtâ€‹ is typically set to 1.0 Many to many The divergence computed is between the sequence of outputs by the network and the desired sequence of outputs This is not just the sum of the divergences at individual times Language modelling: Representing words Represent words as one-hot vectors Sparse problem Makes no assumptions about the relative importance of words The Projected word vectors Replace every one-hot vector WiW_iWiâ€‹ by PWiPW_iPWiâ€‹ PPP is an MÃ—NM\\times NMÃ—N matrix How to learn projections Soft bag of words Predict word based on words in immediate context Without considering specific position Skip-grams Predict adjacent words based on current word Many to one Example Question answering Input : Sequence of words Output: Answer at the end of the question Speech recognition Input : Sequence of feature vectors (e.g. Mel spectra) Output: Phoneme ID at the end of the sequence Outputs are actually produced for every input We only read it at the end of the sequence How to train Define the divergence everywhere DIV(Ytarget,Y)=âˆ‘twtXentâ¡(Y(t),Â Phoneme)D I V\\left(Y_{\\text {target}}, Y\\right)=\\sum_{t} w_{t} \\operatorname{Xent}(Y(t), \\text { Phoneme})DIV(Ytargetâ€‹,Y)=âˆ‘tâ€‹wtâ€‹Xent(Y(t),Â Phoneme) Typical weighting scheme for speech All are equally important Problem like question answering Answer only expected after the question ends Sequence-to-sequence How do we know when to output symbols In fact, the network produces outputs at every time Which of these are the real outputs Outputs that represent the definitive occurrence of a symbol Option 1: Simply select the most probable symbol at each time Merge adjacent repeated symbols, and place the actual emission of the symbol in the final instant Cannot distinguish between an extended symbol and repetitions of the symbol Resulting sequence may be meaningless Option 2: Impose external constraints on what sequences are allowed Only allow sequences corresponding to dictionary words Sub-symbol units How to train when no timing information provided Only the sequence of output symbols is provided for the training data But no indication of which one occurs where How do we compute the divergence? And how do we compute its gradient "},"L16 Connectionist Temporal Classification.html":{"url":"L16 Connectionist Temporal Classification.html","title":"15 Connectionist Temporal Classification","keywords":"","body":"Sequence to sequence Sequence goes in, sequence comes out No notion of â€œtime synchronyâ€ between input and output May even nots maintain order of symbols (from one language to another) With order synchrony The input and output sequences happen in the same order Although they may be time asynchronous E.g. Speech recognition The input speech corresponds to the phoneme sequence output Question How do we know when to output symbols In fact, the network produces outputs at every time Which of these are the real outputs? Option 1 Simply select the most probable symbol at each time Merge adjacent repeated symbols, and place the actual emission of the symbol in the final instant Problem Cannot distinguish between an extended symbol and repetitions of the symbol Resulting sequence may be meaningless Option 2 Impose external constraints on what sequences are allowed E.g. only allow sequences corresponding to dictionary words Decoding The process of obtaining an output from the network Time-synchronous & order-synchronous sequence aaabbbbbbccc => abc (probility 0.5) aabbbbbbbccc => abc (probility 0.001) cccddddddeee => cde (probility 0.4) cccddddeeeee => cde (probility 0.4) So abc is the most likely time-synchronous output sequence But cde is the the most likely order-synchronous sequence Option 2 is in fact a suboptimal decode that actually finds the most likely time-synchronous output sequence The â€œmergingâ€ heuristics do not guarantee optimal order-synchronous sequences No timing information provided Only the sequence of output symbols is provided for the training data But no indication of which one occurs where Guess the alignment Initialize Assign an initial alignment Either randomly, based on some heuristic, or any other rationale Iterate Train the network using the current alignment Reestimate the alignment for each training instance Constraining the alignment Try 1 Block out all rows that do not include symbols from the target sequence E.g. Block out rows that are not /B/ /IY/ or /F/ Only decode on reduced grid We are now assured that only the appropriate symbols will be hypothesized But this still doesnâ€™t assure that the decode sequence correctly expands the target symbol sequence Order variance Try 2 Explicitly arrange the constructed table Arrange the constructed table so that from top to bottom it has the exact sequence of symbols required If a symbol occurs multiple times, we repeat the row in the appropriate location Constrain that the first symbol in the decode must be the top left block The last symbol must be the bottom right The rest of the symbols must follow a sequence that monotonically travels down from top left to bottom right This guarantees that the sequence is an expansion of the target sequence Compose a graph such that every path in the graph from source to sink represents a valid alignment The â€œscoreâ€ of a path is the product of the probabilities of all nodes along the path Find the most probable path from source to sink using any dynamic programming algorithm (viterbi algorithm) Viterbi algorithm Main idea The best path to any node must be an extension of the best path to one of its parent nodes Dynamically track the best path (and the score of the best path) from the source node to every node in the graph At each node, keep track of The best incoming parent edge (BP) The score of the best path from the source to the node through this best parent edge (Bscr) Process Algorithm Gradients DIV=âˆ‘tXent(Yt,symboltbestpath)=âˆ’âˆ‘tlogâ¡Y(t,symboltbestpath) D I V=\\sum_{t} X e n t\\left(Y_{t}, s y m b o l_{t}^{b e s t p a t h}\\right)=-\\sum_{t} \\log Y\\left(t, s y m b o l_{t}^{b e s t p a t h}\\right) DIV=tâˆ‘â€‹Xent(Ytâ€‹,symboltbestpathâ€‹)=âˆ’tâˆ‘â€‹logY(t,symboltbestpathâ€‹) The gradient w.r.t the -th output vector YtY_tYtâ€‹ âˆ‡YtDIV=[00â‹…â‹…â‹…âˆ’1Y(t,symboltbestpath)0â‹…â‹…â‹…0] \\nabla_{Y_{t}} D I V=[0 \\quad 0 \\cdot \\cdot \\cdot \\frac{-1}{Y(t, s y m b o l_{t}^{b e s t p a t h})} \\quad 0 \\cdot \\cdot \\cdot 0] âˆ‡Ytâ€‹â€‹DIV=[00â‹…â‹…â‹…Y(t,symboltbestpathâ€‹)âˆ’1â€‹0â‹…â‹…â‹…0] Problem Approach heavily dependent on initial alignment Prone to poor local optima Because we commit to the single â€œbestâ€ estimated alignment This can be way off, particularly in early iterations, or if the model is poorly initialized Alternate view There is a probability distribution over alignments of the target Symbol sequence (to the input) Selecting a single alignment is the same as drawing a single sample from it Instead of only selecting the most likely alignment, use the statistical expectation over all possible alignments DIV=E[âˆ’âˆ‘tlogâ¡Y(t,st)] D I V=E\\left[-\\sum_{t} \\log Y\\left(t, s_{t}\\right)\\right] DIV=E[âˆ’tâˆ‘â€‹logY(t,stâ€‹)] Use the entire distribution of alignments This will mitigate the issue of suboptimal selection of alignment Using the linearity of expectation DIV=âˆ’âˆ‘tE[logâ¡Y(t,st)] D I V=-\\sum_{t} E\\left[\\log Y\\left(t, s_{t}\\right)\\right] DIV=âˆ’tâˆ‘â€‹E[logY(t,stâ€‹)] DIV=âˆ’âˆ‘tâˆ‘SâˆˆS1â€¦SKP(st=Sâˆ£S,X)logâ¡Y(t,st=S) D I V=-\\sum_{t} \\sum_{S \\in S_{1} \\ldots S_{K}} P\\left(s_{t}=S | \\mathbf{S}, \\mathbf{X}\\right) \\log Y\\left(t, s_{t}=S\\right) DIV=âˆ’tâˆ‘â€‹SâˆˆS1â€‹â€¦SKâ€‹âˆ‘â€‹P(stâ€‹=Sâˆ£S,X)logY(t,stâ€‹=S) A posteriori probabilities of symbols P(st=Sâˆ£S,X)P(s_{t}=S | \\mathbf{S}, \\mathbf{X})P(stâ€‹=Sâˆ£S,X) is the probability of seeing the specific symbol sss at time ttt, given that the symbol sequence is an expansion of S=s0,...,SKâˆ’1S = s_0,...,S_{K-1}S=s0â€‹,...,SKâˆ’1â€‹ and given the input sequence X=Xo,...,XNâˆ’1X = X_o,...,X_{N-1}X=Xoâ€‹,...,XNâˆ’1â€‹ P(st=Srâˆ£S,X)âˆP(st=Sr,Sâˆ£X)P\\left(s_{t}=S_{r} | \\mathbf{S}, \\mathbf{X}\\right) \\propto P\\left(s_{t}=S_{r}, \\mathbf{S} | \\mathbf{X}\\right)P(stâ€‹=Srâ€‹âˆ£S,X)âˆP(stâ€‹=Srâ€‹,Sâˆ£X) P(st=Sr,Sâˆ£X)P\\left(s_{t}=S_{r}, \\mathbf{S} | \\mathbf{X}\\right)P(stâ€‹=Srâ€‹,Sâˆ£X) is the total probability of all valid paths in the graph for target sequence SSS that go through the symbol SrS_rSrâ€‹ (the rthr^{th}rth symbol in the sequence S0,...,SKâˆ’1S_0,...,S_{K-1}S0â€‹,...,SKâˆ’1â€‹ ) at time For a recurrent network without feedback from the output we can make the conditional independence assumption P(st=Sr,Sâˆ£X)=P(S0â€¦Sr,st=Srâˆ£X)P(st+1âˆˆsuccâ¡(Sr),succâ¡(Sr),â€¦,SKâˆ’1âˆ£X) P\\left(s_{t}=S_{r}, \\mathbf{S} | \\mathbf{X}\\right)=P\\left(S_{0} \\ldots S_{r}, s_{t}=S_{r} | \\mathbf{X}\\right) P\\left(s_{t+1} \\in \\operatorname{succ}\\left(S_{r}\\right), \\operatorname{succ}\\left(S_{r}\\right), \\ldots, S_{K-1} | \\mathbf{X}\\right) P(stâ€‹=Srâ€‹,Sâˆ£X)=P(S0â€‹â€¦Srâ€‹,stâ€‹=Srâ€‹âˆ£X)P(st+1â€‹âˆˆsucc(Srâ€‹),succ(Srâ€‹),â€¦,SKâˆ’1â€‹âˆ£X) We will call the first term the forward probability Î±(t,r)\\alpha(t,r)Î±(t,r) We will call the second term the backward probability Î²(t,r)\\beta(t,r)Î²(t,r) Forward algorithm In practice the recursion will gererally underflow Î±(t,l)=(Î±(tâˆ’1,l)+Î±(tâˆ’1,lâˆ’1))ytS(l) \\alpha(t, l)=(\\alpha(t-1, l)+\\alpha(t-1, l-1)) y_{t}^{S(l)} Î±(t,l)=(Î±(tâˆ’1,l)+Î±(tâˆ’1,lâˆ’1))ytS(l)â€‹ Instead we can do it in the log domain logâ¡Î±(t,l)=logâ¡(elogâ¡Î±(tâˆ’1,l)+elogâ¡Î±(tâˆ’1,lâˆ’1))+logâ¡ytS(l) \\log \\alpha(t, l)=\\log \\left(e^{\\log \\alpha(t-1, l)}+e^{\\log \\alpha(t-1, l-1)}\\right)+\\log y_{t}^{S(l)} logÎ±(t,l)=log(elogÎ±(tâˆ’1,l)+elogÎ±(tâˆ’1,lâˆ’1))+logytS(l)â€‹ Backward algorithm Î²(t,r)=P(st+1âˆˆsuccâ¡(Sr),succâ¡(Sr),â€¦,SKâˆ’1âˆ£X) \\beta(t, r)=P\\left(s_{t+1} \\in \\operatorname{succ}\\left(S_{r}\\right), \\operatorname{succ}\\left(S_{r}\\right), \\ldots, S_{K-1} | \\mathbf{X}\\right) Î²(t,r)=P(st+1â€‹âˆˆsucc(Srâ€‹),succ(Srâ€‹),â€¦,SKâˆ’1â€‹âˆ£X) The joint probability P(st=Sr,Sâˆ£X)=Î±(t,r)Î²(t,r) P\\left(s_{t}=S_{r}, \\mathbf{S} | \\mathbf{X}\\right)=\\alpha(t, r) \\beta(t, r) P(stâ€‹=Srâ€‹,Sâˆ£X)=Î±(t,r)Î²(t,r) Need to be normalized, get posterior probability Î³(t,r)=P(st=Srâˆ£S,X)=P(st=Sr,Sâˆ£X)âˆ‘Srâ€²P(st=Srâ€²,Sâˆ£X)=Î±(t,r)Î²(t,r)âˆ‘râ€²Î±(t,râ€²)Î²(t,râ€²) \\gamma(t,r) = P\\left(s_{t}=S_{r} | \\mathbf{S}, \\mathbf{X}\\right)=\\frac{P\\left(s_{t}=S_{r}, \\mathbf{S} | \\mathbf{X}\\right)}{\\sum_{S_{r}^{\\prime}} P\\left(s_{t}=S_{r}^{\\prime}, \\mathbf{S} | \\mathbf{X}\\right)}=\\frac{\\alpha(t, r) \\beta(t, r)}{\\sum_{r^{\\prime}} \\alpha\\left(t, r^{\\prime}\\right) \\beta\\left(t, r^{\\prime}\\right)} Î³(t,r)=P(stâ€‹=Srâ€‹âˆ£S,X)=âˆ‘Srâ€²â€‹â€‹P(stâ€‹=Srâ€²â€‹,Sâˆ£X)P(stâ€‹=Srâ€‹,Sâˆ£X)â€‹=âˆ‘râ€²â€‹Î±(t,râ€²)Î²(t,râ€²)Î±(t,r)Î²(t,r)â€‹ We can also write this using the modified beta formula as (you will see this in papers) Î³(t,r)=1ytS(r)Î±(t,r)Î²^(t,r)âˆ‘râ€²1ytS(r)Î±(t,r)Î²^(t,r) \\gamma(t, r)=\\frac{\\frac{1}{y_{t}^{S(r)}} \\alpha(t, r) \\hat{\\beta}(t, r)}{\\sum_{r^{\\prime}} \\frac{1}{y_{t}^{S(r)}} \\alpha(t, r) \\hat{\\beta}(t, r)} Î³(t,r)=âˆ‘râ€²â€‹ytS(r)â€‹1â€‹Î±(t,r)Î²^â€‹(t,r)ytS(r)â€‹1â€‹Î±(t,r)Î²^â€‹(t,r)â€‹ The expected divergence DIV=âˆ’âˆ‘tâˆ‘sâˆˆS0â€¦SKâˆ’1P(st=sâˆ£S,X)logâ¡Y(t,st=s) D I V=-\\sum_{t} \\sum_{s \\in S_{0} \\ldots S_{K-1}} P\\left(s_{t}=s | \\mathbf{S}, \\mathbf{X}\\right) \\log Y\\left(t, s_{t}=s\\right) DIV=âˆ’tâˆ‘â€‹sâˆˆS0â€‹â€¦SKâˆ’1â€‹âˆ‘â€‹P(stâ€‹=sâˆ£S,X)logY(t,stâ€‹=s) DIV=âˆ’âˆ‘tâˆ‘rÎ³(t,r)logâ¡ytS(r) D I V=-\\sum_{t} \\sum_{r} \\gamma(t, r) \\log y_{t}^{S(r)} DIV=âˆ’tâˆ‘â€‹râˆ‘â€‹Î³(t,r)logytS(r)â€‹ The derivative of the divergence w.r.t the output YtY_tYtâ€‹ of the net at any time âˆ‡YtDIV=[dDIVdytS0dDIVdytS1â‹¯dDIVdytSLâˆ’1] \\nabla_{Y_{t}} D I V=\\left[\\begin{array}{llll} \\frac{d D I V}{d y_{t}^{S_{0}}} & \\frac{d D I V}{d y_{t}^{S_{1}}} & \\cdots & \\frac{d D I V}{d y_{t}^{S_{L-1}}} \\end{array}\\right] âˆ‡Ytâ€‹â€‹DIV=[dytS0â€‹â€‹dDIVâ€‹â€‹dytS1â€‹â€‹dDIVâ€‹â€‹â‹¯â€‹dytSLâˆ’1â€‹â€‹dDIVâ€‹â€‹] Compare to Viterbi algorithm, components will be non-zero only for symbols that occur in the training instance Compute derivative dDIVdytl=âˆ’âˆ‘r:S(r)=lddytS(r)Î³(t,r)logâ¡ytS(r) \\frac{d D I V}{d y_{t}^{l}}=-\\sum_{r: S(r)=l} \\frac{d}{d y_{t}^{S(r)}} \\gamma(t, r) \\log y_{t}^{S(r)} dytlâ€‹dDIVâ€‹=âˆ’r:S(r)=lâˆ‘â€‹dytS(r)â€‹dâ€‹Î³(t,r)logytS(r)â€‹ ddytS(r)Î³(t,r)logâ¡ytS(r)=Î³(t,r)ytS(r)+dÎ³(t,r)dytS(r)logâ¡ytS(r) \\frac{d}{d y_{t}^{S(r)}} \\gamma(t, r) \\log y_{t}^{S(r)}=\\frac{\\gamma(t, r)}{y_{t}^{S(r)}}+\\frac{d \\gamma(t, r)}{d y_{t}^{S(r)}} \\log y_{t}^{S(r)} dytS(r)â€‹dâ€‹Î³(t,r)logytS(r)â€‹=ytS(r)â€‹Î³(t,r)â€‹+dytS(r)â€‹dÎ³(t,r)â€‹logytS(r)â€‹ Normally we ignore the second term, and think of as a maximum-likelihood estimate And the derivatives at both these locations must be summed if occurs repetition dDIVdytl=âˆ’âˆ‘r:S(r)=lÎ³(t,r)ytS(r) \\frac{d D I V}{d y_{t}^{l}}=-\\sum_{r: S(r)=l} \\frac{\\gamma(t, r)}{y_{t}^{S(r)}} dytlâ€‹dDIVâ€‹=âˆ’r:S(r)=lâˆ‘â€‹ytS(r)â€‹Î³(t,r)â€‹ Repetitive decoding problem Cannot distinguish between an extended symbol and repetitions of the symbol We have a decode: R R R O O O O O D Is this the symbol sequence ROD or ROOD? Solution: Introduce an explicit extra symbol which serves to separate discrete versions of a symbol A â€œblankâ€ (represented by â€œ-â€) RRR---OO---DDD = ROD RR-R---OO---D-DD = RRODD Modified forward algorithm A blank is mandatory between repetitions of a symbol but not required between distinct symbols Skips are permitted across a blank, but only if the symbols on either side are different Modified backward algorithm Overall training procedure Setup the network Typically many-layered LSTM Initialize all parameters of the network Include a ã€Œblankã€ symbol in vocabulary Foreach training instance Pass the training instance through the network and obtain all symbol probabilities at each time Construct the graph representing the specific symbol sequence in the instance Backword pass Perform the forward backward algorithm to compute Î±(t,r)\\alpha(t,r)Î±(t,r) and Î²(t,r)\\beta(t,r)Î²(t,r) Compute derivative of divergence âˆ‡YtDIV\\nabla_{Y_{t}} D I Vâˆ‡Ytâ€‹â€‹DIV for each YtY_tYtâ€‹ âˆ‡YtDIV=[dDIVdyt0dDIVdyt1â‹¯dDIVdytLâˆ’1]\\nabla_{Y_{t}} D I V=\\left[\\begin{array}{llll}\\frac{d D I V}{d y_{t}^{0}} & \\frac{d D I V}{d y_{t}^{1}} & \\cdots & \\frac{d D I V}{d y_{t}^{L-1}}\\end{array}\\right]âˆ‡Ytâ€‹â€‹DIV=[dyt0â€‹dDIVâ€‹â€‹dyt1â€‹dDIVâ€‹â€‹â‹¯â€‹dytLâˆ’1â€‹dDIVâ€‹â€‹] dDIVdytl=âˆ’âˆ‘r:S(r)=lÎ³(t,r)ytS(r)\\frac{d D I V}{d y_{t}^{l}}=-\\sum_{r: S(r)=l} \\frac{\\gamma(t, r)}{y_{t}^{S(r)}}dytlâ€‹dDIVâ€‹=âˆ’r:S(r)=lâˆ‘â€‹ytS(r)â€‹Î³(t,r)â€‹ Aggregate derivatives over minibatch and update parameters CTC: Connectionist Temporal Classification The overall framework is referred to as CTC This is in fact a suboptimal decode that actually finds the most likely time-synchronous output sequence Actual decoding objective S^=argmaxâ¡sÎ±S(SKâˆ’1,Tâˆ’1)\\hat{\\mathbf{S}}=\\underset{\\mathbf{s}}{\\operatorname{argmax}} \\alpha_{\\mathbf{S}}\\left(S_{K-1}, T-1\\right)S^=sargmaxâ€‹Î±Sâ€‹(SKâˆ’1â€‹,Tâˆ’1) Explicit computation of this will require evaluate of an exponential number of symbol sequences Beam search Only used in test Uses breadth-first search to build its search tree Choose top k words for next prediction (prone) Reference "},"L17 Seq2seq and attention model.html":{"url":"L17 Seq2seq and attention model.html","title":"16 Seq 2 Seq And Attention Model","keywords":"","body":"Generating Language Synthesis Input: symbols as one-hot vectors Dimensionality of the vector is the size of the ã€Œvocabularyã€ Projected down to lower-dimensional â€œembeddingsâ€ The hidden units are (one or more layers of) LSTM units Output at each time: A probability distribution that ideally assigns peak probability to the next word in the sequence Divergence Divâ¡(Ytarget(1â€¦T),Y(1â€¦T))=âˆ‘_tXentâ¡(Y_target(t),Y(t))=âˆ’âˆ‘_tlogâ¡Y(t,w_t+1) \\operatorname{Div}(\\mathbf{Y}_{\\text {target}}(1 \\ldots T), \\mathbf{Y}(1 \\ldots T))=\\sum\\_{t}\\operatorname{Xent}(\\mathbf{Y}\\_{\\text {target}}(t), \\mathbf{Y}(t))=-\\sum\\_{t} \\log Y(t, w\\_{t+1}) Div(Ytargetâ€‹(1â€¦T),Y(1â€¦T))=âˆ‘_tXent(Y_target(t),Y(t))=âˆ’âˆ‘_tlogY(t,w_t+1) Feed the drawn word as the next word in the series And draw the next word from the output probability distribution Beginnings and ends A sequence of words by itself does not indicate if it is a complete sentence or not To make it explicit, we will add two additional symbols (in addition to the words) to the base vocabulary : Indicates start of a sentence : Indicates end of a sentence When do we stop? Continue this process until we draw an Or we decide to terminate generation based on some other criterion Delayed sequence to sequence Pseudocode Problem: Each word that is output depends only on current hidden state, and not on previous outputs The input sequence feeds into a recurrent structure The input sequence is terminated by an explicit symbol The hidden activation at the â€œstoresâ€ all information about the sentence Subsequently a second RNN uses the hidden activation as initial state to produce a sequence of outputs The output at each time becomes the input at the next time Output production continues until an is produced Autoencoder The recurrent structure that extracts the hidden representation from the input sequence is the encoder The recurrent structure that utilizes this representation to produce the output sequence is the decoder Generating output At each time the network produces a probability distribution over words, given the entire input and previous outputs At each time a word is drawn from the output distribution P(O1,â€¦,OLâˆ£W1in,â€¦,WNin)=y1O1y1O2â€¦y1OL P\\left(O_{1}, \\ldots, O_{L} \\mid W_{1}^{i n}, \\ldots, W_{N}^{i n}\\right)=y_{1}^{O_{1}} y_{1}^{O_{2}} \\ldots y_{1}^{O_{L}} P(O1â€‹,â€¦,OLâ€‹âˆ£W1inâ€‹,â€¦,WNinâ€‹)=y1O1â€‹â€‹y1O2â€‹â€‹â€¦y1OLâ€‹â€‹ The objective of drawing: Produce the most likely output (that ends in an ) argmaxâ¡O1,â€¦,OLy1O1y1O2â€¦y1OL \\underset{O_{1}, \\ldots, O_{L}}{\\operatorname{argmax}} y_{1}^{O_{1}} y_{1}^{O_{2}} \\ldots y_{1}^{O_{L}} O1â€‹,â€¦,OLâ€‹argmaxâ€‹y1O1â€‹â€‹y1O2â€‹â€‹â€¦y1OLâ€‹â€‹ How to draw words? Greedy answer Select the most probable word at each time Not good, making a poor choice at any time commits us to a poor future Randomly draw a word at each time according to the output probability distribution Not guaranteed to give you the most likely output Beam search Search multiple choices and prune At each time, retain only the top K scoring forks Terminate: When the current most likely path overall ends in Train In practice, if we apply SGD, we may randomly sample words from the output to actually use for the backprop and update Randomly select training instance: (input, output) Forward pass Randomly select a single output y(t)y(t)y(t) and corresponding desired output d(t)d(t)d(t) for backprop Trick The input sequence is fed in reverse order This happens both for training and during actual decode Problem All the information about the input sequence is embedded into a single vector In reality: All hidden values carry information Attention model Compute a weighted combination of all the hidden outputs into a single vector Weights vary by output time Require a time-varying weight that specifies relationship of output time to input time Weights are functions of current output state ei(t)=g(hi,stâˆ’1) e_{i}(t)=g\\left(\\boldsymbol{h}_{i}, \\boldsymbol{s}_{t-1}\\right) eiâ€‹(t)=g(hiâ€‹,stâˆ’1â€‹) wi(t)=expâ¡(ei(t))âˆ‘jexpâ¡(ej(t)) w_{i}(t)=\\frac{\\exp \\left(e_{i}(t)\\right)}{\\sum_{j} \\exp \\left(e_{j}(t)\\right)} wiâ€‹(t)=âˆ‘jâ€‹exp(ejâ€‹(t))exp(eiâ€‹(t))â€‹ Attention weight Typical option for g()g()g() Inner product g(h_i,s_tâˆ’1)=h_iTs_tâˆ’1g\\left(\\boldsymbol{h}\\_{i}, \\boldsymbol{s}\\_{t-1}\\right)=\\boldsymbol{h}\\_{i}^{T} \\boldsymbol{s}\\_{t-1}g(h_i,s_tâˆ’1)=h_iTs_tâˆ’1 Project to the same demension g(hi,s_tâˆ’1)=h_iTW_gs_tâˆ’1g\\left(\\boldsymbol{h}_{i}, \\boldsymbol{s}\\_{t-1}\\right)=\\boldsymbol{h}\\_{i}^{T} \\boldsymbol{W}\\_{g} \\boldsymbol{s}\\_{t-1}g(hiâ€‹,s_tâˆ’1)=h_iTW_gs_tâˆ’1 Non-linear activation g(h_i,s_tâˆ’1)=v_gTtanh(W_g[his_tâˆ’1])g\\left(\\boldsymbol{h}\\_{i}, \\boldsymbol{s}\\_{t-1}\\right)=v\\_{g}^{T} \\boldsymbol{t} \\boldsymbol{a} \\boldsymbol{n} \\boldsymbol{h}\\left(\\boldsymbol{W}\\_{g}\\left[\\begin{array}{c}\\boldsymbol{h}_{i} \\\\\\\\ \\boldsymbol{s}\\_{t-1}\\end{array}\\right]\\right)g(h_i,s_tâˆ’1)=v_gTtanhââ›â€‹W_gâ£â¡â€‹hiâ€‹s_tâˆ’1â€‹â¦â¤â€‹â ââ€‹ MLP g(h_i,s_tâˆ’1)=MLPâ¡([h_i,s_tâˆ’1])g\\left(\\boldsymbol{h}\\_{i}, \\boldsymbol{s}\\_{t-1}\\right)=\\operatorname{MLP}\\left(\\left[\\boldsymbol{h}\\_{i}, \\boldsymbol{s}\\_{t-1}\\right]\\right)g(h_i,s_tâˆ’1)=MLP([h_i,s_tâˆ’1]) Pseudocode Train Back propagation also updates parameters of the â€œattentionâ€ function Trick: Occasionally pass drawn output instead of ground truth, as input Randomly select from output, force network to produce correct word even the prioir word is not correct variants Bidirectional processing of input sequence Neural Machine Translation by Jointly Learning to Align and Translate Local attention vs global attention Effective Approaches to Attention-based Neural Machine Translation Multihead attention Derive ã€Œvalueã€, and multiple ã€Œkeysã€ from the encoder Vi,Kil,i=1â€¦T,l=1â€¦NheadV_{i}, K_{i}^{l}, i=1 \\ldots T, l=1 \\ldots N_{\\text {head}}Viâ€‹,Kilâ€‹,i=1â€¦T,l=1â€¦Nheadâ€‹ Derive one or more ã€Œqueriesã€ from decoder Qjl,j=1â€¦M,l=1â€¦NheadQ_{j}^{l}, j=1 \\ldots M, l=1 \\ldots N_{\\text {head}}Qjlâ€‹,j=1â€¦M,l=1â€¦Nheadâ€‹ Each query-key pair gives you one attention distribution And one context vector aj,il=a_{j, i}^{l}=aj,ilâ€‹=attention(Qjl,Kil,i=1â€¦T),Cjl=âˆ‘iaj,ilVi\\left(Q_{j}^{l}, K_{i}^{l}, i=1 \\ldots T\\right), \\quad C_{j}^{l}=\\sum_{i} a_{j, i}^{l} V_{i}(Qjlâ€‹,Kilâ€‹,i=1â€¦T),Cjlâ€‹=âˆ‘iâ€‹aj,ilâ€‹Viâ€‹ Concatenate set of context vectors into one extended context vector Cj=[Cj1Cj2â€¦CjNhead]C_{j}=\\left[C_{j}^{1} C_{j}^{2} \\ldots C_{j}^{N_{\\text {head}}}\\right]Cjâ€‹=[Cj1â€‹Cj2â€‹â€¦CjNheadâ€‹â€‹] Each ã€Œattenderã€ focuses on a different aspect of the input thatâ€™s important for the decode "},"L18 Representation.html":{"url":"L18 Representation.html","title":"17 Representation","keywords":"","body":"Logistic regression This the perceptron with a sigmoid activation It actually computes the probability that the input belongs to class 1 Decision boundaries may be obtained by comparing the probability to a threshold These boundaries will be lines (hyperplanes in higher dimensions) The sigmoid perceptron is a linear classifier Estimating the model Given: Training data: (X1,y1),(X2,y2),â€¦,(XN,yN)\\left(X_{1}, y_{1}\\right),\\left(X_{2}, y_{2}\\right), \\ldots,\\left(X_{N}, y_{N}\\right)(X1â€‹,y1â€‹),(X2â€‹,y2â€‹),â€¦,(XNâ€‹,yNâ€‹) XXX are vectors, yyy are binary (0/1) class values Total probability of data P((X1,y1),(X2,y2),â€¦,(XN,yN))=âˆiP(Xi,yi)=âˆiP(yiâˆ£Xi)P(Xi)=âˆi11+eâˆ’yi(w0+wTXi)P(Xi) \\begin{array}{l} P\\left(\\left(X_{1}, y_{1}\\right),\\left(X_{2}, y_{2}\\right), \\ldots,\\left(X_{N}, y_{N}\\right)\\right)= \\prod_{i} P\\left(X_{i}, y_{i}\\right) \\\\\\\\ =\\prod_{i} P\\left(y_{i} \\mid X_{i}\\right) P\\left(X_{i}\\right)=\\prod_{i} \\frac{1}{1+e^{-y_{i}\\left(w_{0}+w^{T} X_{i}\\right)}} P\\left(X_{i}\\right) \\end{array} P((X1â€‹,y1â€‹),(X2â€‹,y2â€‹),â€¦,(XNâ€‹,yNâ€‹))=âˆiâ€‹P(Xiâ€‹,yiâ€‹)=âˆiâ€‹P(yiâ€‹âˆ£Xiâ€‹)P(Xiâ€‹)=âˆiâ€‹1+eâˆ’yiâ€‹(w0â€‹+wTXiâ€‹)1â€‹P(Xiâ€‹)â€‹ Likelihood P(TrainingÂ data)=âˆi11+eâˆ’yi(w0+wTXi)P(Xi) P(\\text {Training data})=\\prod_{i} \\frac{1}{1+e^{-y_{i}\\left(w_{0}+w^{T} X_{i}\\right)}} P\\left(X_{i}\\right) P(TrainingÂ data)=iâˆâ€‹1+eâˆ’yiâ€‹(w0â€‹+wTXiâ€‹)1â€‹P(Xiâ€‹) Log likelihood logâ¡P(TrainingÂ data)=âˆ‘ilogâ¡P(Xi)âˆ’âˆ‘ilogâ¡(1+eâˆ’yi(w0+wTXi)) \\begin{array}{l} \\log P(\\text {Training data})= \\sum_{i} \\log P\\left(X_{i}\\right)-\\sum_{i} \\log \\left(1+e^{-y_{i}\\left(w_{0}+w^{T} X_{i}\\right)}\\right) \\end{array} logP(TrainingÂ data)=âˆ‘iâ€‹logP(Xiâ€‹)âˆ’âˆ‘iâ€‹log(1+eâˆ’yiâ€‹(w0â€‹+wTXiâ€‹))â€‹ Maximum Likelihood Estimate w0,w1=argmaxâ¡w0,w1logâ¡P(TrainingÂ data) w_{0}, w_{1}=\\underset{w_{0}, w_{1}}{\\operatorname{argmax}} \\log P(\\text {Training data}) w0â€‹,w1â€‹=w0â€‹,w1â€‹argmaxâ€‹logP(TrainingÂ data) Equals (note argmin rather than argmax) w0,w1=argminâ¡w0,wâˆ‘ilogâ¡(1+eâˆ’yi(w0+wTXi)) w_{0}, w_{1}=\\underset{w_{0}, w}{\\operatorname{argmin}} \\sum_{i} \\log \\left(1+e^{-y_{i}\\left(w_{0}+w^{T} X_{i}\\right)}\\right) w0â€‹,w1â€‹=w0â€‹,wargminâ€‹iâˆ‘â€‹log(1+eâˆ’yiâ€‹(w0â€‹+wTXiâ€‹)) Identical to minimizing the KL divergence between the desired output and actual output 11+eâˆ’(w0+wTXi)\\frac{1}{1+e^{-\\left(w_{0}+w^{T} X_{i}\\right)}}1+eâˆ’(w0â€‹+wTXiâ€‹)1â€‹ MLP Separable case The rest of the network may be viewed as a transformation that transforms data from non-linear classes to linearly separable features We can now attach any linear classifier above it for perfect classification Need not be a perceptron Could even train an SVM on top of the features! For insufficient structures, the network may attempt to transform the inputs to linearly separable features Will fail to separate exactly, but will try to minimize error The network until the second-to-last layer is a non-linear function f(X)f(X)f(X) that converts the input space XXX of into the feature space where the classes are maximally linearly separable Lower layers Manifold hypothesis: For separable classes, the classes are linearly separable on a non-linear manifold Layers sequentially â€œstraightenâ€ the data manifold The â€œfeature extractionâ€ layer transforms the data such that the posterior probability may now be modelled by a logistic Weight as a template In high dimensional space, all vectors are more or less the same length Which means all xxx are in this surface of sphere The perceptron fires if the input is within a specified angle of the weight Represents a convex region on the surface of the sphere! The network is a Boolean function over these regions Neuron fires if the input vector is close enough to the weight vector If the input pattern matches the weight pattern closely enough The perceptron is a correlation filter! Autoencoder The lowest layers of a network detect significant features in the signal The signal could be (partially) reconstructed using these features Will retain all the significant components of the signal Simplest autoencoder This is just PCA! The autoencoder finds the direction of maximum energy Simply varying the hidden representation will result in an output that lies along the major axis Terminology Encoder The â€œAnalysisâ€ net which computes the hidden representation Decoder The â€œSynthesisâ€ which recomposes the data from the hidden representation Nonlinearity When the hidden layer has a linear activation the decoder represents the best linear manifold to fit the data Varying the hidden value will move along this linear manifold When the hidden layer has non-linear activation, the net performs nonlinear PCA The decoder represents the best non-linear manifold to fit the data Varying the hidden value will move along this non-linear manifold The model is specific to the training data Varying the hidden layer value only generates data along the learned manifold Any input will result in an output along the learned manifold But may not generalize beyond the manifold Input unseen data may behave beyond intuitive manner, no constrain! The decoder can only generate data on the manifold that the training data lie on This also makes it an excellent â€œgeneratorâ€ of the distribution of the training data Dictionary-based techniques The decoder represents a source-specific generative dictionary Exciting it will produce typical data from the source! Signal separation Separation: Identify the combination of entries from both dictionaries that compose the mixed signal Given mixed signal and source dictionaries, find excitation that best recreates mixed signal Simple backpropagation Intermediate results are separated signals "},"L19 Hopfield network.html":{"url":"L19 Hopfield network.html","title":"18 Hopfield Network","keywords":"","body":"Hopfield Net So far, neural networks for computation are all feedforward structures Loopy network Each neuron is a perceptron with +1/-1 output Every neuron receives input from every other neuron Every neuron outputs signals to every other neuron At each time each neuron receives a â€œfieldâ€ âˆ‘jâ‰ iwjiyj+bi\\sum_{j \\neq i} w_{j i} y_{j}+b_{i}âˆ‘jâ‰ iâ€‹wjiâ€‹yjâ€‹+biâ€‹ If the sign of the field matches its own sign, it does not respond If the sign of the field opposes its own sign, it â€œflipsâ€ to match the sign of the field If the sign of the field at any neuron opposes its own sign, it â€œflipsâ€ to match the field Which will change the field at other nodes Which may then flip... and so on... Filp behavior Let yiâˆ’y^{-}_{i}yiâˆ’â€‹ be the output of the iii-th neuron just before it responds to the current field Let yi+y_{i}^{+}yi+â€‹ be the output of the iii-th neuron just after it responds to the current field if yiâˆ’=signâ¡(âˆ‘jâ‰ iwjiyj+bi)y_{i}^{-}=\\operatorname{sign}\\left(\\sum_{j \\neq i} w_{j i} y_{j}+b_{i}\\right)yiâˆ’â€‹=sign(âˆ‘jâ‰ iâ€‹wjiâ€‹yjâ€‹+biâ€‹), then yi+=âˆ’yiâˆ’y_{i}^{+} = -y_{i}^{-}yi+â€‹=âˆ’yiâˆ’â€‹ If the sign of the field matches its own sign, it does not flip yi+(âˆ‘jâ‰ iwjiyj+bi)âˆ’yiâˆ’(âˆ‘jâ‰ iwjiyj+bi)=0 y_{i}^{+}\\left(\\sum_{j \\neq i} w_{j i} y_{j}+b_{i}\\right)-y_{i}^{-}\\left(\\sum_{j \\neq i} w_{j i} y_{j}+b_{i}\\right)=0 yi+â€‹ââ›â€‹jâ‰ iâˆ‘â€‹wjiâ€‹yjâ€‹+biâ€‹â ââ€‹âˆ’yiâˆ’â€‹ââ›â€‹jâ‰ iâˆ‘â€‹wjiâ€‹yjâ€‹+biâ€‹â ââ€‹=0 if yiâˆ’â‰ signâ¡(âˆ‘jâ‰ iwjiyj+bi)y_{i}^{-}\\neq\\operatorname{sign}\\left(\\sum_{j \\neq i} w_{j i} y_{j}+b_{i}\\right)yiâˆ’â€‹â‰ sign(âˆ‘jâ‰ iâ€‹wjiâ€‹yjâ€‹+biâ€‹), then yi+=âˆ’yiâˆ’y_{i}^{+} = -y_{i}^{-}yi+â€‹=âˆ’yiâˆ’â€‹ yi+(âˆ‘jâ‰ iwjiyj+bi)âˆ’yiâˆ’(âˆ‘jâ‰ iwjiyj+bi)=2yi+(âˆ‘jâ‰ iwjiyj+bi) y_{i}^{+}\\left(\\sum_{j \\neq i} w_{j i} y_{j}+b_{i}\\right)-y_{i}^{-}\\left(\\sum_{j \\neq i} w_{j i} y_{j}+b_{i}\\right)=2 y_{i}^{+}\\left(\\sum_{j \\neq i} w_{j i} y_{j}+b_{i}\\right) yi+â€‹ââ›â€‹jâ‰ iâˆ‘â€‹wjiâ€‹yjâ€‹+biâ€‹â ââ€‹âˆ’yiâˆ’â€‹ââ›â€‹jâ‰ iâˆ‘â€‹wjiâ€‹yjâ€‹+biâ€‹â ââ€‹=2yi+â€‹ââ›â€‹jâ‰ iâˆ‘â€‹wjiâ€‹yjâ€‹+biâ€‹â ââ€‹ This term is always positive! Every flip of a neuron is guaranteed to locally increase yi(âˆ‘jâ‰ iwjiyj+bi)y_{i}\\left(\\sum_{j \\neq i} w_{j i} y_{j}+b_{i}\\right)yiâ€‹(âˆ‘jâ‰ iâ€‹wjiâ€‹yjâ€‹+biâ€‹) Globally Consider the following sum across all nodes D(y1,y2,â€¦,yN)=âˆ‘iyi(âˆ‘jâ‰ iwjiyj+bi)=âˆ‘i,jâ‰ iwijyiyj+âˆ‘ibiyi \\begin{array}{c} D\\left(y_{1}, y_{2}, \\ldots, y_{N}\\right)=\\sum_{i} y_{i}\\left(\\sum_{j \\neq i} w_{j i} y_{j}+b_{i}\\right) \\\\\\\\ =\\sum_{i, j \\neq i} w_{i j} y_{i} y_{j}+\\sum_{i} b_{i} y_{i} \\end{array} D(y1â€‹,y2â€‹,â€¦,yNâ€‹)=âˆ‘iâ€‹yiâ€‹(âˆ‘jâ‰ iâ€‹wjiâ€‹yjâ€‹+biâ€‹)=âˆ‘i,jâ‰ iâ€‹wijâ€‹yiâ€‹yjâ€‹+âˆ‘iâ€‹biâ€‹yiâ€‹â€‹ Assume wii=0w_{ii} = 0wiiâ€‹=0 For any unit kkk that â€œflipsâ€ because of the local field Î”D(yk)=D(y1,â€¦,yk+,â€¦,yN)âˆ’D(y1,â€¦,ykâˆ’,â€¦,yN) \\Delta D\\left(y_{k}\\right)=D\\left(y_{1}, \\ldots, y_{k}^{+}, \\ldots, y_{N}\\right)-D\\left(y_{1}, \\ldots, y_{k}^{-}, \\ldots, y_{N}\\right) Î”D(ykâ€‹)=D(y1â€‹,â€¦,yk+â€‹,â€¦,yNâ€‹)âˆ’D(y1â€‹,â€¦,ykâˆ’â€‹,â€¦,yNâ€‹) Î”D(yk)=(yk+âˆ’ykâˆ’)(âˆ‘jâ‰ kwjkyj+bk) \\Delta D\\left(y_{k}\\right)=\\left(y_{k}^{+}-y_{k}^{-}\\right)\\left(\\sum_{j \\neq k} w_{j k} y_{j}+b_{k}\\right) Î”D(ykâ€‹)=(yk+â€‹âˆ’ykâˆ’â€‹)ââ›â€‹jâ‰ kâˆ‘â€‹wjkâ€‹yjâ€‹+bkâ€‹â ââ€‹ This is always positive! Every flip of a unit results in an increase in DDD Overall Flipping a unit will result in an increase (non-decrease) of D=âˆ‘i,jâ‰ iwijyiyj+âˆ‘ibiyi D=\\sum_{i, j \\neq i} w_{i j} y_{i} y_{j}+\\sum_{i} b_{i} y_{i} D=i,jâ‰ iâˆ‘â€‹wijâ€‹yiâ€‹yjâ€‹+iâˆ‘â€‹biâ€‹yiâ€‹ DDD is bounded Dmaxâ¡=âˆ‘i,jâ‰ iâˆ£wijâˆ£+âˆ‘iâˆ£biâˆ£ D_{\\max }=\\sum_{i, j \\neq i}\\left|w_{i j}\\right|+\\sum_{i}\\left|b_{i}\\right| Dmaxâ€‹=i,jâ‰ iâˆ‘â€‹âˆ£wijâ€‹âˆ£+iâˆ‘â€‹âˆ£biâ€‹âˆ£ The minimum increment of DDD in a flip is Î”Dminâ¡=minâ¡i,{yi,i=1.â€¦N}2âˆ£âˆ‘jâ‰ iwjiyj+biâˆ£ \\Delta D_{\\min }=\\min _{i,\\{y_{i}, i=1 . \\ldots N\\}} 2|\\sum_{j \\neq i} w_{j i} y_{j}+b_{i}| Î”Dminâ€‹=i,{yiâ€‹,i=1.â€¦N}minâ€‹2âˆ£jâ‰ iâˆ‘â€‹wjiâ€‹yjâ€‹+biâ€‹âˆ£ Any sequence of flips must converge in a finite number of steps Think of this as an infinite deep network where every weights at every layers are identical Find the maximum layer! The Energy of a Hopfield Net Define the Energy of the network as E=âˆ’âˆ‘i,jâ‰ iwijyiyjâˆ’âˆ‘ibiyi E=-\\sum_{i, j \\neq i} w_{i j} y_{i} y_{j}-\\sum_{i} b_{i} y_{i} E=âˆ’i,jâ‰ iâˆ‘â€‹wijâ€‹yiâ€‹yjâ€‹âˆ’iâˆ‘â€‹biâ€‹yiâ€‹ Just the negative of DDD The evolution of a Hopfield network constantly decreases its energy This is analogous to the potential energy of a spin glass(Magnetic diploes) The system will evolve until the energy hits a local minimum We remove bias for better understanding The network will evolve until it arrives at a local minimum in the energy contour Content-addressable memory Each of the minima is a â€œstoredâ€ pattern If the network is initialized close to a stored pattern, it will inevitably evolve to the pattern This is a content addressable memory Recall memory content from partial or corrupt values Also called associative memory Evolve and recall pattern by content, not by location Evolution The network will evolve until it arrives at a local minimum in the energy contour We proved that every change in the network will result in decrease in energy So path to energy minimum is monotonic For 2-neuron net Symmetric âˆ’12yTWy=âˆ’12(âˆ’y)TW(âˆ’y)-\\frac{1}{2} \\mathbf{y}^{T} \\mathbf{W} \\mathbf{y}=-\\frac{1}{2}(-\\mathbf{y})^{T} \\mathbf{W}(-\\mathbf{y})âˆ’21â€‹yTWy=âˆ’21â€‹(âˆ’y)TW(âˆ’y) If y^\\hat{y}y^â€‹ is a local minimum, so is âˆ’y^-\\hat{y}âˆ’y^â€‹ Computational algorithm Very simple Updates can be done sequentially, or all at once Convergence when it deos not chage significantly any more E=âˆ’âˆ‘iâˆ‘j>iwjiyjyi E=-\\sum_{i} \\sum_{j>i} w_{j i} y_{j} y_{i} E=âˆ’iâˆ‘â€‹j>iâˆ‘â€‹wjiâ€‹yjâ€‹yiâ€‹ Issues Store a specific pattern A network can store multiple patterns Every stable point is a stored pattern So we could design the net to store multiple patterns Remember that every stored pattern PPP is actually two stored patterns, PPP and âˆ’P-Pâˆ’P How could the quadrtic function have multiple minimum? (Convex function) Input has constrain (belong to (âˆ’1,1)(-1,1)(âˆ’1,1) ) Hebbian learning: wji=yjyiw_{j i}=y_{j} y_{i}wjiâ€‹=yjâ€‹yiâ€‹ Design a stationary pattern signâ¡(âˆ‘jâ‰ iwjiyj)=yiâˆ€i\\operatorname{sign}\\left(\\sum_{j \\neq i} w_{j i} y_{j}\\right)=y_{i} \\quad \\forall isign(âˆ‘jâ‰ iâ€‹wjiâ€‹yjâ€‹)=yiâ€‹âˆ€i So signâ¡(âˆ‘jâ‰ iwjiyj)=signâ¡(âˆ‘jâ‰ iyjyiyj)\\operatorname{sign}\\left(\\sum_{j \\neq i} w_{j i} y_{j}\\right)=\\operatorname{sign}\\left(\\sum_{j \\neq i} y_{j} y_{i} y_{j}\\right)sign(âˆ‘jâ‰ iâ€‹wjiâ€‹yjâ€‹)=sign(âˆ‘jâ‰ iâ€‹yjâ€‹yiâ€‹yjâ€‹) =signâ¡(âˆ‘jâ‰ iyj2yi)=signâ¡(yi)=yi\\quad=\\operatorname{sign}\\left(\\sum_{j \\neq i} y_{j}^{2} y_{i}\\right)=\\operatorname{sign}\\left(y_{i}\\right)=y_{i}=sign(âˆ‘jâ‰ iâ€‹yj2â€‹yiâ€‹)=sign(yiâ€‹)=yiâ€‹ Energy E=âˆ’âˆ‘iâˆ‘jiwjiyjyi=âˆ’âˆ‘iâˆ‘jiyi2yj2=âˆ’âˆ‘iâˆ‘ji1=âˆ’0.5N(Nâˆ’1)\\begin{aligned} E=&-\\sum_{i} \\sum_{jE=â€‹âˆ’iâˆ‘â€‹jiâˆ‘â€‹wjiâ€‹yjâ€‹yiâ€‹=âˆ’iâˆ‘â€‹jiâˆ‘â€‹yi2â€‹yj2â€‹=âˆ’iâˆ‘â€‹jiâˆ‘â€‹1=âˆ’0.5N(Nâˆ’1)â€‹ This is the lowest possible energy value for the network Stored pattern has lowest energy No matter where it begin, it will evolve into yellow pattern(lowest energy) How many patterns can we store? To store more than one pattern wji=âˆ‘ypâˆˆ{yp}yipyjp w_{j i}=\\sum_{\\mathbf{y}_{p} \\in\\left\\{\\mathbf{y}_{p}\\right\\}} y_{i}^{p} y_{j}^{p} wjiâ€‹=ypâ€‹âˆˆ{ypâ€‹}âˆ‘â€‹yipâ€‹yjpâ€‹ {yP}\\{y_P\\}{yPâ€‹} is the set of patterns to store Super/subscript ppp represents the specific pattern Hopfield: For a network of neurons can store up to ~0.15N0.15N0.15N patterns through Hebbian learning(Provided in PPT) Orthogonal/ Non-orthogonal patterns Orthogonal patterns Patterns are local minima (stationary and stable) No other local minima exist But patterns perfectly confusable for recall Non-orthogonal patterns Patterns are local minima (stationary and stable) No other local minima exist Actual wells for patterns Patterns may be perfectly recalled! (Note K > 0.14 N) Two orthogonal 6-bit patterns Perfectly stationary and stable Several spurious â€œfake-memoryâ€ local minima.. Observations Many â€œparasiticâ€ patterns Undesired patterns that also become stable or attractors Patterns that are non-orthogonal easier to remember I.e. patterns that are closer are easier to remember than patterns that are farther!! Seems possible to store K > 0.14N patterns i.e. obtain a weight matrix W such that K > 0.14N patterns are stationary Possible to make more than 0.14N patterns at-least 1-bit stable "},"L20 Boltzmann machines 1.html":{"url":"L20 Boltzmann machines 1.html","title":"19 Boltzmann Machines 1","keywords":"","body":"Training hopfield nets Geometric approach Behavior of E(y)=yTWy\\mathbf{E}(\\mathbf{y})=\\mathbf{y}^{T} \\mathbf{W y}E(y)=yTWy with W=YYTâˆ’NpI\\mathbf{W}=\\mathbf{Y} \\mathbf{Y}^{T}-N_{p} \\mathbf{I}W=YYTâˆ’Npâ€‹I is identical to behavior with W=YYTW=YY^TW=YYT Energy landscape only differs by an additive constant Gradients and location of minima remain same (Have the same eigen vectors) Sine : yT(YYTâˆ’NpI)y=yTYYTyâˆ’NNp\\mathbf{y}^{T}\\left(\\mathbf{Y} \\mathbf{Y}^{T}-N_{p} \\mathbf{I}\\right) \\mathbf{y}=\\mathbf{y}^{T} \\mathbf{Y} \\mathbf{Y}^{T} \\mathbf{y}-N N_{p}yT(YYTâˆ’Npâ€‹I)y=yTYYTyâˆ’NNpâ€‹ We use yTYYTy\\mathbf{y}^{T} \\mathbf{Y} \\mathbf{Y}^{T} \\mathbf{y}yTYYTy for analyze A pattern ypy_pypâ€‹ is stored if: signâ¡(Wyp)=y_p\\operatorname{sign}\\left(\\mathbf{W} \\mathbf{y}_{p}\\right)=\\mathbf{y}\\_{p}sign(Wypâ€‹)=y_p for all target patterns Training: Design WWW such that this holds Simple solution: ypy_pypâ€‹ is an Eigenvector of WWW Storing k orthogonal patterns Let Y=[y_1y_2â€¦y_K]\\mathbf{Y}=\\left[\\mathbf{y}\\_{1} \\mathbf{y}\\_{2} \\ldots \\mathbf{y}\\_{K}\\right]Y=[y_1y_2â€¦y_K] W=YÎ›YT\\mathbf{W}=\\mathbf{Y} \\Lambda \\mathbf{Y}^{T}W=YÎ›YT Î»1,...,Î»k\\lambda_1,...,\\lambda_kÎ»1â€‹,...,Î»kâ€‹ are positive for Î»1=Î»2=Î»k=1\\lambda_1= \\lambda_2=\\lambda_k= 1Î»1â€‹=Î»2â€‹=Î»kâ€‹=1 this is exactly the Hebbian rule Any pattern yyy can be written as y=a1y1+a2y2+â‹¯+aNyN\\mathbf{y}=a_{1} \\mathbf{y}_{1}+a_{2} \\mathbf{y}_{2}+\\cdots+a_{N} \\mathbf{y}_{N}y=a1â€‹y1â€‹+a2â€‹y2â€‹+â‹¯+aNâ€‹yNâ€‹ Wy=a1Wy1+a2Wy2+â‹¯+aNWyN=y\\mathbf{W y}=a_{1} \\mathbf{W y}_{1}+a_{2} \\mathbf{W y}_{2}+\\cdots+a_{N} \\mathbf{W y}_{N} = yWy=a1â€‹Wy1â€‹+a2â€‹Wy2â€‹+â‹¯+aNâ€‹WyNâ€‹=y All patterns are stable Remembers everything Completely useless network Even if we store fewer than NNN patterns Let Y=[y_1y_2â€¦y_Kr_K+1r_K+2â€¦r_N]Y=\\left[\\mathbf{y}\\_{1} \\mathbf{y}\\_{2} \\ldots \\mathbf{y}\\_{K} \\mathbf{r}\\_{K+1} \\mathbf{r}\\_{K+2} \\ldots \\mathbf{r}\\_{N}\\right]Y=[y_1y_2â€¦y_Kr_K+1r_K+2â€¦r_N] W=YÎ›YTW=Y \\Lambda Y^{T}W=YÎ›YT r_K+1r_K+2â€¦r_N\\mathbf{r}\\_{K+1} \\mathbf{r}\\_{K+2} \\ldots \\mathbf{r}\\_{N}r_K+1r_K+2â€¦r_N are orthogonal to y1y2â€¦yK\\mathbf{y}_1 \\mathbf{y}_2 \\ldots \\mathbf{y}_Ky1â€‹y2â€‹â€¦yKâ€‹ Î»1=Î»2=Î»k=1\\lambda_1= \\lambda_2=\\lambda_k= 1Î»1â€‹=Î»2â€‹=Î»kâ€‹=1 Problem arise because eigen values are all 1.0 Ensures stationarity of vectors in the subspace All stored patterns are equally important General (nonorthogonal) vectors wji=âˆ‘pâˆˆ{p}yipyjpw_{j i}=\\sum_{p \\in\\{p\\}} y_{i}^{p} y_{j}^{p}wjiâ€‹=âˆ‘pâˆˆ{p}â€‹yipâ€‹yjpâ€‹ The maximum number of stationary patterns is actually exponential in NNN (McElice and Posner, 84â€™) For a specific set of KKK patterns, we can always build a network for which all KKK patterns are stable provided kâ‰¤Nk \\le Nkâ‰¤N But this may come with many â€œparasiticâ€ memories Optimization Energy function E=âˆ’12yTWyâˆ’bTyE=-\\frac{1}{2} \\mathbf{y}^{T} \\mathbf{W} \\mathbf{y}-\\mathbf{b}^{T} \\mathbf{y}E=âˆ’21â€‹yTWyâˆ’bTy This must be maximally low for target patterns Must be maximally high for all other patterns So that they are unstable and evolve into one of the target patterns Estimate WWW such that EEE is minimized for y1,...,yPy_1,...,y_Py1â€‹,...,yPâ€‹ EEE is maximized for all other yyy Minimize total energy of target patterns E(y)=âˆ’12yTWyW^=argminâ¡Wâˆ‘yâˆˆYPE(y)E(\\mathbf{y})=-\\frac{1}{2} \\mathbf{y}^{T} \\mathbf{W y} \\quad \\widehat{\\mathbf{W}}=\\underset{\\mathbf{W}}{\\operatorname{argmin}} \\sum_{\\mathbf{y} \\in \\mathbf{Y}_{P}} E(\\mathbf{y})E(y)=âˆ’21â€‹yTWyW=Wargminâ€‹âˆ‘yâˆˆYPâ€‹â€‹E(y) However, might also pull all the neighborhood states down Maximize the total energy of all non-target patterns E(y)=âˆ’12yTWyE(\\mathbf{y})=-\\frac{1}{2} \\mathbf{y}^{T} \\mathbf{W} \\mathbf{y}E(y)=âˆ’21â€‹yTWy W^=argminâ¡Wâˆ‘yâˆˆYPE(y)âˆ’âˆ‘yâˆ‰YPE(y)\\widehat{\\mathbf{W}}=\\underset{\\mathbf{W}}{\\operatorname{argmin}} \\sum_{\\mathbf{y} \\in \\mathbf{Y}_{P}} E(\\mathbf{y})-\\sum_{\\mathbf{y} \\notin \\mathbf{Y}_{P}} E(\\mathbf{y})W=Wargminâ€‹âˆ‘yâˆˆYPâ€‹â€‹E(y)âˆ’âˆ‘yâˆ‰YPâ€‹â€‹E(y) Simple gradient descent W=w+Î·(âˆ‘yâˆˆYPyyTâˆ’âˆ‘yâˆ‰YPyyT)\\mathbf{W}=\\mathbf{w}+\\eta\\left(\\sum_{\\mathbf{y} \\in \\mathbf{Y}_{P}} \\mathbf{y} \\mathbf{y}^{T}-\\sum_{\\mathbf{y} \\notin \\mathbf{Y}_{P}} \\mathbf{y} \\mathbf{y}^{T}\\right)W=w+Î·(âˆ‘yâˆˆYPâ€‹â€‹yyTâˆ’âˆ‘yâˆ‰YPâ€‹â€‹yyT) minimize the energy at target patterns raise all non-target patterns Do we need to raise everything? Raise negative class Focus on raising the valleys If you raise every valley, eventually theyâ€™ll all move up above the target patterns, and many will even vanish How do you identify the valleys for the current WWW? Initialize the network randomly and let it evolve It will settle in a valley Should we randomly sample valleys? Are all valleys equally important? Major requirement: memories must be stable They must be broad valleys Solution: initialize the network at valid memories and let it evolve It will settle in a valley If this is not the target pattern, raise it What if thereâ€™s another target pattern downvalley no need to raise the entire surface, or even every valley Raise the neighborhood of each target memory Storing more than N patterns Visible neurons The neurons that store the actual patterns of interest Hidden neurons The neurons that only serve to increase the capacity but whose actual values are not important The maximum number of patterns the net can store is bounded by the width NNN of the patterns.. So lets pad the patterns with KKK â€œdonâ€™t careâ€ bits The new width of the patterns is N+KN+KN+K Now we can store N+KN+KN+K patterns! Taking advantage of donâ€™t care bits Simple random setting of donâ€™t care bits, and using the usual training and recall strategies for Hopfield nets should work However, to exploit it properly, it helps to view the Hopfield net differently: as a probabilistic machine A probabilistic interpretation For binary y the energy of a pattern is the analog of the negative log likelihood of a Boltzmann distribution Minimizing energy maximizes log likelihood E(y)=âˆ’12yTWyP(y)=Cexpâ¡(âˆ’E(y))E(\\mathbf{y})=-\\frac{1}{2} \\mathbf{y}^{T} \\mathbf{W y} \\quad P(\\mathbf{y})=\\operatorname{Cexp}(-E(\\mathbf{y}))E(y)=âˆ’21â€‹yTWyP(y)=Cexp(âˆ’E(y)) Boltzmann Distribution E(y)=âˆ’12yTWyâˆ’bTyE(\\mathbf{y})=-\\frac{1}{2} \\mathbf{y}^{T} \\mathbf{W} \\mathbf{y}-\\mathbf{b}^{T} \\mathbf{y}E(y)=âˆ’21â€‹yTWyâˆ’bTy P(y)=Cexpâ¡(âˆ’E(y)kT)P(\\mathbf{y})=\\operatorname{Cexp}\\left(\\frac{-E(\\mathbf{y})}{k T}\\right)P(y)=Cexp(kTâˆ’E(y)â€‹) C=1âˆ‘yexpâ¡(âˆ’E(y)kT)C=\\frac{1}{\\sum_{\\mathrm{y}} \\exp \\left(\\frac{-E(\\mathbf{y})}{k T}\\right)}C=âˆ‘yâ€‹exp(kTâˆ’E(y)â€‹)1â€‹ kkk is the Boltzmann constant, TTT is the temperature of the system Optimizing WWW E(y)=âˆ’12yTWyW^=argminâ¡Wâˆ‘yâˆˆYPE(y)âˆ’âˆ‘yâˆ‰YPE(y)E(\\mathbf{y})=-\\frac{1}{2} \\mathbf{y}^{T} \\mathbf{W} \\mathbf{y} \\quad \\widehat{\\mathbf{W}}=\\underset{\\mathbf{W}}{\\operatorname{argmin}} \\sum_{\\mathbf{y} \\in \\mathbf{Y}_{P}} E(\\mathbf{y})-\\sum_{\\mathbf{y} \\notin \\mathbf{Y}_{P}} E(\\mathbf{y})E(y)=âˆ’21â€‹yTWyW=Wargminâ€‹âˆ‘yâˆˆYPâ€‹â€‹E(y)âˆ’âˆ‘yâˆ‰YPâ€‹â€‹E(y) Simple gradient descent W=W+Î·(âˆ‘yâˆˆYPÎ±yyyTâˆ’âˆ‘yâˆ‰YPÎ²(E(y))yyT)\\mathbf{W}=\\mathbf{W}+\\eta\\left(\\sum_{\\mathbf{y} \\in \\mathbf{Y}_{P}} \\alpha_{\\mathbf{y}} \\mathbf{y} \\mathbf{y}^{T}-\\sum_{\\mathbf{y} \\notin \\mathbf{Y}_{P}} \\beta(E(\\mathbf{y})) \\mathbf{y} \\mathbf{y}^{T}\\right)W=W+Î·(âˆ‘yâˆˆYPâ€‹â€‹Î±yâ€‹yyTâˆ’âˆ‘yâˆ‰YPâ€‹â€‹Î²(E(y))yyT) Î±y\\alpha_yÎ±yâ€‹ more importance to more frequently presented memories Î²(E(y))\\beta (E(y))Î²(E(y)) more importance to more attractive spurious memories Looks like an expectation W=W+Î·(Eyâˆ¼YPyyTâˆ’Eyâˆ¼YyyT)\\mathbf{W}=\\mathbf{W}+\\eta\\left(E_{\\mathbf{y} \\sim \\mathbf{Y}_{P}} \\mathbf{y} \\mathbf{y}^{T}-E_{\\mathbf{y} \\sim Y} \\mathbf{y} \\mathbf{y}^{T}\\right)W=W+Î·(Eyâˆ¼YPâ€‹â€‹yyTâˆ’Eyâˆ¼Yâ€‹yyT) The behavior of the Hopfield net is analogous to annealed dynamics of a spin glass characterized by a Boltzmann distribution "},"L21 Boltzmann machines 2.html":{"url":"L21 Boltzmann machines 2.html","title":"20 Boltzmann Machines 2","keywords":"","body":" This lecture redefined a regular Hopfield net as a **stochastic** system: Boltzmann machines. And talked about the training, sampling issues of Boltzmann machines model, introduced *Restricted* Boltzmann Machines, which is a common used model in practice. The Hopfield net as a distribution The Helmholtz Free Energy of a System At any time, the probability of finding the system in state sss at temperature TTT is PT(s)P_T(s)PTâ€‹(s) At each state it has a potential energy EsE_sEsâ€‹ The internal energy of the system, representing its capacity to do work, is the average UT=âˆ‘SPT(s)ES U_{T}=\\sum_{S} P_{T}(s) E_{S} UTâ€‹=Sâˆ‘â€‹PTâ€‹(s)ESâ€‹ The capacity to do work is counteracted by the internal disorder of the system, i.e. its entropy HT=âˆ’âˆ‘SPT(s)logâ¡PT(s) H_{T}=-\\sum_{S} P_{T}(s) \\log P_{T}(s) HTâ€‹=âˆ’Sâˆ‘â€‹PTâ€‹(s)logPTâ€‹(s) The Helmholtz free energy of the system measures the useful work derivable from it and combines the two terms FT=UT+kTHT F_{T}=U_{T}+k T H_{T} FTâ€‹=UTâ€‹+kTHTâ€‹ =âˆ‘SPT(s)ESâˆ’kTâˆ‘SPT(s)logâ¡PT(s) =\\sum_{S} P_{T}(s) E_{S}-k T \\sum_{S} P_{T}(s) \\log P_{T}(s) =Sâˆ‘â€‹PTâ€‹(s)ESâ€‹âˆ’kTSâˆ‘â€‹PTâ€‹(s)logPTâ€‹(s) The probability distribution of the states at steady state is known as the Boltzmann distribution Minimizing this w.r.t PT(s)P_T(s)PTâ€‹(s), we get PT(s)=1Zexpâ¡(âˆ’ESkT) P_{T}(s)=\\frac{1}{Z} \\exp \\left(\\frac{-E_{S}}{k T}\\right) PTâ€‹(s)=Z1â€‹exp(kTâˆ’ESâ€‹â€‹) ZZZ is a normalizing constant Hopfield net as a distribution E(S)=âˆ’âˆ‘ijwijsisjâˆ’bisiE(S)=-\\sum_{iE(S)=âˆ’âˆ‘ijâ€‹wijâ€‹siâ€‹sjâ€‹âˆ’biâ€‹siâ€‹ P(S)=expâ¡(âˆ’E(S))âˆ‘Sâ€²expâ¡(âˆ’E(Sâ€²))P(S)=\\frac{\\exp (-E(S))}{\\sum_{S^{\\prime}} \\exp \\left(-E\\left(S^{\\prime}\\right)\\right)}P(S)=âˆ‘Sâ€²â€‹exp(âˆ’E(Sâ€²))exp(âˆ’E(S))â€‹ The stochastic Hopfield network models a probability distribution over states It is a generative model: generates states according to P(S)P(S)P(S) The field at a single node Let's take one node as example Let SSS and Sâ€²S^\\primeSâ€² be the states with the +1 and -1 states P(S)=P(si=1âˆ£sjâ‰ i)P(sjâ‰ i)P(S)=P\\left(s_{i}=1 \\mid s_{j \\neq i}\\right) P\\left(s_{j \\neq i}\\right)P(S)=P(siâ€‹=1âˆ£sjâ‰ iâ€‹)P(sjâ‰ iâ€‹) P(Sâ€²)=P(si=âˆ’1âˆ£sjâ‰ i)P(sjâ‰ i)P\\left(S^{\\prime}\\right)=P\\left(s_{i}=-1 \\mid s_{j \\neq i}\\right) P\\left(s_{j \\neq i}\\right)P(Sâ€²)=P(siâ€‹=âˆ’1âˆ£sjâ‰ iâ€‹)P(sjâ‰ iâ€‹) logâ¡P(S)âˆ’logâ¡P(Sâ€²)=logâ¡P(si=1âˆ£sjâ‰ i)âˆ’logâ¡P(si=âˆ’1âˆ£sjâ‰ i)\\log P(S)-\\log P\\left(S^{\\prime}\\right)=\\log P\\left(s_{i}=1 \\mid s_{j \\neq i}\\right)-\\log P\\left(s_{i}=-1 \\mid s_{j \\neq i}\\right)logP(S)âˆ’logP(Sâ€²)=logP(siâ€‹=1âˆ£sjâ‰ iâ€‹)âˆ’logP(siâ€‹=âˆ’1âˆ£sjâ‰ iâ€‹) logâ¡P(S)âˆ’logâ¡P(Sâ€²)=logâ¡P(si=1âˆ£sjâ‰ i)1âˆ’P(si=1âˆ£sjâ‰ i)\\log P(S)-\\log P\\left(S^{\\prime}\\right)=\\log \\frac{P\\left(s_{i}=1 \\mid s_{j \\neq i}\\right)}{1-P\\left(s_{i}=1 \\mid s_{j \\neq i}\\right)}logP(S)âˆ’logP(Sâ€²)=log1âˆ’P(siâ€‹=1âˆ£sjâ‰ iâ€‹)P(siâ€‹=1âˆ£sjâ‰ iâ€‹)â€‹ logâ¡P(S)=âˆ’E(S)+C\\log P(S)=-E(S)+ClogP(S)=âˆ’E(S)+C E(S)=âˆ’12(EnotÂ i+âˆ‘jâ‰ iwijsj+bi)E(S)=-\\frac{1}{2}\\left(E_{\\text {not } i}+\\sum_{j \\neq i} w_{i j} s_{j}+b_{i}\\right)E(S)=âˆ’21â€‹(EnotÂ iâ€‹+âˆ‘jâ‰ iâ€‹wijâ€‹sjâ€‹+biâ€‹) E(Sâ€²)=âˆ’12(EnotÂ iâˆ’âˆ‘jâ‰ iwijsjâˆ’bi)E\\left(S^{\\prime}\\right)=-\\frac{1}{2}\\left(E_{\\text {not } i}-\\sum_{j \\neq i} w_{i j} s_{j}-b_{i}\\right)E(Sâ€²)=âˆ’21â€‹(EnotÂ iâ€‹âˆ’âˆ‘jâ‰ iâ€‹wijâ€‹sjâ€‹âˆ’biâ€‹) logâ¡P(S)âˆ’logâ¡P(Sâ€²)=E(Sâ€²)âˆ’E(S)=âˆ‘jâ‰ iwijSj+bi\\log P(S)-\\log P\\left(S^{\\prime}\\right)=E\\left(S^{\\prime}\\right)-E(S)=\\sum_{j \\neq i} w_{i j} S_{j}+b_{i}logP(S)âˆ’logP(Sâ€²)=E(Sâ€²)âˆ’E(S)=âˆ‘jâ‰ iâ€‹wijâ€‹Sjâ€‹+biâ€‹ logâ¡(P(si=1âˆ£sjâ‰ i)1âˆ’P(si=1âˆ£sjâ‰ i))=âˆ‘jâ‰ iwijsj+bi\\log \\left(\\frac{P\\left(s_{i}=1 \\mid s_{j \\neq i}\\right)}{1-P\\left(s_{i}=1 \\mid s_{j \\neq i}\\right)}\\right)=\\sum_{j \\neq i} w_{i j} s_{j}+b_{i}log(1âˆ’P(siâ€‹=1âˆ£sjâ‰ iâ€‹)P(siâ€‹=1âˆ£sjâ‰ iâ€‹)â€‹)=âˆ‘jâ‰ iâ€‹wijâ€‹sjâ€‹+biâ€‹ P(si=1âˆ£sjâ‰ i)=11+eâˆ’(âˆ‘jâ‰ iwijsj+bi)P\\left(s_{i}=1 \\mid s_{j \\neq i}\\right)=\\frac{1}{1+e^{-\\left(\\sum_{j \\neq i} w_{i j} s_{j}+b_{i}\\right)}}P(siâ€‹=1âˆ£sjâ‰ iâ€‹)=1+eâˆ’(âˆ‘jâ‰ iâ€‹wijâ€‹sjâ€‹+biâ€‹)1â€‹ The probability of any node taking value 1 given other node values is a logistic Redefining the network Redefine a regular Hopfield net as a stochastic system Each neuron is now a stochastic unit with a binary state sis_isiâ€‹, which can take value 0 or 1 with a probability that depends on the local field zi=âˆ‘jwijsj+biz_{i}=\\sum_{j} w_{i j} s_{j}+b_{i}ziâ€‹=âˆ‘jâ€‹wijâ€‹sjâ€‹+biâ€‹ P(si=1âˆ£sjâ‰ i)=11+eâˆ’ziP\\left(s_{i}=1 \\mid s_{j \\neq i}\\right)=\\frac{1}{1+e^{-z_{i}}}P(siâ€‹=1âˆ£sjâ‰ iâ€‹)=1+eâˆ’ziâ€‹1â€‹ Note The Hopfield net is a probability distribution over binary sequences (Boltzmann distribution) The conditional distribution of individual bits in the sequence is a logistic The evolution of the Hopfield net can be made stochastic Instead of deterministically responding to the sign of the local field, each neuron responds probabilistically Recall patterns The Boltzmann Machine The entire model can be viewed as a generative model Has a probability of producing any binary vector yyy E(y)=âˆ’12yTWyE(\\mathbf{y})=-\\frac{1}{2} \\mathbf{y}^{T} \\mathbf{W} \\mathbf{y}E(y)=âˆ’21â€‹yTWy P(y)=Cexpâ¡(âˆ’E(y)T)P(\\mathbf{y})=\\operatorname{Cexp}\\left(-\\frac{E(\\mathbf{y})}{T}\\right)P(y)=Cexp(âˆ’TE(y)â€‹) Training a Hopfield net: Must learn weights to â€œrememberâ€ target states and â€œdislikeâ€ other states Must learn weights to assign a desired probability distribution to states Just maximize likelihood Maximum Likelihood Training logâ¡(P(S))=(âˆ‘ijwijsisj)âˆ’logâ¡(âˆ‘Sâ€²expâ¡(âˆ‘ijwijsiâ€²sjâ€²))\\log (P(S))=\\left(\\sum_{ilog(P(S))=(âˆ‘ijâ€‹wijâ€‹siâ€‹sjâ€‹)âˆ’log(âˆ‘Sâ€²â€‹exp(âˆ‘ijâ€‹wijâ€‹siâ€²â€‹sjâ€²â€‹)) L=1Nâˆ‘SâˆˆSlogâ¡(P(S))=1Nâˆ‘S(âˆ‘ijwijsisj)âˆ’logâ¡(âˆ‘Sâ€²expâ¡(âˆ‘ijwijsiâ€²sjâ€²))\\mathcal{L}=\\frac{1}{N} \\sum_{S \\in \\mathbf{S}} \\log (P(S)) =\\frac{1}{N} \\sum_{S}\\left(\\sum_{iL=N1â€‹âˆ‘SâˆˆSâ€‹log(P(S))=N1â€‹âˆ‘Sâ€‹(âˆ‘ijâ€‹wijâ€‹siâ€‹sjâ€‹)âˆ’log(âˆ‘Sâ€²â€‹exp(âˆ‘ijâ€‹wijâ€‹siâ€²â€‹sjâ€²â€‹)) Second term derivation dlogâ¡(âˆ‘Sâ€²expâ¡(âˆ‘ijwijsiâ€²sjâ€²))dwij=âˆ‘Sâ€²expâ¡(âˆ‘ijwijsiâ€²sjâ€²)âˆ‘Sâ€²expâ¡(âˆ‘ijwijsiâ€²â€²sjâ€²)siâ€²sjâ€²\\frac{d \\log \\left(\\sum_{S^{\\prime}} \\exp \\left(\\sum_{idwijâ€‹dlog(âˆ‘Sâ€²â€‹exp(âˆ‘ijâ€‹wijâ€‹siâ€²â€‹sjâ€²â€‹))â€‹=âˆ‘Sâ€²â€‹âˆ‘Sâ€²â€‹exp(âˆ‘ijâ€‹wijâ€‹siâ€²â€²â€‹sjâ€²â€‹)exp(âˆ‘ijâ€‹wijâ€‹siâ€²â€‹sjâ€²â€‹)â€‹siâ€²â€‹sjâ€²â€‹ dlogâ¡(âˆ‘Sâ€²expâ¡(âˆ‘ijwijsiâ€²sjâ€²))dwij=âˆ‘Sâ€²P(Sâ€²)siâ€²sjâ€²\\frac{d \\log \\left(\\sum_{S^{\\prime}} \\exp \\left(\\sum_{idwijâ€‹dlog(âˆ‘Sâ€²â€‹exp(âˆ‘ijâ€‹wijâ€‹siâ€²â€‹sjâ€²â€‹))â€‹=âˆ‘Sâ€²â€‹â€‹P(Sâ€²)siâ€²â€‹sjâ€²â€‹ The second term is simply the expected value of siSjs_iS_jsiâ€‹Sjâ€‹, over all possible values of the state We cannot compute it exhaustively, but we can compute it by sampling! Overall gradient ascent rule wij=wij+Î·dâŸ¨logâ¡(P(S))âŸ©dwijw_{i j}=w_{i j}+\\eta \\frac{d\\langle\\log (P(\\mathbf{S}))\\rangle}{d w_{i j}}wijâ€‹=wijâ€‹+Î·dwijâ€‹dâŸ¨log(P(S))âŸ©â€‹ Overall Training Initialize weights Let the network run to obtain simulated state samples Compute gradient and update weights Iterate Note the similarity to the update rule for the Hopfield network The only difference is how we got the samples Adding Capacity Visible neurons The neurons that store the actual patterns of interest Hidden neurons The neurons that only serve to increase the capacity but whose actual values are not important We could have multiple hidden patterns coupled with any visible pattern These would be multiple stored patterns that all give the same visible output We are interested in the marginal probabilities over visible bits S=(V,H)S=(V,H)S=(V,H) P(S)=expâ¡(âˆ’E(S))âˆ‘Sâ€²expâ¡(âˆ’E(Sâ€²))P(S)=\\frac{\\exp (-E(S))}{\\sum_{S^{\\prime}} \\exp \\left(-E\\left(S^{\\prime}\\right)\\right)}P(S)=âˆ‘Sâ€²â€‹exp(âˆ’E(Sâ€²))exp(âˆ’E(S))â€‹ P(S)=P(V,H)P(S) = P(V,H)P(S)=P(V,H) P(V)=âˆ‘HP(S)P(V)=\\sum_{H} P(S)P(V)=âˆ‘Hâ€‹P(S) Train to maximize probability of desired patterns of visible bits E(S)=âˆ’âˆ‘ijwijsisjE(S)=-\\sum_{iE(S)=âˆ’âˆ‘ijâ€‹wijâ€‹siâ€‹sjâ€‹ P(S)=expâ¡(âˆ‘ijwijsisj)âˆ‘Sâ€²expâ¡(âˆ‘ijwijsiâ€²sjâ€²)P(S)=\\frac{\\exp \\left(\\sum_{iP(S)=âˆ‘Sâ€²â€‹exp(âˆ‘ijâ€‹wijâ€‹siâ€²â€‹sjâ€²â€‹)exp(âˆ‘ijâ€‹wijâ€‹siâ€‹sjâ€‹)â€‹ P(V)=âˆ‘Hexpâ¡(âˆ‘ijwijsisj)âˆ‘Sâ€²expâ¡(âˆ‘ijwijsiâ€²sjâ€²)P(V)=\\sum_{H} \\frac{\\exp \\left(\\sum_{iP(V)=âˆ‘Hâ€‹âˆ‘Sâ€²â€‹exp(âˆ‘ijâ€‹wijâ€‹siâ€²â€‹sjâ€²â€‹)exp(âˆ‘ijâ€‹wijâ€‹siâ€‹sjâ€‹)â€‹ Maximum Likelihood Training logâ¡(P(V))=logâ¡(âˆ‘Hexpâ¡(âˆ‘ijwijsisj))âˆ’logâ¡(âˆ‘Sâ€²expâ¡(âˆ‘ijwijsiâ€²sjâ€²))\\log (P(V))=\\log \\left(\\sum_{H} \\exp \\left(\\sum_{ilog(P(V))=log(Hâˆ‘â€‹exp(ijâˆ‘â€‹wijâ€‹siâ€‹sjâ€‹))âˆ’log(Sâ€²â€‹âˆ‘â€‹exp(ijâˆ‘â€‹wijâ€‹siâ€²â€‹sjâ€²â€‹)) L=1Nâˆ‘VâˆˆVlogâ¡(P(V))\\mathcal{L}=\\frac{1}{N} \\sum_{V \\in \\mathbf{V}} \\log (P(V))L=N1â€‹VâˆˆVâˆ‘â€‹log(P(V)) dLdwij=1Nâˆ‘VâˆˆVâˆ‘HP(Sâˆ£V)sisjâˆ’âˆ‘S!P(Sâ€²)siâ€²sjâ€² \\frac{d \\mathcal{L}}{d w_{i j}}=\\frac{1}{N} \\sum_{V \\in \\mathbf{V}} \\sum_{H} P(S \\mid V) s_{i} s_{j}-\\sum_{S !} P\\left(S^{\\prime}\\right) s_{i}^{\\prime} s_{j}^{\\prime} dwijâ€‹dLâ€‹=N1â€‹VâˆˆVâˆ‘â€‹Hâˆ‘â€‹P(Sâˆ£V)siâ€‹sjâ€‹âˆ’S!âˆ‘â€‹P(Sâ€²)siâ€²â€‹sjâ€²â€‹ âˆ‘HP(Sâˆ£V)sisjâ‰ˆ1Kâˆ‘HâˆˆHsimulsiSj\\sum_{H} P(S \\mid V) s_{i} s_{j} \\approx \\frac{1}{K} \\sum_{H \\in \\mathbf{H}_{s i m u l}} s_{i} S_{j}âˆ‘Hâ€‹P(Sâˆ£V)siâ€‹sjâ€‹â‰ˆK1â€‹âˆ‘HâˆˆHsimulâ€‹â€‹siâ€‹Sjâ€‹ Computed as the average sampled hidden state with the visible bits fixed âˆ‘Sâ€²P(Sâ€²)siâ€²sjâ€²â‰ˆ1Mâˆ‘SiâˆˆSsimulsiâ€²Sjâ€²\\sum_{S^{\\prime}} P\\left(S^{\\prime}\\right) s_{i}^{\\prime} s_{j}^{\\prime} \\approx \\frac{1}{M} \\sum_{S_{i} \\in \\mathbf{S}_{s i m u l}} s_{i}^{\\prime} S_{j}^{\\prime}âˆ‘Sâ€²â€‹P(Sâ€²)siâ€²â€‹sjâ€²â€‹â‰ˆM1â€‹âˆ‘Siâ€‹âˆˆSsimulâ€‹â€‹siâ€²â€‹Sjâ€²â€‹ Computed as the average of sampled states when the network is running â€œfreelyâ€ Training Step1 For each training pattern ViV_iViâ€‹ Fix the visible units to ViV_iViâ€‹ Let the hidden neurons evolve from a random initial point to generate HiH_iHiâ€‹ Generate Si=[Vi,Hi]S_i = [V_i,H_i]Siâ€‹=[Viâ€‹,Hiâ€‹] Repeat K times to generate synthetic training S={S1,1,S1,2,â€¦,S1K,S2,1,â€¦,SN,K} \\mathbf{S}=\\{S_{1,1}, S_{1,2}, \\ldots, S_{1 K}, S_{2,1}, \\ldots, S_{N, K}\\} S={S1,1â€‹,S1,2â€‹,â€¦,S1Kâ€‹,S2,1â€‹,â€¦,SN,Kâ€‹} Step2 Now unclamp the visible units and let the entire network evolve several times to generate Ssimul=S_simul,1,S_simul,2,â€¦,S_simul,M \\mathbf{S}_{simul}=S\\_{simul, 1}, S\\_{simul, 2}, \\ldots, S\\_{simul, M} Ssimulâ€‹=S_simul,1,S_simul,2,â€¦,S_simul,M Gradients dâŸ¨logâ¡(P(S))âŸ©dwij=1NKâˆ‘Ssisjâˆ’1Mâˆ‘SiâˆˆSsimulÂ siâ€²sjâ€² \\frac{d\\langle\\log (P(\\mathbf{S}))\\rangle}{d w_{i j}}=\\frac{1}{N K} \\sum_{\\boldsymbol{S}} s_{i} s_{j}-\\frac{1}{M} \\sum_{S_{i} \\in \\mathbf{S}_{\\text {simul }}} s_{i}^{\\prime} s_{j}^{\\prime} dwijâ€‹dâŸ¨log(P(S))âŸ©â€‹=NK1â€‹Sâˆ‘â€‹siâ€‹sjâ€‹âˆ’M1â€‹Siâ€‹âˆˆSsimulÂ â€‹âˆ‘â€‹siâ€²â€‹sjâ€²â€‹ wij=wijâˆ’Î·dâŸ¨logâ¡(P(S))âŸ©dwij w_{i j}=w_{i j}-\\eta \\frac{d\\langle\\log (P(\\mathbf{S}))\\rangle}{d w_{i j}} wijâ€‹=wijâ€‹âˆ’Î·dwijâ€‹dâŸ¨log(P(S))âŸ©â€‹ Gradients are computed as before, except that the first term is now computed over the expanded training data Issues Training takes for ever Doesnâ€™t really work for large problems A small number of training instances over a small number of bits Restricted Boltzmann Machines Partition visible and hidden units Visible units ONLY talk to hidden units Hidden units ONLY talk to visible units Training Step1 For each sample Anchor visible units Sample from hidden units No looping!! Step2 Now unclamp the visible units and let the entire network evolve several times to generate Ssimul=S_simul,1,S_simul,2,â€¦,S_simul,M \\mathbf{S}_{simul}=S\\_{simul, 1}, S\\_{simul, 2}, \\ldots, S\\_{simul, M} Ssimulâ€‹=S_simul,1,S_simul,2,â€¦,S_simul,M For each sample Initialize V0V_0V0â€‹ (visible) to training instance value Iteratively generate hidden and visible units Gradient âˆ‚logâ¡p(v)âˆ‚wij=vihj>0âˆ’vihj>âˆ \\frac{\\partial \\log p(v)}{\\partial w_{i j}}=^{0}-^{\\infty} âˆ‚wijâ€‹âˆ‚logp(v)â€‹=viâ€‹hjâ€‹>0âˆ’viâ€‹hjâ€‹>âˆ A Shortcut: Contrastive Divergence Recall: Raise the neighborhood of each target memory Sufficient to run one iteration to give a good estimate of the gradient âˆ‚logâ¡p(v)âˆ‚wij=vihj>0âˆ’vihj>1 \\frac{\\partial \\log p(v)}{\\partial w_{i j}}=^{0}-^{1} âˆ‚wijâ€‹âˆ‚logp(v)â€‹=viâ€‹hjâ€‹>0âˆ’viâ€‹hjâ€‹>1 "},"L22 EM algorithm.html":{"url":"L22 EM algorithm.html","title":"21 EM Algorithm","keywords":"","body":" This lecture introduced EM algorithm: an iterative technique to estimate probaility models for missing data. Meanwhile, mixture Gaussian, PCA and factor analysis are actually *generative* models in a way of EM. Key points EM: An iterative technique to estimate probability models for data with missing components or information By iteratively â€œcompletingâ€ the data and reestimating parameters PCA: Is actually a generative model for Gaussian data Data lie close to a linear manifold, with orthogonal noise A lienar autoencoder! Factor Analysis: Also a generative model for Gaussian data Data lie close to a linear manifold Like PCA, but without directional constraints on the noise (not necessarily orthogonal) Generative models Learning a generative model You are given some set of observed data X={x}X=\\{x\\}X={x} You choose a model P(x;Î¸)P(x ; \\theta)P(x;Î¸) for the distribution of xxx Î¸\\thetaÎ¸ are the parameters of the model Estimate the theta such that P(x;Î¸)P(x ; \\theta)P(x;Î¸) best â€œfitsâ€ the observations X={x}X=\\{x\\}X={x} How to define \"best fits\"? Maximum likelihood! Assumption: The data you have observed are very typical of the process EM algorithm Tackle missing data and information problem in model estimation Let ooo are observed data logâ¡P(o)=logâ¡âˆ‘hP(h,o)=logâ¡âˆ‘hQ(h)P(h,o)Q(h) \\log P(o)=\\log \\sum_{h} P(h, o)=\\log \\sum_{h} Q(h) \\frac{P(h, o)}{Q(h)} logP(o)=loghâˆ‘â€‹P(h,o)=loghâˆ‘â€‹Q(h)Q(h)P(h,o)â€‹ The logarithm is a concave function, therefore logâ¡âˆ‘hQ(h)P(h,o)Q(h)â‰¥âˆ‘hQ(h)logâ¡P(h,o)Q(h) \\log \\sum_{h} Q(h) \\frac{P(h, o)}{Q(h)} \\geq \\sum_{h} Q(h) \\log \\frac{P(h, o)}{Q(h)} loghâˆ‘â€‹Q(h)Q(h)P(h,o)â€‹â‰¥hâˆ‘â€‹Q(h)logQ(h)P(h,o)â€‹ Choose a tight lower bound Let Q(h)=P(hâˆ£o;Î¸â€²)Q(h)=P(h \\mid o ; \\theta^{\\prime})Q(h)=P(hâˆ£o;Î¸â€²) logâ¡P(o;Î¸)â‰¥âˆ‘hP(hâˆ£o;Î¸â€²)logâ¡P(h,o;Î¸)P(hâˆ£o;Î¸â€²) \\begin{aligned} \\log P(o ; \\theta) \\geq \\sum_{h} P\\left(h \\mid o ; \\theta^{\\prime}\\right) \\log \\frac{P(h, o ; \\theta)}{P\\left(h \\mid o ; \\theta^{\\prime}\\right)} \\end{aligned} logP(o;Î¸)â‰¥hâˆ‘â€‹P(hâˆ£o;Î¸â€²)logP(hâˆ£o;Î¸â€²)P(h,o;Î¸)â€‹â€‹ Let J(Î¸,Î¸â€²)=âˆ‘hP(hâˆ£o;Î¸â€²)logâ¡P(h,o;Î¸)P(hâˆ£o;Î¸â€²)J\\left(\\theta, \\theta^{\\prime}\\right)=\\sum_{h} P\\left(h \\mid o ; \\theta^{\\prime}\\right) \\log \\frac{P(h, o ; \\theta)}{P\\left(h \\mid o ; \\theta^{\\prime}\\right)}J(Î¸,Î¸â€²)=âˆ‘hâ€‹P(hâˆ£o;Î¸â€²)logP(hâˆ£o;Î¸â€²)P(h,o;Î¸)â€‹ logâ¡P(o;Î¸)â‰¥J(Î¸,Î¸â€²) \\begin{array}{l} \\log P(o ; \\theta) \\geq J\\left(\\theta, \\theta^{\\prime}\\right) \\end{array} logP(o;Î¸)â‰¥J(Î¸,Î¸â€²)â€‹ The algorithm process EM for missing data â€œExpandâ€ every incomplete vector out into all possibilities With proportion P(mâˆ£o)P(m|o)P(mâˆ£o) (from previous estimate of the model) Estimate the statistics from the expanded data EM for missing information Problem : We are not given the actual Gaussian for each observation What we want: (o1,k1),(o2,k2),(o3,k3)â€¦\\left(o_{1}, k_{1}\\right),\\left(o_{2}, k_{2}\\right),\\left(o_{3}, k_{3}\\right) \\ldots(o1â€‹,k1â€‹),(o2â€‹,k2â€‹),(o3â€‹,k3â€‹)â€¦ What we have: o1,o2,o3â€¦o_{1}, o_{2}, o_{3} \\ldotso1â€‹,o2â€‹,o3â€‹â€¦ The algorithm process General EM principle â€œCompleteâ€ the data by considering every possible value for missing data/variables Reestimate parameters from the â€œcompletedâ€ data Principal Component Analysis Find the principal subspace such that when all vectors are approximated as lying on that subspace, the approximation error is minimal Closed form Total projection error for all data L=âˆ‘xxTxâˆ’wTxxTw L=\\sum_{x} x^{T} x-w^{T} x x^{T} w L=xâˆ‘â€‹xTxâˆ’wTxxTw Minimizing this w.r.t ğ‘¤ (subject to ğ‘¤ = unit vector) gives you the Eigenvalue equation (âˆ‘xxTx)w=Î»w \\left(\\sum_{x} x^{T} x\\right) w=\\lambda w (xâˆ‘â€‹xTx)w=Î»w This can be solved to find the principal subspace However, it is not feasible for large matrix (need to find eigenvalue) Iterative solution Objective: Find a vector (subspace) www and a position zzz on www such that zwâ‰ˆxzw\\approx xzwâ‰ˆx most closely (in an L2 sense) for the entire (training) data The algorithm process PCA & linear autoencoder We put data XXX into the inital subpace, got ZZZ The fix ZZZ to get a better subpace WWW, etc... This is an autoencoder with linear activations ! Backprop actually works by simultaneously updating (implicitly) and in tiny increments PCA is actually a generative model The observed data are Gaussian Gaussian data lying very close to a principal subspace Comprising â€œcleanâ€ Gaussian data on the subspace plus orthogonal noise "},"L23 Variational Autoencoders.html":{"url":"L23 Variational Autoencoders.html","title":"22 Variational Autoencoders","keywords":"","body":" Non-linear extensions of linear Gaussian models. EM for PCA With complete information If we knew zzz for each xxx, estimating AAA and DDD would be simple x=Az+E x=A z+E x=Az+E P(xâˆ£z)=N(Az,D) P(x \\mid z)=N(A z, D) P(xâˆ£z)=N(Az,D) Given complete information (x1,z1),(x2,z2)\\left(x_{1}, z_{1}\\right),\\left(x_{2}, z_{2}\\right)(x1â€‹,z1â€‹),(x2â€‹,z2â€‹) argmaxâ¡A,Dâˆ‘(x,z)logâ¡P(x,z)=argmaxâ¡A,Dâˆ‘(x,z)logâ¡P(xâˆ£z) \\underset{A, D}{\\operatorname{argmax}} \\sum_{(x, z)} \\log P(x, z)=\\underset{A, D}{\\operatorname{argmax}} \\sum_{(x, z)} \\log P(x \\mid z) A,Dargmaxâ€‹(x,z)âˆ‘â€‹logP(x,z)=A,Dargmaxâ€‹(x,z)âˆ‘â€‹logP(xâˆ£z) =argmaxâ¡A,Dâˆ‘(x,Z)logâ¡1(2Ï€)dâˆ£Dâˆ£expâ¡(âˆ’0.5(xâˆ’Az)TDâˆ’1(xâˆ’Az)) =\\underset{A, D}{\\operatorname{argmax}} \\sum_{(x, Z)} \\log \\frac{1}{\\sqrt{(2 \\pi)^{d}|D|}} \\exp \\left(-0.5(x-A z)^{T} D^{-1}(x-A z)\\right) =A,Dargmaxâ€‹(x,Z)âˆ‘â€‹log(2Ï€)dâˆ£Dâˆ£â€‹1â€‹exp(âˆ’0.5(xâˆ’Az)TDâˆ’1(xâˆ’Az)) We can get a close form solution: A=XZ+A = XZ^{+}A=XZ+ But we don't have ZZZ => missing With incomplete information Initialize the plane Complete the data by computing the appropriate zzz for the plane P(zâˆ£X;A)P(z|X;A)P(zâˆ£X;A) is a delta, because EEE is orthogonal to AAA Reestimate the plane using the zzz Iterate Linear Gaussian Model PCA assumes the noise is always orthogonal to the data Not always true The noise added to the output of the encoder can lie in any direction (uncorrelated) We want a generative model: to generate any point Take a Gaussian step on the hyperplane Add full-rank Gaussian uncorrelated noise that is independent of the position on the hyperplane Uncorrelated: diagonal covariance matrix Direction of noise is unconstrained With complete information x=Az+e x=A z+e x=Az+e P(xâˆ£z)=N(Az,D) P(x \\mid z)=N(A z, D) P(xâˆ£z)=N(Az,D) Given complete information X=[x1,x2,â€¦],Z=[z1,z2,â€¦]X=\\left[x_{1}, x_{2}, \\ldots\\right], Z=\\left[z_{1}, z_{2}, \\ldots\\right]X=[x1â€‹,x2â€‹,â€¦],Z=[z1â€‹,z2â€‹,â€¦] argmaxâ¡A,Dâˆ‘(x,z)logâ¡P(x,z)=argmaxâ¡A,Dâˆ‘(x,z)logâ¡P(xâˆ£z) \\underset{A, D}{\\operatorname{argmax}} \\sum_{(x, z)} \\log P(x, z)=\\underset{A, D}{\\operatorname{argmax}} \\sum_{(x, z)} \\log P(x \\mid z) A,Dargmaxâ€‹(x,z)âˆ‘â€‹logP(x,z)=A,Dargmaxâ€‹(x,z)âˆ‘â€‹logP(xâˆ£z) =argmaxâ¡A,Dâˆ‘(x,z)logâ¡1(2Ï€)dâˆ£Dâˆ£expâ¡(âˆ’0.5(xâˆ’Az)TDâˆ’1(xâˆ’Az)) =\\underset{A, D}{\\operatorname{argmax}} \\sum_{(x, z)} \\log \\frac{1}{\\sqrt{(2 \\pi)^{d}|D|}} \\exp \\left(-0.5(x-A z)^{T} D^{-1}(x-A z)\\right) =A,Dargmaxâ€‹(x,z)âˆ‘â€‹log(2Ï€)dâˆ£Dâˆ£â€‹1â€‹exp(âˆ’0.5(xâˆ’Az)TDâˆ’1(xâˆ’Az)) =argmaxâ¡A,Dâˆ‘(x,z)âˆ’12logâ¡âˆ£Dâˆ£âˆ’0.5(xâˆ’Az)TDâˆ’1(xâˆ’Az) =\\underset{A, D}{\\operatorname{argmax}} \\sum_{(x, z)}-\\frac{1}{2} \\log |D|-0.5(x-A z)^{T} D^{-1}(x-A z) =A,Dargmaxâ€‹(x,z)âˆ‘â€‹âˆ’21â€‹logâˆ£Dâˆ£âˆ’0.5(xâˆ’Az)TDâˆ’1(xâˆ’Az) We can also get closed form solution With incomplete information Option 1 In every possible way proportional to P(zâˆ£x)P(z|x)P(zâˆ£x) (Gaussian) Compute the solution from the completed data argmaxâ¡A,Dâˆ‘xâˆ«âˆ’âˆâˆp(zâˆ£x)(âˆ’12logâ¡âˆ£Dâˆ£âˆ’0.5(xâˆ’Az)TDâˆ’1(xâˆ’Az))dz \\underset{A, D}{\\operatorname{argmax}} \\sum_{x} \\int_{-\\infty}^{\\infty} p(z \\mid x)\\left(-\\frac{1}{2} \\log |D|-0.5(x-A z)^{T} D^{-1}(x-A z)\\right) d z A,Dargmaxâ€‹xâˆ‘â€‹âˆ«âˆ’âˆâˆâ€‹p(zâˆ£x)(âˆ’21â€‹logâˆ£Dâˆ£âˆ’0.5(xâˆ’Az)TDâˆ’1(xâˆ’Az))dz The same as before Option 2 By drawing samples from P(zâˆ£x)P(z|x)P(zâˆ£x) Compute the solution from the completed data The intuition behind Linear Gaussian Model zâˆ¼N(0,I)z \\sim N(0, I)zâˆ¼N(0,I) => AzAzAz The linear transform stretches and rotates the K-dimensional input space onto a Kdimensional hyperplane in the data space X=Az+EX = Az +EX=Az+E Add Gaussian noise to produce points that arenâ€™t necessarily on the plane The posterior probability P(zâˆ£x)P(z|x)P(zâˆ£x) gives you the location of all the points on the plane that could have generated xxx and their probabilities What about data that are not Gaussian distributed close to a plane? Linear Gaussian Models fail How to do that Non-linear Gaussian Model f(z)f(z)f(z) is a non-linear function that produces a curved manifold Like the decoder of a non-linear AE Generating process Draw a sample zzz from a Uniform Gaussian Transform zzz by f(z)f(z)f(z) This places zzz on the curved manifold Add uncorrelated Gaussian noise to get the final observation Key requirement Identifying the dimensionality KKK of the curved manifold Having a function that can transform the (linear) KKK-dimensional input space (space of zzz ) to the desired KKK-dimensional manifold in the data space With complete data x=f(z;Î¸)+e x=f(z ; \\theta)+e x=f(z;Î¸)+e P(xâˆ£z)=N(f(z;Î¸),D) P(x \\mid z)=N(f(z ; \\theta), D) P(xâˆ£z)=N(f(z;Î¸),D) Given complete information X=[x1,x2,â€¦],Z=[z1,z2,â€¦]X=\\left[x_{1}, x_{2}, \\ldots\\right], \\quad Z=\\left[z_{1}, z_{2}, \\ldots\\right]X=[x1â€‹,x2â€‹,â€¦],Z=[z1â€‹,z2â€‹,â€¦] Î¸â‹†,Dâ‹†=argmaxâ¡Î¸,Dâˆ‘(x,z)logâ¡P(x,z)=argmaxâ¡Î¸,Dâˆ‘(x,z)logâ¡P(xâˆ£z) \\theta^{\\star}, D^{\\star}=\\underset{\\theta, D}{\\operatorname{argmax}} \\sum_{(x, z)} \\log P(x, z)=\\underset{\\theta, D}{\\operatorname{argmax}} \\sum_{(x, z)} \\log P(x \\mid z) Î¸â‹†,Dâ‹†=Î¸,Dargmaxâ€‹(x,z)âˆ‘â€‹logP(x,z)=Î¸,Dargmaxâ€‹(x,z)âˆ‘â€‹logP(xâˆ£z) =argmaxâ¡Î¸,Dâˆ‘(x,Z)logâ¡1(2Ï€)dâˆ£Dâˆ£expâ¡(âˆ’0.5(xâˆ’f(z;Î¸))TDâˆ’1(xâˆ’f(z;Î¸))) =\\underset{\\theta, D}{\\operatorname{argmax}} \\sum_{(x, Z)} \\log \\frac{1}{\\sqrt{(2 \\pi)^{d}|D|}} \\exp \\left(-0.5(x-f(z ; \\theta))^{T} D^{-1}(x-f(z ; \\theta))\\right) =Î¸,Dargmaxâ€‹(x,Z)âˆ‘â€‹log(2Ï€)dâˆ£Dâˆ£â€‹1â€‹exp(âˆ’0.5(xâˆ’f(z;Î¸))TDâˆ’1(xâˆ’f(z;Î¸))) =argmaxâ¡Î¸,Dâˆ‘(x,Z)âˆ’12logâ¡âˆ£Dâˆ£âˆ’0.5(xâˆ’f(z;Î¸))TDâˆ’1(xâˆ’f(z;Î¸)) =\\underset{\\theta, D}{\\operatorname{argmax}} \\sum_{(x, Z)}-\\frac{1}{2} \\log |D|-0.5(x-f(z ; \\theta))^{T} D^{-1}(x-f(z ; \\theta)) =Î¸,Dargmaxâ€‹(x,Z)âˆ‘â€‹âˆ’21â€‹logâˆ£Dâˆ£âˆ’0.5(xâˆ’f(z;Î¸))TDâˆ’1(xâˆ’f(z;Î¸)) There isnâ€™t a nice closed form solution, but we could learn the parameters using backpropagation Incomplete data The posterior probability is given by P(zâˆ£x)=P(xâˆ£z)P(z)P(x) P(z \\mid x)=\\frac{P(x \\mid z) P(z)}{P(x)} P(zâˆ£x)=P(x)P(xâˆ£z)P(z)â€‹ The denominator P(x)=âˆ«âˆ’âˆâˆN(x;f(z;Î¸),D)N(z;0,D)dz P(x)=\\int_{-\\infty}^{\\infty} N(x ; f(z ; \\theta), D) N(z ; 0, D) d z P(x)=âˆ«âˆ’âˆâˆâ€‹N(x;f(z;Î¸),D)N(z;0,D)dz Can not have a closed form solution Try to approximate it We approximate P(zâˆ£x)P(z|x)P(zâˆ£x) as P(zâˆ£x)â‰ˆQ(z,x)=Gaussianâ¡N(z;Î¼(x),Î£(x)) P(z \\mid x) \\approx Q(z, x)=\\operatorname{Gaussian} N(z ; \\mu(x), \\Sigma(x)) P(zâˆ£x)â‰ˆQ(z,x)=GaussianN(z;Î¼(x),Î£(x)) Sample zzz from N(z;Î¼(x;Ï•),Ïƒ(x;Ï•))N(z;\\mu (x;\\phi),\\sigma (x;\\phi))N(z;Î¼(x;Ï•),Ïƒ(x;Ï•)) for each training instance Draw KKK-dimensional vector Îµ\\varepsilonÎµ from N(0,I)N(0,I)N(0,I) Compute z=Î¼(x;Ï†)+Î£(x;Ï†)0.5Îµz=\\mu(x ; \\varphi)+\\Sigma(x ; \\varphi)^{0.5} \\varepsilonz=Î¼(x;Ï†)+Î£(x;Ï†)0.5Îµ Reestimate Î¸\\thetaÎ¸ from the entire â€œcompleteâ€ data Using backpropagation L(Î¸,D)=âˆ‘(x,z)logâ¡âˆ£Dâˆ£+(xâˆ’f(z;Î¸))TDâˆ’1(xâˆ’f(z;Î¸)) L(\\theta, D)=\\sum_{(x, z)} \\log |D|+(x-f(z ; \\theta))^{T} D^{-1}(x-f(z ; \\theta)) L(Î¸,D)=(x,z)âˆ‘â€‹logâˆ£Dâˆ£+(xâˆ’f(z;Î¸))TDâˆ’1(xâˆ’f(z;Î¸)) Î¸â‹†,Dâ‹†=argminâ¡Î¸,DL(Î¸,D) \\theta^{\\star}, D^{\\star}=\\underset{\\theta, D}{\\operatorname{argmin}} L(\\theta, D) Î¸â‹†,Dâ‹†=Î¸,Dargminâ€‹L(Î¸,D) Estimate Ï†\\varphiÏ† using the entire â€œcompleteâ€ data Recall Q(z,x)=N(z;Î¼(x;Ï†),Î£(x;Ï†))Q(z, x)=N(z ; \\mu(x ; \\varphi), \\Sigma(x ; \\varphi))Q(z,x)=N(z;Î¼(x;Ï†),Î£(x;Ï†)) must approximate P(zâˆ£x)P(z|x)P(zâˆ£x) as closely as possible Define a divergence between Q(z,x)Q(z,x)Q(z,x) and P(zâˆ£x)P(z|x)P(zâˆ£x) Variational AutoEncoder Non-linear extensions of linear Gaussian models f(z;Î¸)f(z;\\theta)f(z;Î¸) is generally modelled by a neural network Î¼(x;Ï†)\\mu(x ; \\varphi)Î¼(x;Ï†) and Î£(x;Ï†)\\Sigma(x ; \\varphi)Î£(x;Ï†) are generally modelled by a common network with two outputs However, VAE can not be used to compute the likelihoood of data P(x;Î¸)P(x;\\theta)P(x;Î¸) is intractable Latent space The latent space zzz often captures underlying structure in the data xxx in a smooth manner Varying zzz continuously in different directions can result in plausible variations in the drawn output "}}