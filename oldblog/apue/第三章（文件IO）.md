+++
title = "APUE阅读笔记 第三章 文件IO"
slug = "apue chapter 3"
tags = ["UNIX", "APUE"]
date = "2018-04-08T15:16:25+08:00"
description = "本章讨论UNIX的文件I/O函数--打开文件、读文件、写文件等，都是属于不带缓存的I/O(unbuffered I/O)。"

+++




# 文件描述符

对于内核而言，所有打开文件都由**文件描述符引用**。

文件描述符是一个非负整数，当打开一个现存文件或者创建一个新文件时，内核向进程返回一个文件描述符。

按照惯例，UNIX shell 使文件描述符0与进程的标准输入相结合，文件描述符1与标准输出相结合，文件描述符2与标准出错输出相结合。

在<unistd.h>中，幻数0，1，2被换成符号常数**STDIN_FILENO/STDOUT_FILENO/STDERR_FILENO**。

# open函数

```C
int open(const char *pathname, int oflag,.... , mode_t);
```



1. pathname 是要打开或者创建文件的名字

2. ofag 参数可用来说明函数的选择项

   - O_RDNOLY   只读打开

   - O_WRONLY  只写打开

   - O_RDWR   读写打开

     **以上操作只能指定一个**，下列操作是可以选择的：

     - O_APPEND	每次写时都加到文件的尾端
     - O_CREAT     当文件不存在时创建它
     - O_TRUNC    如果文件存在，而且为只读或只写成功打开，将其长度截断为0

3. 由open 返回的文件描述符一定是最小的未用过的文件描述符数字。

# creat函数

```C
int creat(const char *pathname, mode_t mode);
```



此函数等价与`open(pathname, O_WRONLY| O_CREAT | O_TRUNC,mode)`

# close函数

可用close函数关闭一个打开的文件：

```C
int close (int filedes);
```



# lseek函数

每个打开文件都有一个与其相关联的“当前文件位移量”，是一个非负整数，用以度量从文件开始处计算的字节数。

读写操作都是从当前文件位移量处开始，并使位移量增加所读或写的字节数。系统默认打开文件时位移量为0。

``` C
off_t lseek(int filedes, off_t offset, int whence);
```



若whence时SEEK_SET，则将该文件的位移量设置为距文件开始处offset个字节。

若whence时SEEK_CUR，则将该文件的位移量设置为当前值加offset个，可正可负。

若whence时SEEK_END，则将该文件的位移量设置为文件长度加offset，可正可负。

**若lseek成功执行，则返回新的文件位移量，若文件描述符引用的是一个管道或FIFO，则sleek返回-1，并将errno设置为EPIPE**。

**通常，文件的位移量应该是一个非负整数，但某些设备也许也可能允许负的位移量。因此，在比较lseek的返回值时，应该测试是否等于-1来表示是否可以设置位移量。**

lseek仅将当前的文件位移量记录在内核，不引起任何I/O操作，然后用该位移量读写。

**文件位移量可以大于当前文件的长度，这种情况下，对文件的下一次写将延长该文件，使得文件中没有写过的字节都被读为0。**

# read函数

```C
ssize_t read(int filedes, void *buff, size_t nbytes);
```



若read成功，则返回读到的字节数，若已经到末尾，返回0，失败返回-1。

有多种情况可能使得实际得到的字节数小于要求的字节数：

1. 读普通文件，在读到要求字节数之前已经达到了文件末端。
2. 从终端设备读，通常一次最多读一行。
3. 从网络读，网络的缓存机构可能造成这种情况。



# write函数

``` C
ssize_t write(int filedes, const void *, size_t nbytes);
```



其返回值通常与参数nbytes的值相同，否则表示出错。

注意，这里的文件一定要是已经打开的，并从当前位移处开始写。

# 文件共享

1. **每个进程在进程表中都有一个记录项，每个记录项中有一张打开文件描述符表，**可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：

    - 文件描述符标志。

    - 指向一个文件表项的指针。

2. **内核为所有打开文件维持一张文件表。**每个文件表项包含：
   - 文件状态标志(读、写、增写、同步、非阻塞等)。
   - 当前文件位移量。
   - 指向该文件v节点表项的指针。

3. **每个打开文件（或设备）都有一个v节点结构。**v节点包含了文件类型和对此文件进
   行各种操作的函数的指针信息。对于大多数文件， v节点还包含了该文件的i节点（索引节点）。这些信息是在打开文件时从盘上读入内存的，所以所有关于文件的信息都是快速可供使用的。

   ![fd1](/images/apue/fd1.png)

   如果两个独立进程各自打开了同一文件，则有图中所示的安排。我们假定第一个进程使该文件在文件描述符3上打开，而另一个进程则使此文件在文件描述符4上打开。**打开此文件的每个进程都得到一个文件表项，但对一个给定的文件只有一个v节点表项。这种安排使每个进程都有它自己的对该文件的当前位移量。**

   ![fd2](/images/apue/fd2.png)


   **注意，文件描述符标志和文件状态标志在作用范围方面的区别，前者只用于一个进程的一个描述符，而后者则适用于指向该给定文件表项的任何进程中的所有描述符。**


# 原子操作

当多个进程写同一文件时，则可能产生预期不到的结果（例如lseek和write是分开的函数调用）。为了说明如何避免这种情况，需要理解原子操作的概念。

例如如上所述，打开文件和新建文件时一个原子操作。如果在打开和创建之间，另一个进程创建了该文件，那么就会发生问题。如果在这两个函数调用之间，另一个进程创建了该文件，而且又向该文件写进了一些数据，那么执行这段程序中的creat时，刚写上去的数据就会被擦去。将这两者合并在一个原子操作中，此种问题也就不会产生。

**一般而言，原子操作（atomic operation）指的是由多步组成的操作。如果该操作原子地执行，则或者执行完所有步，或者一步也不执行，不可能只执行所有步的一个子集。**

# dup和dup2函数

```C
int dup(int filedes);

int dup2(int filedes, int filedes2);
```



由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。用dup2则可以用filedes2参数指定新描述符的数值。如果filedes2已经打开，则先将其关闭。如若filedes等于filedes2，则dup返回filedes2，而不关闭它。

这些函数返回的新文件描述符与参数filedes共享同一个文件表项。

# fcntl函数

``` C
int fcntl(int filesed, int cmd,... , int arg);
```



fcntl函数有五种功能：
-  复制一个现存的描述符（cmd＝FDUPFD）。
-  获得/设置文件描述符标记（cmd = FGETFD或FSETFD）。
-  获得/设置文件状态标志（cmd = FGETFL或FSETFL）。
-  获得/设置异步I / O有权（cmd = FGETOWN或FSETOWN）。
-  获得/设置记录锁（cmd = GETLK , FSETLK或FSETLKW）。

**fcntl则允许当仅知道打开文件的描述符时可以修改其性质。这一点在使用shell打开文件，对pipe进行操作时很有用。**

# ioctl函数

```C
#include <unistd.h> 
#include <sys/ioctl.h> 
#include<termios.h>

int ioctl(int filedes, int request,...);

```



ioctl 函数是I/O操作的杂物箱。不能用本章中其他函数表示的I/O操作通常都能用ioctl表示。终端I/O是ioctl 的最大使用方面。

磁带操作使我们可以在磁带上写一个文件结束标志，反绕磁带，越过指定个数的文件或记录等等，用本章中的其他函数(read、write、lseek等)都难于表示这些操作，所以，用i octl是对这些设备进行操作的最容易的方法。



# /dev/fd

比较新的系统都提供名为/dev/fd的目录，其目录项是名为0、1、2等的文件。打开文件/dev/fd/n等效于复制描述符n (假定描述符n是打开的)。

在函数中调用：

```C
fd = open("/dev/fd/0", mode);
```



等效于：

```C
fd = dup(0);
```



/dev/fd文件主要由shell使用，这允许程序以对待其他路径名一样的方式使用路径名参数来
处理标准输入和标准输出。例如， cat (1)程序将命令行中的一个单独的`-`特别解释为一个输入文件名，该文件指的是标准输入。例如：

```C
filter file2 | cat file1 - file3 | lpr
```



首先cat读file1，接着读其标准输入(也就是filter file2命令的输出)，然后读file3，如若支持
/dev/fd，则可以删除cat对-的特殊处理，于是我们就可键入下列命令行：

```C
filter file2 | cat file1 /dev/fd/0 file3 | lpr
```



在命令行中用-作为一个参数特指标准输入或标准输出已由很多程序采用。但是这会带来一些问题，例如若用`-`指定第一个文件，那么它看来就像开始了另一个命令行的选择项。/dev/fd则提高了文件名参数的一致性，也更加清晰。



# 小结

本章说明了传统的UNIX I/O函数。但对于ioctl和fcntl函数还很陌生，需要多加应用。

本章的重点除了各种I/O操作外，还有文件描述符的应用，这是管道实现的基础。

还了解了shell关于`-`的操作，表示标准输入，也可使用`/dev/fd/0 `代替。