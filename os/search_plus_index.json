{"./":{"url":"./","title":"Introduction","keywords":"","body":"操作系统笔记 此 GitBook 记录了我学操作系统的时候记录的一些知识要点，以及实现大作业的时候的思路。 如有错误，烦请指出，不胜感谢。 This GitBook notes are maintained by zealscott. 参考资料 Operating System:Design and Implementation,Third Edition Computer Systems: A Programmer's Perspective, 3/E http://wiki.minix3.org/doku.php @Last updated at 1/22/2021 "},"notes/":{"url":"notes/","title":"Notes","keywords":"","body":""},"notes/io hardware.html":{"url":"notes/io hardware.html","title":"I/O 硬件原理","keywords":"","body":" 操作系统的主要功能之一是控制所有的输入输出，必须向设备发出指令，捕获中断并进行错误处理，还要提供一个设备与系统其余部分简单的接口。 I/O设备 I/O设备在速度上覆盖了巨大的范围，这给数据传输的性能保持上造成了巨大压力。 按交互对象分类 人机交互设备：视频显示设备、键盘、鼠标、打印机 与计算机或其他电子设备交互的设备：磁盘、磁带、传感器、控制器 计算机间的通信设备：网卡、调制解调器 按交互方向分类 输入（可读）：键盘、扫描仪 输出（可写）：显示设备、打印机 输入/输出（可读写）：磁盘、网卡 按外设特性分类 使用特征：存储、输入/输出、终端 数据传输率：低速(如键盘)、中速(如打印机)、高速(如网卡、磁盘) 信息组织特征：单个字符或数据块 字符设备(如打印机、管道) 无法编址，也不存在寻址操作 块设备(如磁盘) 能够独立的读写单个数据块 设备控制器 I/O设备通常包含一个机械部件和一个电子部件。为了达到设计的模块性和通用性，一般将其分开。电子部分称为设备控制器（device controller）或适配器（adapter）。 操作系统主要和控制器打交道，而不是设备本身。 任务 控制器负责将驱动器读出来的比特流转换成字节块并在需要时进行纠错。 比特流 实际从驱动器读出来的是一串比特流，以一个前导符（preamble）开始，随后是一个扇区4096比特，最后是一个效验和，也称为纠错码（Error-Correcting Code）。 通常该字节块是在控制器中的一个缓冲区中逐个比特汇集而成。在对检查和进行校验证实数据正确之后，该块数据随后被拷贝到主存中。 I/O控制技术 CPU有多种方式控制I/O，其主要的区别在于CPU参与的程度。 内存映射I/O I/O操作由程序发起，并等待操作完成。数据的每次读写通过CPU。 那么，控制器如何与CPU进行通讯呢？ 每个控制器都有一些用来与CPU通信的寄存器及数据缓冲区。 通过写入寄存器，操作系统可以命令设备发送数据、接收数据、开启或关闭、或其它操作。 通常设备有一个数据缓冲区，以供操作系统读写数据。 那么，CPU如何与控制寄存器和设备的数据缓冲区进行通讯呢？ 每个控制寄存器分配一个I/O port 设备寄存器独立编址 I/O寄存器是内存地址空间的一部分 -- 内存映射I/O 设备缓冲区按内存地址空间进行统一编址 如图所示： 示例 当CPU想要读一个字时，无论是从内存中读还是I/O port中读，都将需要的地址放入总线的地址线上，然后在总线的一条控制线上设置读信号。然后用第二条信号线来表明是I/O空间还是内存空间。 读请求 -> CPU(请求地址) -> 总线 -> 内存空间、I/O空间 中断 CPU检测I/O操作是否可以开始或完成： 检测设备控制寄存器中的状态标志位（忙等待） 使用中断方式通知CPU 中断驱动方式 I/O操作由程序发起，在操作完成时（如数据可读或已经写入）由外设向CPU发出中断，通知该程序。数据的每次读写通过CPU。 当一个启动的中断操作完成时，将中断CPU并开始运行中断处理器。然后将通知操作系统I/O已经完成，操作系统检查状态标志位以确定一切正常，并获取结果。 缺点 CPU每次处理的数据量少（通常不超过几个字节），只适于数据传输率较低的设备。 任何读写操作都需要CPU来复制到内存，过多浪费CPU资源。 直接存储器存取 由程序设置DMA(Direct Memory Access )控制器中的若干寄存器值（如内存始址，传送字节数），然后发起I/O操作，而后者完成内存与外设的成批数据交换，在操作完成时由DMA控制器向CPU发出中断。 在使用DMA中，CPU只需要对DMA编程，然后由DMA来指导控制器将数据从缓存区读到主存。 优点 CPU只需干预I/O操作的开始和结束，而其中的一批数据读写无需CPU控制，适于高速设备。 通道控制方式 通道控制器(Channel Processor)有自己的专用存储器，可以执行由通道指令组成的通道程序，因此可以进行较为复杂的I/O控制。 通道程序通常由操作系统所构造，放在内存里。 优点 类似于协处理器 执行一个通道程序可以完成几批I/O操作 参考资料 Operating System:Design and Implementation,Third Edition "},"notes/io software.html":{"url":"notes/io software.html","title":"I/O 软件原理","keywords":"","body":" 从软件系统的层次介绍I/O的实现过程 I/O软件目标 设备无关性 程序员写出的软件无需修改便能读出软盘、硬盘以及CD-ROM等不同设备上的文件 统一的命名 一个文件或设备名将简单地只是一个字符串或一个整数，而完全不依赖于设备。 在UNIX和MINIX 3中，所有的磁盘可以以任何方式集成到文件系统层次结构中去，用户也不必知道哪个各字对应着哪个设备。 容错功能 错误应在尽可能接近硬件的地方处理，低层软件可以自行处理错误，尽可能向上层软件透明 协同同步与异步传输 多数物理I/O是异步传输，用户接口是阻塞的，需要使之协同 设备共享 某些设备可同时被多个用户使用，另一些设备则在某一时刻只能供一个用户专用 I/O软件系统的层次结构 分为中断处理器、设备驱动程序、设备无关I/O软件、用户空间I/O软件四个层次结构。 中断处理器 中断需要尽量加以屏蔽，需将其放在操作系统的底层进行处理，以便其余部分尽可能少地与之发生联系。 这里的中断是由硬件产生，一般在I/O完成后会发生。 屏蔽中断的最好方法是将将启动I/O的驱动程序阻塞，直至I/O操作结束并发生中断，解除阻塞。 在Minix中，驱动程序为单独的一个进程，因此可以使用这个模型。 设备驱动程序 设备驱动程序中包括了所有与设备相关的代码。每个设备驱动程序只处理一种设备，或者一类紧密相关的设备。 功能 设备驱动程序的功能是从与设备无关I/O软件中接收抽象的请求，并负责执行该请求。 实现 将设备驱动程序放在系统内核中，可以获得良好的性能，但会影响系统的可靠性--很多安全漏洞都是这样产生，因为I/O驱动程序有着很高的权限 MINIX3将其作为用户模式的进程，以提高其可靠性 工作流程 将I/O请求转换为更具体的形式 驱动程序将向控制器的设备寄存器中写入这些命令 这些控制命令发出后，存在两种情况 驱动程序需等待控制器完成一些操作，所以驱动程序阻塞，直到中断信号到达才解除阻塞（主要）。 另一种情况是操作没有任何延迟，所以驱动程序无需阻塞 设备无关I/O软件 是执行适用于所有设备的常用I/O功能，并向用户层软件提供一个一致的接口。 在标准接口情况下，可以方便地加入新的驱动程序。 功能 设备驱动程序的统一接口 设备无关I/O软件负责将设备名映射到相应的驱动程序 通过设备名确定一个i-节点，这个节点包含主设备号，通过主设备号可以找到相应的设备驱动程序 i-节点也包括次设备号，作为参数传给驱动程序，用来指定要读或写的具体单元。 检查用户是否有权使用设备 缓冲 对于块设备，硬件每次读写均以块为单元，而用户程序则可以读写任意大小的单元。如果用户进程写半个块，操作系统将在内部保留这些数据，直到其余数据到齐后才一次性地将这些数据写到盘上。 对字符设备，用户向系统写数据的速度可能比向设备输出的速度快，所以需要进行缓冲。超前的键盘输入同样也需要缓冲。 错误报告 错误处理多数由驱动程序完成，多数错误是与设备紧密相关的，因此只有驱动程序知道应如何处理（如重试、忽略、严重错误）。 分配和释放专用设备 一些设备，如CD-ROM记录器，在同一时刻只能由一个进程使用。 这要求操作系统检查对该设备的使用请求，并根据设备的忙闲状况来决定是接受或拒绝此请求。 提供与设备无关的块大小 不同磁盘的扇区大小可能不同，设备无关软件屏蔽了这一事实并向高层软件提供统一的数据块大小。 用户空间I/O软件 I/O相关的库例程 假脱机系统(spooling) 创建一个特殊的daemon进程，解决多个进程使用打印机的资源管理问题 outline 参考资料 Operating System:Design and Implementation,Third Edition "},"notes/pcb.html":{"url":"notes/pcb.html","title":"进程模型与实现","keywords":"","body":"进程 进程就是正在执行的程序。包括程序计数器（PC），寄存器，变量的当前值等。从数据结构上来说，包括代码段（Text），数据段（Data，存储静态变量和全局变量）和堆栈段。 在逻辑上，每个进程都运行在自己的虚拟CPU上，因为我们在编写代码时，并没有考虑进程间的切换，而就认为我们的代码会连续执行，这是计算机中一种重要的抽象。 而在实际物理上，多个进程是通过切换共享物理CPU（为了简单，这里只考虑单CPU情形）。CPU根据时间片（time slides）和某种调度算法来考虑是否该切换进程，但由于在计算机中，时间片一般很短（10ms左右），人类总是感觉计算机是多个程序同时执行，因此才有了多进程的概念。 上下文切换 那么，CPU是如何从一个进程切换到另一个进程的呢？这里涉及到的概念是Context switch。 所谓上下文切换，就是CPU在从一个进程到另一个进程时，需要记下当前进程的状态，然后再运行新的进程，这样，下次就可以直接从之前中断的地方重新运行。这是一种很自然的解决方法。 注意：the time it takes is dependent on hardware support, and the time is overhead; the system does no useful work while switching. 因此，科学家想了很多办法来降低上下文切换中的系统效率损失，在这里不做介绍。 模式切换 模式切换（Mode Switching）是只用户态（user mode）和内核态（kernel mode）之间的切换。因此，我们知道，如果进行了上下文切换，则一定会发生模式切换。而模式切换并不一定意味着上下文切换。请看下面的例子： 此图中，p3到p2发生的是上下文切换，而p2由于中断信号，交给kernel去处理，处理结束后又回到p2，这就是发生的模式切换。 逻辑程序计数器 每个进程有用自己的逻辑程序计数器，而CPU只有一个物理程序计数器，当进程被运行时，将该进程的逻辑计数器装入物理程序计数器中，而程序暂时中止运行时，将物理计数器中的值保存在该进程的逻辑计数器中。 进程的实现 进程控制块（PCB） process control block，是由操作系统维护的用来记录进程相关信息的一块内存。 每个进程在OS中的登记表项，OS根据此PCB来对进程进行管理。 PCB位于核心段中，通常不能由应用程序自身的代码来直接访问，需要通过系统调用或UNIX中的进程文件系统（/proc）直接访问进程映像。 PCB中主要包括以下几部分内容： 进程描述信息： process ID、进程名、user ID、process group 进程控制信息 当前状态、优先级、代码执行入口地址、程序的外存地址、进程间同步和通信 资源占用信息 虚拟地址空间的现状、打开文件列表 CPU现场保护结构 寄存器值、PC、栈指针地址等。 PCB的组织方式 链表：同一状态的进程使用一个链表。如就绪链表、阻塞链表 索引表：同一状态的进程归入一个索引表，再指向PCB table（更常用） 在微内核体系架构中（Minix），这些部分是分模快进行处理，也就是说，进程通讯、内存管理和文件管理是分别的几个数组，使用相同的下标去访问同一个进程的不同信息。 在巨内核体系架构中（Linux），所有的信息都储存在同一个数组。 "},"notes/schedule.html":{"url":"notes/schedule.html","title":"进程调度介绍","keywords":"","body":" 因为有进程间通信，就会涉及到多个进程竞争CPU，操作系统要决定哪一个进程先运行。 调度介绍 我们将进程分为计算密集型（compute-bound）和I/O密集型（I/O-bound），这是通过进程行为进行分类。 如果需要运行I/O密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求保持磁盘忙碌。 什么时候调度 一定会发生调度： 当一个进程退出时 当一个进程在I/O或信号量阻塞时 可能发生调度： 当一个新进程创建时 当一个I/O中断发生时（意味着I/O设备完成了工作，一些进程可以转变为就绪态） 当一个时钟中断发生时 分类 由于我们不知道每次作业什么时候到来，每个作业需要运行多久，因此不太可能有绝对完美的调度算法。 许多进程调度的处理方式对进程和线程都适用。这里首先讨论进程调度问题。 我们可以把调度算法分为两类：非抢占式调度以及抢占式调度。 非抢占式调度算法 这种算法挑选一个进程运行，并一直运行到阻塞（可能是I/O阻塞或等待另外一个进程）或自愿退出。 抢占式调度算法 挑选一个进程并运行，这个进程所运行的最大时间是固定的。如果到了最大时间依然在运行，进程将会被挂起，调度器将会挑选另外的进程运行。 由于操作系统可以分为批处理、交互式、实时系统三部分，在不同的系统中，调度器的优化目标是不同的，因此分开介绍。 调度算法目标 为了设计一个调度算法，应该首先明确一个好的调度算法必须做什么。 所有系统都要求 公平 给每个进程公平的CPU份额 策略强制执行 执行所规定的策略 平衡 保持系统所有的部分都忙碌 批处理系统 吞吐量 最大化每小时作业数 周转时间（turnaround time） 最小化从提交到完成的时间间隔（衡量了用户等待一个输出的平均时间），时间越短越好 CPU利用率 保持CPU始终忙碌（并不是一个好的度量参数） 交互式系统 响应时间 快速响应请求 均衡性 满足所有用户需求 实时系统 满足截止时间 避免丢失数据 可预测性 在多媒体系统中避免失真 批处理系统中的调度 先来先服务（FCFS） non-preemptive scheduler 在这个算法中，进程按照他们请求CPU的顺序使用CPU，维持一个就绪进程的单一队列。 当一个作业从外部进入系统，就马上运行并可以运行任意长时间。当其他作业到来时，就被插入队列尾端。 当运行的进程阻塞时，队列里的第一个进程调度运行，当这个阻塞的进程转为就绪时，再次插入队列尾端。 算法的优点很明显：易于实现。但缺点是在I/O密集型进程和计算密集型进程交替执行时，效率很低（convoy effect）。 最短作业优先（SJF） preemptive scheduler 这也是很容易想到的贪心算法。当一批作业同时到来时，我们先处理作业最短的。 改善平均周转时间，缩短作业的等待时间。 可以证明，当所有作业同时启动时，最短作业优先算法是最优的。这能够使得平均等待时间最短，最大化吞吐量。 但这种算法也只能在批处理系统中有用。因为在实际的其他系统中，每个作业的到达时间、执行时间都是未知的。 最短剩余时间优先（STCF） preemptive scheduler 使用这种调度算法，调度器总是挑选其剩余时间最短的那些进程运行，同样，运行时间必须预知。 当一个新作业到来时，它所需的总时间与当前运行进程的剩余时间进行比较，如果新作业需要比当前进程更少的时间完成，那么当前进程被挂起，新作业运行。 这种方式可以使得新到来的短作业得到较好的服务。 最高响应比优先（HRRN） HRRN是介于FCFS（先来先服务算法）与SJF（短作业优先算法）之间的折中算法，既考虑作业等待时间又考虑作业运行时间，既照顾短作业又不使长作业等待时间过长，改进了调度性能。 响应比 =（等待时间+预估执行时间）/ 预估执行时间 即RR=（w+s）/s=1+w/s，因此响应比一定是大于1的。 CPU每次计算所有作业的响应比，选择最高响应比再进行作业。 三级调度 准入调度器 当作业到来时，首先被放入存储在磁盘上的输入队列中。 准入调度器决定哪些作业允许进入系统，其他作业被选中之前就保存在输入队列中。 一个典型的准入控制算法是找一些计算密集型进程和I/O密集型进程缓和一起运行。 内存调度器 决定哪个进程留在内存而哪个进程换出到磁盘。在内存中保留的进程数称为多道程序的道数。 CPU调度器 实际在内存中选取下一个将要运行的进程。任何合适的抢占式和非抢占式调度算法都可以在CPU调度器中使用。 交互式系统中的调度 在交互式系统中，一般使用两级调度（内存调度和CPU调度），下面将重点介绍CPU调度器和一些常见的调度算法。 时间片轮转调度 每个进程被分配一个时间段，称为它的时间片（Quantum），即该进程允许运行的时间。 时间片轮转调度中最有趣的一点就是时间片的长度。 从一个进程切换到另一个进程需要进行上下文切换（context switch），但这个过程需要overhead，因此，如果时间片设计的过短，单位时间的上下文切换消耗过大。而时间片设置得比平均CPU突发时间长，抢占会很少发生，使得交互请求的相应变差。 注意，在交互式系统中我们注重响应时间，在这种目标下此算法很好，但在周转时间上很差。 因此，时间片过短会导致过多的进程切换，降低了CPU效率；设得过长又可能引起对短的交互请求的相应变差。通常来说时间片设置为20~50ms。 优先级调度 每个进程被赋予优先级，率先运行优先级最高的就绪进程。 我们可以设计多个优先级队列，在同类进程内部采用时间片轮转调度。 最短进程优先 由于最短作业优先在批处理系统中常常伴随产生最短平均相应时间，因此可以用于交互进程。 如何从当前的就绪进程中找出最短的那一个？一种方法是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。 可以通过将当前测量值和先前估计值进行加权平均得到下一个估计值的技术称为老化。 彩票调度算法 算法为进程发放针对系统各种资源（如CPU时间）的彩票，当调度器需要作出决策时，随机选择一张彩票，持有该彩票的进程将获得系统资源。 如果一个新进程创建并得到一些彩票，则下次抽奖时，它中奖的机会与其持有的彩票成正比。因此，彩票调度的反映非常迅速。 公平分享调度 考虑进程的拥有者是谁，对每个用户赋予不同的CPU时间。 实时系统调度 分为硬实时和软实时。 软实时允许偶尔超过时间限制，而硬实时必须满足时间限制。 按照要响应的时间进一步分为周期性和非周期性。一个系统必须响应多个周期的事件流。 例如，有mmm个周期性的事件，事件iii的周期为PiP_iPi​，其中每个事件需要CiC_iCi​秒的CPU时间来处理，则必须满足： ∑i=1mCiPi≤1\\sum\\limits_{i=1}^m\\frac {C_i}{P_i} \\le 1i=1∑m​Pi​Ci​​≤1 才可能处理所有的负载。满足该条件的实时系统是可调度的（schedulable）。 调度策略与机制 将调度问题分解为调度策略与调度机制 调度机制（scheduling mechanism） 将调度算法以某种形式参数化 调度策略（scheduling policy） 参数由用户进程依据相应的策略设置 例如，若内核使用优先级调度算法，且提供一条系统调用，则该主进程可以使用它来设置或改变其子进程的优先级。（nice命令） 线程调度 若系统中进程包含多线程，则系统中存在两个层次上的并行性：线程级和进程级。 线程的实现方式决定了线程级的调度模式 用户级线程 只需要几条指令，无须上下文切换、修改内存映射、高速缓存失效等等，时间快 用户级线程阻塞会引起整个进程的阻塞 进程内部的线程调度器决定哪个进程运行，没有时钟中断来打断运行了足够长时间的线程， 操作系统按照进程来调度 内核级线程 内核挑选线程运行，不需要考虑这个线程属于哪个进程 线程被赋予时间片，如果线程运行时间超过了这个时间片，将会被强制挂起 区别 主要区别是性能 用户级线程进行线程切换只需要几条指令，而内核级线程需要完整的上下文切换，修改内存映射，使高速缓存失效，这将比用户级线程切换慢几个数量级。 在使用内核线程时，一个线程的阻塞不会导致整个进程阻塞，而如果在用户级线程下则会导致整个进程阻塞。 例如，在忙等待引起的阻塞时，没有办法被系统检测到。（在用户级线程中线程只是一条语句或一个函数，而忙等待则无法执行这条语句） 内核知道从不同进程的线程切换需要更大开销，因此当内核考虑线程切换时，同等重要的情况下，优先考虑同进程的线程。 用户线程可作为特定应用定制的调度器。 参考资料 Operating System:Design and Implementation,Third Edition 操作系统调度算法 "},"notes/ipc.html":{"url":"notes/ipc.html","title":"经典 IPC 问题实现与思考","keywords":"","body":" 本文介绍多种同步方法来解决进程间通信问题，并给出模型的代码实现。 代码介绍 本文主要侧重于代码实现，若对互斥（mutex）以及死锁问题还不够熟悉，可以参考我这篇文章。 include - pthread_mutex_t - 用于创建互斥（mutex）变量 - pthread_mutex_lock - 用于对互斥加锁，防止其他进程（线程）进入临界区。 - pthread_create - 用于创建临界区 - pthread_t - 标识线程 ``` include - sem_t - 用于创建信号量变量 - sem_init - 信号量初始化函数 - sem_wait - 相当于Dijkstra的down操作 - sem_post - 相当于Dijkstra的up操作 哲学家进餐问题 引言 对于问题的描述不过多介绍，可参考wiki。 最naive的想法就是哲学家先取左叉子，再取右叉，最后再依次放回就行。但很遗憾这种想法会造成死锁。想象一下：若在同一时刻所有的哲学家都同时拿起左叉，那他们再也拿不到右叉，导致程序在一直运行却又无法进行下去。 因此，我们很容易想到利用互斥（mutex）进行改进。我们将哲学家进餐的一系列动作都lock起来，这样的确能避免死锁，但这样也会导致同一时间只有一个进程在进餐（资源浪费），有没有更好的方法呢？ 我们知道，若有n个哲学家，则最多n/2个哲学家同时进餐。我们可以首先利用mutex将取叉的动作lock住，同时检查周围的人是否正在进餐。这样，我们就需要一个数组来标识每个哲学家的状态。最后，我们把动作分解为take_forks,eat,think,put_forks四个状态，其中需要特别注意take_forks和put_forks。 代码 #include #include #include #include #define N 5 #define LEFT (i - 1 + N) % N #define RIGHT (i + 1) % N #define THINKING 0 #define HUNGRY 1 #define EATING 2 int state[N]; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; sem_t s[N]; void think(int i) { if (state[i] == THINKING) { printf(\"philosopher %d is thinking.......\\n\", i); sleep(3); } } void eat(int i) { if (state[i] == EATING) { printf(\"philosopher %d is eating.......\\n\", i); sleep(3); } } void init() { int i; for (i = 0; i 需要注意，我们的test函数只是测试周围的哲学家的状态，若周围哲学家已经在进餐，则不能拿起叉子，只能等待（63行），直到发送信号解除阻塞后才可以进食。 结果 读者-写者问题 引言 哲学家进餐问题对于多个竞争进程互斥的访问有限资源（如I/O设备）这一类问题的建模十分有用，在读者-写者问题中，为数据库访问建立了一个模型。 我们知道，对一个成熟的数据库来说，很重要的一点就是处理多并发请求的问题。在这里我们规定：允许多个进程同时读一个数据库，但不允许读写同时进行，也不允许同时写。 代码实现 #include #include #include #include #define N 5 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; sem_t db; /* control the access of database */ int rc; /* the process want to access the database */ void init() { rc = 0; if (sem_init(&db, 1, 1) != 0) { printf(\"sem_init is wrong\\n\"); } } void read_data(int i) { printf(\"person %d is reading.......\\n\", i); sleep(3); } void finish_read(int i) { printf(\"person %d finish reading!\\n\", i); } void write_data() { printf(\"person is writing.......\\n\"); sleep(5); } void finish_write() { printf(\"person finish writing!\\n\"); } void reader() { while (1) { pthread_mutex_lock(&mutex); rc += 1; if (rc == 1) sem_wait(&db); pthread_mutex_unlock(&mutex); read_data(rc); pthread_mutex_lock(&mutex); rc -= 1; finish_read(rc); if (rc == 0) sem_post(&db); pthread_mutex_unlock(&mutex); sleep(3); /* wait for another reading ... */ } } void writer() { while (1) { sem_wait(&db); write_data(); finish_write(); sem_post(&db); /* restore the access */ sleep(5); /* wait for another writing ... */ } } int main() { int i = 0; pthread_t id1, id2; int ret1, ret2; init(); for (i = 0; i 建模方式与以上类似，但要注意，这个模型有一定缺陷。比如，如果读者的周期小于写者的周期，那么系统将一直允许读者进入，而写者一直被挂起直到没有一个读者为止。这个时候也许就会让写者等待很久。 结果 因此，读者可以自行思考更为合理的建模方式，这种建模方式是根据实际应用需求的，如： 读者优先模式 写者优先模式 严格按照时间戳读写 参考资料 Operating System:Design and Implementation,Third Edition 多线程同步--信号量 sen_init Linux进程间通信——使用信号量 哲学家进餐问题的C语言实现 "},"notes/deadlock.html":{"url":"notes/deadlock.html","title":"死锁","keywords":"","body":"概述 计算机系统中有很多独占资源，依次只能被一个进程使用（打印机等）。 所有的操作系统都具有授权一个进程排他访问某一资源的能力，这个能力包括软件和硬件。 很多进程需要独占的访问几个资源，而这时候，多个进程可能无限制地等待其他进程将独占资源释放，也就是等待永远不会发生的条件，这种情况叫做死锁。 资源 进程对设备、文件等获得独占性的访问权时有可能会发生死锁，为了尽可能地通用化，将这种需排它使用的对象称为资源。 资源有两类： 可剥夺式资源可从拥有它的进程处剥夺而没有任何副作用，存储器是一类可剥夺资源。（例如内存） 不可剥夺资源无法在不导致相关计算失败的情况下将其从属主进程处剥夺。（打印机） 死锁原理 死锁发生的必要条件 互斥：任一时刻只允许一个进程使用资源 请求和保持：进程在请求其余资源时，不主动释放已经占用的资源 非剥夺：进程已经占用的资源，不会被强制剥夺 环路等待：环路中的每一条边是进程在请求另一进程已经占有的资源。 死锁模型 可以使用图模型来表示，其中矩形表示资源（里面的圆点表示实例），圆圈表示进程。 没有产生死锁的情况： 产生死锁： 可以总结出： 如果一个图模型没有环，则不可能有死锁 如果一个图存在环 若每一个资源只有一个实例，那么会发生死锁 若每个资源有多个实例，那么可能会发生死锁 死锁策略 鸵鸟算法 这是最简单的算法。虽然死锁出现以后很棘手，但实践表明，死锁很少发生。 因此，我们可以假装没有这个事情，如果发生了，仅仅需要重启一下就好。 虽然看起来很蠢，但这种方法被包括UNIX等大多数操作系统所使用。 死锁的检测和恢复 采用这种技术，系统只需监听资源的请求和释放。每次资源被请求或释放时，资源图被更新，同时检测是否存在环路，若存在，则撤销环中的一个进程，直到不产生环路。 另外一种更粗略的方法是周期性的检测是否有进程连续阻塞超过一定时间，若发现，则撤销该进程。 死锁的预防 按照之前提出的四个必要条件，我们只需要破除其中的一个，则死锁绝对不会发生。 破坏互斥 类似于假脱机技术，使用一个守护进程来真正请求资源。 并且，需要把守护进程设计成完整的输出文件就绪后才开始打印。 禁止已拥有资源的进程等待其他资源 规定所有进程在开始执行前请求所需要的所有资源 不现实，因为许多进程直到运行才知道它需要多少资源。 这种方案不能最优化资源的使用。 当一个进程请求资源时，先暂时释放当前的所有资源，然后再尝试一次来获得所需的所有资源。 破坏不可抢占 这是不太现实和棘手的。 消除环路 简单的保证每一个进程在任何时候只占用一个资源 这种限制是不可接受的 给所有资源提供一个全局编号 进程申请资源必须按照编号顺序 或者仅要求不允许进程请求编号比当前所有占用资源编号低的资源 避免死锁 不必对进程强加一些规则来避免死锁，而是通过对每一次资源请求认真的分析来判断是否能安全的分配。 银行家算法 基本思想 一个小城镇的银行家向一群客户分别承诺了一定的贷款额度，考虑到所有客户不会同时申请最大额度贷款，他只保留较少单位的资金来为客户服务 将客户比作进程，贷款比作设备，银行家比作操作系统 算法 对每一个请求进行检查，检查如果满足它是否会导致不安全状态。若是，则不满足该请求；否则便满足。 检查状态是否安全的方法是看他是否有足够的资源满足某一客户。 如果可以，则这笔投资认为是能够收回的，然后检查最接近最大限额的客户，如此反复下去。如果所有投资最终都被收回，则该状态是安全的，最初的请求可以批准。 其中，a、b是安全的，c是不安全的。 资源轨迹图 两阶段加锁法 死锁预防的方案过于严格，死锁避免的算法又需要无法得到的信息 实际情况采取相应的算法 例如在许多数据库系统中，常常需要将若干记录上锁然后进行更新。当有多个进程同时运行时，有可能发生死锁。常用的一种解法是两阶段加锁法。 第一阶段，进程试图将其所需的全部记录加锁，一次锁一个记录。 若成功，则开始第二阶段，完成更新数据并释放锁。 若有些记录已被上锁，则它将已上锁的记录解锁并重新开始第一阶段 总结以上策略的优缺点如下： 参考资料 Operating System:Design and Implementation,Third Edition "},"notes/minix processes.html":{"url":"notes/minix processes.html","title":"Minix3 进程概述","keywords":"","body":"概述 UNIX 的内核是一个部分模块的单块程序 MINIX 是微内核结构，是一组进程的集合，内核功能较少，进程之间以及用户进程之间使用进程级通信机制（IPC）进行通信 内部结构 注意：内核层的 system task 是系统任务，第二第三层统称为系统进程 system process 除了第一层为内核层，其他层都是user mode。 进程都潜在有一定特权，这是第二层、第三层、第四层内的进程的不同之处。 kernel call 与system call的区别 内核调用（kernel call）是由系统服务提供的以使驱动程序和服务器完成工作的低层函数。例如读硬件的I/O端口。 system call 是用POSIX规范定义的高层调用，如read、fork和unlink，这些调用供第四层的用户程序使用。 用户程序包含很多POSIX调用，但不包含内核调用。 内核层（Kernel） 多数用 C 写，汇编负责内核直接与硬件交互的最底层部分。 主要功能是为上层驱动程序和服务提供一组特权内核调用。 内核 进程调度，负责进程在就绪态、运行态、阻塞态之间转换 处理进程间的消息 支持对 I/O 端口和中断的访问，在处理器中需要使用特权内核模式（kernel mode），这些指令在用户指令中是没有的。 时钟任务 类似设备驱动程序，与产生时钟信号的硬件交互 只提供内核接口，用户不能访问 系统任务 为驱动程序和服务器提供内核调用，用户进程不可调用 包括读写 I/O 端口、跨地址空间复制数据 设备驱动程序（Device Drives） 请求系统任务代表它们读写 I/O 端口 请求系统任务将读取的数据副本到另一个地址空间 实现操作系统工作一：管理资源 服务器进程（server processes） 进程管理器（Process Manage） 执行所有涉及或者终止进程的MINIX3系统调用，例如fork，exec和wait。 还负责执行与信号有关的系统调用，例如alarm和kill。 管理内存，如发出brk系统调用。 文件系统（File System） 执行文件系统的调用，如read，mount和chdir。 实现操作系统工作二：通过实现系统调用提供一个扩展的计算机（PM & FS） 信息服务器（information server0，IS） 负责提供其他驱动程序和服务器的调试和状态信息的工作。 再生服务器（reincarnation server，RS） 启动或者重启那些不与内核一起加载到内存的设备驱动程序。 网络服务器（network server） 可以通过驱动程序来请求I/O。 用户进程（user processes） 如shell程序、编辑器、编译器和用户程序。 系统进程比用户进程拥有更高的执行优先级 Init进程 在系统引导时启动 是第一个用户进程，也是引导映像（boot image）的最后一个进程 Daemon 守护进程 周期性运行或总是等待某个事件的后台进程 总结 设备驱动层和服务器层的进程统称为系统进程，是操作系统的组成部分。 Init是第一个用户进程，PID=1 进程管理器是用户空间内运行的第一个进程，PID=0 MINIX3 中的进程管理 MINIX3 的启动 软盘 只有第一个分区可以引导（引导块，boot block），由它装入引导程序（bootstrap），引导程序很小，并装入一个更大的程序boot，由boot装入操作系统。 boot block -> bootstrap -> boot -> boot image -> Kernel -> 系统任务、时钟任务 -> init 进程 -> 其他用户进程 硬盘 可能包含很多分区，第一个扇区包含主引导记录。 主引导记录（master boot record）= 第1个扇区内的一小段程序（用于选择活动分区）+ 磁盘分区表（partition table） 程序部分被执行以读入分区表并选择活动分区，活动分区的第一个扇区有一个引导程序，被装入并执行以查找启动程序boot。 master boot record -> partition table -> active parttition -> boot block (扇区1) -> bootstrap-> boot -> boot image 在 BIOS 中设置启动盘的搜索顺序 软盘启动 硬盘启动 程序部分被执行读入分区表并选择活动分区，活动分区第一个扇区中的引导程序被装入执行并以查找并启动程序boot boot 是MINIX3的次级装入程序，不仅可以装入操作系统，而且作为一个监控程序，允许用户改变、设置和保存不同的参数。 引导映像（boot image） MINIX3 的 boot 程序将在软盘或硬盘分区上找一个包含多个部分（各种程序，如PM、FS 等）的文件，并将各部分装到内存适当的位置。 引导映像的各个部分是独立的程序，内核、FS、PM、再生服务器必须是引导映像的一部分。 在初始化阶段，内核先启动系统任务和时钟任务，再启动进程管理器和文件系统，接着是其他一些服务器和驱动程序，这些都完成之后被阻塞，然后第1个用户进程 init 才开始运行。 进程树的初始化 Init 是第1个用户进程，也是作为引导映像（boot image）的一部分加载的最后一个进程 init进程首先执行/etc/rc脚本，结合再生服务器启动其他驱动程序和服务器，启动守护进程。 其中一个使用程序为服务（service），是再生服务器的用户接口 最后启动守护进程 init不是进程树的树根，其结构也不能判断系统进程的启动顺序 进程管理器是用户空间运行的第1个进程，PID=0 再生服务器是其他所有再引导映像中启动的进程的父进程 MINIX3 中的进程间通信 原语 Send Receive Sendrec 发送一条消息，并等待同一个进程的应答 实现：内核中的消息传递机制将消息从发送者复制到接收者 同步通讯：当一个进程发送消息到目标进程而目标进程并不在等待消息时，发送进程将阻塞，直到目标进程调用 receive 为止。 当 A 向 B 发送消息时，如果 B 向 A 发送消息，会导致死锁。 每个任务、驱动程序或服务器只允许与一些特定的进程通信 Notify 不阻塞消息发送 只发送一个很简单的通知，使用置位就可以存储。 异步通讯，可以避免死锁 消息通知（notification message）的简单性在于，不能被接受的通知可以很容易的存储起来，以便当接受者调用receive时可以收到这个通知。 实现 每个系统进程都有这样一个位图，其中的每一位对应于一个系统进程，用于记录其他系统进程发给他的通知。 通过位图（bitmap）来接收，notify 只包含发送者信息和一个内核加上的时间戳 当系统进程调用receive时，通过检查自己的位图，可以知道其他系统进程是否发通知给它 MINIX3 中的进程调度 结构：多级排队系统 共 16 个队列 最低优先级位 IDLE 进程，只在没有其他任务时运行 系统和时钟任务处于最高优先级队列中 驱动程序和服务器进程通常具有一个较大的时间片，通常是运行结束被阻塞而非时间片到了被中断 只有当前一个队列中没有就绪的程序时，才会运行低优先级的进程队列 不同优先级的进程时间片长度不一 驱动程序进程和服务器进程通常需要运行至其阻塞，因此它们分配较大的时间片 优先级调度 + 改进的轮转调度算法 进程转为非就绪时，它的时间片没有用完，则表明发生I/O阻塞，则该进程将再次转为就绪，将其放在对手，分配的时间片为上次时间片中的剩余时间。 一个用完时间片的进程，以正常的时间片轮转调度方式放在队尾 优先级降低 如果一个用完了时间片的进程，仍然是上一次运行的进程，则可以认为此进程在无限循环中，阻止了其他低优先级进程的运行。 此时，将把该进程放到一个较低优先级队列的队尾以降低它的优先级。 优先级提高 如果一个进程用完了时间片，但没有妨碍其他进程运行，则它的优先级将提高，知道该进程所允许的最大优先级为止。 进程的优先级可根据实际情况调整 MINIX3的系统任务 由于MINIX中内核独立于主系统部件，因此外部进程被禁止执行实际的I/O操作，也不能改动系统表以及完成其他操作系统一般都有的功能。 解决这个问题的方法是让内核为驱动程序和服务器提供一组服务。这些对普通用户进程可用的服务，允许驱动程序和服务器执行实际的I/O操作、存取内核表以及他们所需要的功能，而不要在内核内部完成。 这些服务是由系统任务（system task）进行处理的。其工作原理为：系统任务接受来自驱动程序和服务器的对于这些服务的调用请求，因为系统任务是处于内核空间的一部分，所以可以调度并使用他们。 与系统调用的区别 在传统的单体内核操作系统中，系统调用（system call）指的是对于所有内核提供服务的调用，由POSIX标准描述对进程可用的系统调用。 而在MINIX3中，操作系统的组件是在用户空间中运行的，虽然有着作为系统进程的特权。 将用户进程发出的系统调用将被转换为发往服务器进程的消息。服务器进程之间、服务器进程与设备驱动程序之间以及服务器进程与内核之间可以通过消息进行通信 系统任务将接受对于所有内核服务的请求，称为内核调用。其关系如下： 用户进程 -> 系统调用 -> 服务进程 -> 内核调用 -> 系统任务 例如，fork系统调用要求改变进程表的内核部分，为此进程管理器将发送sys_fork调用给系统任务，而它可以操作内核空间中的数据。 系统调用接收的消息类型 一共接收28条消息，每一种消息对应于一个内核调用 进程管理类 sys_fork,sys_exec sys_nice改变进程的属性 sys_privctl改变进程特权，被RS使用 信号类 sys_kill sys_getksig,sys_endksig,sys_sigsend用于协助处理信号 内存类 sys_newmap 用于更新进程表的内核部分 sys_segctl,sys_memset 用于访问进程数据空间之外的内存 sys_umap 用于虚拟地址转换物理地址 sys_vircopy,sys_physcopy 用于使用虚拟地址或物理地址进行内存复制 时间类 sys_times 对应于time 系统控制 sys_abort 在正常关机请求或系统崩溃后，进程管理器产生 sys_getinfo相应对内核信息的不同请求 调用 系统调用 为POSIX标准描述的对进程可用的系统调用。在MINIX3中，用户进程不再直接向内核请求服务。 内核调用 系统任务接受所有对于内核服务的请求。 类系统调用 用于进程间通信的send，receive，notify等消息原语。 系统任务的实现 由kernel/主目录下的一个头文件system.h和一个C源文件system.c编译而成。 kernel/system.h 提供了绝大多数内核调用的函数原型 system.c 系统任务的主题逻辑 实现步骤 以read系统调用为例，读取一个数据库最坏需要11条消息，最少需要4条。 最坏情况 消息3请求系统任务执行I/O操作 消息4确认信号 当发生系统中断时，系统任务通过消息5告诉等待中的驱动程序这个事件 消息6和消息7分别是请求复制数据到文件系统的消息以及回复 消息8告诉文件系统数据已经准备好了（完成复制到缓冲区） 消息9和消息10是将数据由缓冲区复制到用户的请求消息和回复（跨进程复制） 消息11是给用户的回复 最好情况 在缓冲区中已经存在数据 消息2和消息3分别是将数据复制给用户的请求和回复 例子 以exec为例，进程管理器完成exec系统调用的大部分工作 为设置进程表内核数据结构中的栈指针，由do_exec来处理 调用exec的进程，发送消息给进程管理器后阻塞 不同于其他系统调用（相应结果将解除阻塞），exec没有响应 do_exec为进程解除阻塞，并使其成为就绪 参考资料 Operating System:Design and Implementation,Third Edition "},"notes/memory.html":{"url":"notes/memory.html","title":"内存管理的基本思想与算法","keywords":"","body":"层次化存储体结构 计算机的存储体系 寄存器（register） 在CPU内部，非常快速，昂贵 高速缓存（cache） 非常快速，昂贵，容量小，易失性 主存（RAM） 中等速度，中等价格，易失性 外存 容量大，速度慢，种类多，不易失 操作系统的工作就是协调这些存储器的使用，管理存储器的部分程序被称为存储管理器 记录存储使用状况 分配、回收存储资源 数据的装入与写回 存储管理系统分类 在运行期间，进程需要在内存和磁盘之间换进换出的系统（交换和分页）和不需要换进换出的系统。 不需要换进换出的系统 特点：进程被调入运行后，它将始终位于内存中，直至运行结束 没有交换和分页的单道程序 固定分区的多道程序 不需要换进换出的系统实现起来是最简单的，但无法做到并发等现代操作系统的高级功能。 基本的存储管理 单道程序存储管理 同一时刻只运行一道程序，应用程序和操作系统共享存储器。 相应地，同一时刻只能有一个进程在存储器中运行。 一旦用户输入了一个命令，操作系统就把需要的程序从磁盘贝到存储器中并执行它；在进程运行结束后，操作系统显示出个提示符并等待新的命令。当收到新的命令时它把新的程序装入存储器，覆盖掉原来的程序。 实现方案 将操作系统和应用程序在RAM上存放位置的不同分为以下三种结构： 固定分区的多道程序系统 将内存划分为n个分区（可能不相等），分区的划分可以在系统启动时手工完成。 实现方案 每个分区分别有一个运行队列 当一个作业到达时，可以把它放到能够容纳它的最小的分区的输入队列中 这会造成小分区的队列是满的，而大分区的输入队列却是空的 各分区共享同一个输入队列 如果选择小进程先运行，则会浪费内存空间；而如果选择大进程运行，则对小进程不利。 一种算法是至少保留一个小分区，这样小进程就可以直接运行不与大进程竞争 另一种方式是制定一条规则：规定一个进程被忽略的次数不能超过k次 重定位和存储保护 多道程序引发了两个很重要的问题： 当一个程序被链接时，必须知道程序将在内存的什么地方运行 当一个程序运行时，它只能访问自己的内存空间 重定位 使用相对地址进行链接。 当一个程序被装入内存时，直接对指令代码进行修改，一次性实现文件内的相对地址到内存中绝对地址之间的转换（一般为线性） 在装入时重定位并没有解决保护问题，一个恶意的程序总可以生成一条新指令去访问任何它想访问的地址 地址保护 每个内存块分配4位的保护码，PSW中包含一个4位的密钥，若运行进程试图对保护码不同于PSW中密钥的主存进行访问，则由硬件引起一个陷入 另一种解决方式是在机器中增加两个特殊的硬件寄存器，基地址（base）和边界（limit）寄存器。 程序分区的起始地址存储在基地址寄存器中 分区的长度存储在边界寄存器中 当访问内存单元时，直接用基地址加上指令地址访问 缺点是每一次内存访问都增加了一次加法和比较操作。 交换技术（swapping） 随着程序越来越大，我们已经无法一次性把程序全部放到内存同时运行，因此产生了两种技术：交换技术（swapping）和虚拟存储器（virtual memory） 原理 把各个进程完整地调入主存，运行一段时间，再放回到磁盘上，过段时间再调入运行。 可采用固定分区和可变分区。 内存紧缩（memory compaction） 当交换在主存中生成了多个空洞时，可以把所有的进程向下移动至相互靠紧，从而把这些空洞结合成一大块。 但这样会造成CPU资源浪费。 使用可变内存策略来减少进程移动或换入换出的次数。 支持可变内存策略 如果预计大多数进程在运行时都要增长，那么可以在进程被换入或移动时分配多一点的内存，从而减小系统开销。 但如果进程需要换出磁盘，只需要交换进程实际占用的内存内容。 实现方案 基于位图的存储管理 内存被划分为可能小到几个字或大到几千字节的分配单位，每个分配单位对应于位图中的一位，0表示空闲，1表示占用（或者反过来）。 位图的大小仅仅取决于内存和分配单位的大小。 缺点：在位图中查找指定长度的连续0串是一个缓慢的操作。 基于链表的存储管理 跟踪内存使用的另一个方法是维持一个已分配和空闲的内存段的链表。 链表中的每一个表项都包含下列内容： 指明是空洞(H)还是进程(P)的标志 开始地址、长度 指向下一个表项的指针。 内存分配算法 首次适配算法(first fit) 存储管理器沿着内存段链表搜索直到找到一个足够大的空洞 下次适配(next fit) 每次找到合适的空洞时都记住当时的位置，在下次寻找空洞时从上次结束的地方开始搜索，而不是每次都从头开始 最佳适配算法(best fit) 试图找出最接近实际需要的大小的空洞，而不是把一个以后可能会用到的大空洞先使用 实际性能其实很差，因为会造成很多空洞 每次被调用时都要搜索整个链表，因此会比首次适配算法慢 最坏匹配算法(worst fit) 在每次分配时，总是将最大的那个空闲区切去一部分，分配给请求者 进程链表和空闲链表分离 这样可以加快链表的查找速度 但使得内存的回收变得更加复杂，速度更慢 快速匹配算法(quick fit) 为一些经常被用到长度的空洞设立单独的链表 快速适配算法寻找一个指定大小的空洞是十分迅速的，但在一个进程结束或被换出时寻找它的邻接块以查看是否可以合并是非常费时间的 虚拟存储管理 基本思想 操作系统把程序当前使用的那些部分保留在存储器中，而把其他部分保存在磁盘上。 程序的代码、数据、栈可以超过实际可用的物理内存的大小 分页技术（paging） 虚地址空间被划分成称为页面（pages）的单位，在物理存储器对应的单位称为页框（page frames），页和页框总是同样大小的。 由程序产生的地址被称为虚地址（virtual addresses），他们构成一个虚地址空间（virtual address space） 在使用虚拟存储器的情况下，虚地址不是被直接送到内存总上，而是送到存储管理单元(MMU)，它在CPU中，其功能是把虚地址映射为物理地址 缺页故障（Page Fault） 当访问未有映射的虚拟页，会引发陷入，这个陷入称为缺页故障。 操作系统找到一个很少使用的页框并把它的内容写入磁盘，随后把需引用的页取到刚才释放的页框中，修改映射，然后重新启动引起陷入的指令。 页表（Page Table） 虚地址被分成虚页号（高位）和偏移（低位）两部分， 虚页号被用做页表的索引以找到该虚页对应的页表项，从页表项中可以找到页框号（如果有的话）。 页框号被拼接到偏移的高位端，形成送往内存的物理地址。 主要问题 页表可能会非常大 地址映射必须十分迅速 多级页表 使用多级页表来解决页表过大的问题。 因为局部性原理，程序实际访问的地址空间是很小的一部分，因此可以多次映射来将不需要的页表存储在磁盘中。 优点 避免将进程的所有页表项一直保存在内存中 缺点 需要多次访问内存，以查找页表 页表项的结构 页框号 物理页面号 有效位 这一位是1时这个表项是有效的可以被使用，如果是0，表示这个表项对应的虚页现在不在内存中，访问这一位为0的页会引起Page Fault 保护位 指出这个页允许什么样的访问。 在最简单的形式下这个域只有一位，0表示读写，1表示只读。一个更先进的安排是使用三位，各位分别指出是否允许读、写、执行这个页。 修改位和访问位跟踪页 在一个页被写入时硬件自动设置修改位，如果一个页已经被修改过，则必须把它写回磁盘，否则只用简单地把它丢弃就可以了 访问位在该页被引用时设置，被用来帮助操作系统在发生页面故障时选择淘汰的页，不再使用的页要比在使用的页更适合于被淘汰 禁止缓存位 这个特性对那些映射到设备寄存器而不是常规内存的页面是非常重要的。 TLB 由于访问页表（内存中）依然不够快，因此在CPU中有一小部分页表的拷贝，这部分页表是由最近访问页的页表项组成，称为TLB。 当一个虚地址被送到MMU翻译时，硬件首先把它和TLB中的所有条目同时（并行地）进行比较；如果找到了并且这个访问没有违反保护位，它的页框号将直接从TLB中取出而不用去查页表。 反置页表 物理存储器的每个页框对应一个页表项，而不是虚地址空间中的每个虚页对应一个页表项。 优点：节省大量为保存页表所需要内存空间 缺点：查找过程复杂 页面替换算法 动机 当发生缺页中断时，需从磁盘上调入相应的页面，然而内存已满，需要选取内存中的页面，将其换出，并装入新页面。 如何从众多的页面中选取被置换的页面？ 为此提出了各种算法 可以应于缓存块的置换、Web缓冲区的更新等 页面替换算法 The Optimal Page Replacement Algorithm 选择等待时间最长的那个页面被替换。 无法实现，因为无法知道一个页面还要等待多久被访问。 The Not Recently Used Page Replacement Algorithm 统计访问位和修改位，在一个时钟周期内，选择未被访问也未被修改的页面被替换 在一个时钟周期结束后，访问位会被清零 FIFO Page Replacement Algorithm 不是很好的算法，最先进入的页面也有可能是经常访问的页面 The Second Chance Page Replacement Algorithm 对FIFO的改进，如果访问位为1，那么曾经访问过，就把其清零，然后把页面放到链表的尾端，修改装入时间。 如果访问位为0，则直接淘汰。 实际上式寻找古老而且从上一次时钟中断以来未被访问的页面 The Clock Page Replacement Algorithm 改进二次机会算法，使用环形链表形式，避免了链表指针移动。 Least Recently Used Algorithm 将内存中最久未被访问的页面淘汰 性能较好，接近最优算法 每次访问都会造成链表节点更新，开销较大。 可以使用硬件支持来加速 Matrix method Counter method 使用软件模拟（老化） Not Frequently Used Algorithm 参考资料 Operating System:Design and Implementation,Third Edition "},"notes/minix memory.html":{"url":"notes/minix memory.html","title":"Minix3 进程管理器概述","keywords":"","body":"MINIX3不支持页式存储管理、提供了交换所需的相关代码。 进程管理器 负责处理与进程管理相关的系统调用（fork，exec和brk），分为两个功能（在一个进程中）： 进程管理 存储管理(存储管理器) 存储管理器保存着一张按照内存地址排列的空洞列表，当由于执行系统调用fork或exec需要内存时，系统将用最先匹配算法对空洞列表进行搜索找出一个足够大的空洞，在运行期间，这块内存都不发生变化。 策略与机制分离 哪个进程应该被放在内存中哪个位置的决定（策略）是由存储管理器作出的 而具体的为进程设置内存映像（机制）的操作是由在内核中的系统任务完成的（具体执行的） 这个划分使得修改存储管理策略（算法等）比较容易实现，不需要修改操作系统底层 内存布局 组合的I和D空间 即进程所有的部分（代码、数据、和栈）共用一个内存块，它是作为一个整体来申请和释放。 在MINIX中有两种情况需要分配内存： 在一个进程执行fork时，为子进程分配所需要的空间； 在一个进程通过EXEC系统调用修改它的内存映象时，老的映象被作为空洞送到空闲表，需要为新的映象分配内存。 独立的I和D空间 Minix3默认的是使用更为复杂的独立的I和D空间。 当这样的一个进程fork时，只需要分配为新进程做一个堆栈段和数据段拷贝所需数量的内存。 父进程和子进程将共享已经由父进程使用的执行代码，即共享代码（shared text） 当一个这样的进程执行exec时，系统将查找进程表看是否有另外一个进程已经在使用需要的执行代码，如果找到了就只为数据和堆栈分配新内存，已经在内存的代码段将被共享。 在一个进程结束时它总是要释放它的数据和堆栈占用的内存，但是只有在搜索了进程表并发现没有其他进程在使用代码段后，才释放代码段所占用的内存。 程序文件及内存布局 磁盘文件的头部包含了进程映象各部分的大小以及总的大小的信息。 在具有给定的I和D空间的程序头部，有一个域指出代码和数据部分的总长度，这些部分被直接拷贝到内存映象中。 映象中的数据部分增扩了头部bss域指出的数量，扩大的部分被清0，用于未初始化的静态数据。 总共分配的内存数量是由文件头中的total域说明。 对于组合I和D空间，假如一个程序有4K代码段、2K的数据与bss、和1K堆栈，若文件头中说明的需要分配的内存总量是40K(total)，那么在堆栈段和数据段之间的未用内存将是33K(40-1-4-2)。 对于使用独立的I和D段的程序(由文件头中连接器设置的一位指出)，文件头中的total域只对结合的数据段和堆栈段有用。一个有4K正文、2K数据、1K堆栈，total域为64K的程序将被分配68K的空间(4K指令空间，64K数据空间)，留出61K空间供数据段和堆栈在运行时使用。 参考资料 Operating System:Design and Implementation,Third Edition "},"notes/minix file system.html":{"url":"notes/minix file system.html","title":"Minix3 文件系统概述","keywords":"","body":"+++ title = \"Minix3 文件系统概述\" slug = \"minix file system\" tags = [\"os\"] date = \"2018-06-27T08:43:34+08:00\" description = \"\" +++ 文件系统管理文件分配空间和释放空间、记录磁盘块和空闲空间、提供某种方法以防止文件被未授权使用等等 MINIX文件系统是在用户空间中运行的一个大型C程序 文件系统可以独立于MINIX的其他部分进行修改、调试和测试 可以很方便地把整个文件系统移植到任何带有C编译器的计算机上 消息 文件系统的结构基本上与内存管理器和所有的I/O任务一样。 文件系统的主循环程序不断地等待消息 当收到消息后，它首先提取消息的类型，然后以其为索引查找文件系统中处理各类消息的过程指针表。 随后调用相应过程，进行处理后，返回状态值。 文件系统再把回答消息发送给调用进程，然后回到循环的开始，等待下一条消息的到来。 文件系统的布局 引导块 每个文件系统都以引导块开始，引导块中包含有可执行代码 硬件将从引导设备把引导块读入内存，并转而执行其他代码，引导块负责操作系统本身的加载工作。 超级块 超级块中包含的信息描述了文件系统的布局 位图 MINIX用两个位图来记录空闲i节点和空闲区段 在超级块中保存了i节点位图和区段位图中的第一个空闲块 使用区段的目的是确保同一文件的磁盘块处于同一个柱面上，从而提高文件顺序读写的性能（减少寻道时间） i-node 在打开文件时，先要找到它的i节点，并装入到内存中的inode表中，它将会一直在内存中，直至文件被关闭 每个i节点还有一个计数器，当文件多次打开时，在内存中只保存一个i节点拷贝。若i节点自上次调入内存之后被修改过，则要将它写回磁盘。 块高速缓存 所有未使用的缓冲区使用一个双向链表链接，按照最近一个使用时间排序 使用哈希表进行快速索引 每次文件系统需要一个块时，先调用get_block在缓冲区里寻找 若未找到这个块，并且缓冲区已满，将LRU链表的第一个块写回供使用 若找到这个块，则将缓冲区计数器加一 当函数完成后，调用put_block释放块 若计数器不为0，则只减去1 若计数器为0，则放到LRU链表，一般来说放到链表尾部（最近被访问） 目录和路径 文件系统的挂装 mount /dev/hd2c /usr /usr目录的i节点在内存副本设置标志位 将被挂装的文件系统的超级块调入内存超级块表中 一个指向自身根目录i节点的指针 一个指向其挂装的目标i节点的指针 一颗目录树下可能有多个文件系统 注意，即使挂装后可以直接访问，但依然不能硬链接，因为其不能跨文件系统 文件描述符 文件打开时，文件描述符被返回给用户进程。其后，READ、WRITE调用都使用文件描述符对文件进行操作。 由于fork之后的子父进程共享同样的文件描述符和文件位置，因此不能将文件位置存入进程表中。 Minix中引入一个新的共享表flip来实现。 READ系统调用 n = read(fd, buffer, nbytes); 库函数构造消息->文件系统 文件系统解析消息类型->调用相应处理函数 处理函数提取文件描述符->filp表项及i节点->定位数据块 在高速缓存中检查数据块，若不在，从磁盘中调入 系统任务将数据从高速缓存中用户进程空间 库函数返回，接着执行该语句之后语句 参考资料 Operating System:Design and Implementation,Third Edition "},"notes/race condition.html":{"url":"notes/race condition.html","title":"竞争条件与互斥","keywords":"","body":"竞争条件 协同进程可能共享一些彼此都能够读写的公用存储区（例如打印机脱机系统），也可能是一些共享文件，当两个或多个进程读写某些共享数据，而最后的结果却取决于进程运行的精确时序，就称为竞争条件（race condition）。 如果程序之间有竞争条件，也许大部分的运行结果都很好，但在极少数情况下会发生一些难以解释的事情。 互斥（mutual exclusion） 要避免这种错误，关键是要找出某种途径防止多个进程在使用一个共享变量或文件时，其他进程不能做同样的事。 互斥的实现有很多种，在UNIX编程中，总体来说有两种大的方案： 忙等待形式的互斥 优势在于被等待的进程（线程）不需要context switch（no extra overhead），提高了效率 但若等待时间较长，会浪费CPU资源。 会造成优先级反转问题（priority inversion problem） 睡眠等待 CPU利用率较高，但会造成context switch的overhead。 临界区 把对共享内存进行访问的程序片段称为临界区或者临界段（critical region）。 如果能够进行适当安排，使得两个进程不可能同时处于临界区，则能够避免竞争条件。 我们认为一个好的方案应该能解决竞争条件的同时，依然高效地进行操作，满足以下四个条件： 任何两个进程不能同时处于临界区。 不应该对CPU的速度和数目做任何假设。 临界区外的进程不得阻塞其他进程。 不能使进程在临界区外无休止的等待。 忙等待的互斥 关闭中断 这是最简单也最直接的方案，使得每个进程在进入临界区后先关闭中断，在离开之前再打开中断。 中断被关闭后，时钟中断也会关闭。因此CPU在做完临界区之前都不会发生进程切换。 缺点： 把关闭中断的权利交给用户进程是不明智的。可能会造成系统终止。 不适用于多CPU情形。 在实际中很少采用。 关闭中断对于操作系统是一项很有用的技术，但对于用户进程不是一种合适的通用互斥机制。 锁变量 设想有一个共享锁变量，在进程想要进入临界区时，先测试这把锁。 但可以想象，如果锁变量依然是普通类型（不是原子类型），则依然会发生竞争条件。 严格交替法 首先看示意代码： /// process 0 //// while(true){ while(turn!=0); critical_region(); turn=1; noncritical_region(); } /// process 1 //// while(true){ while(turn!=1); critical_region(); turn=0; noncritical_region(); } process 0 必须在 turn 变量等于0时才会进入临界区，process 1 必须在 turn 变量等于1时才能进入临界区。 假设turn变量初始化为0，则process 1会一直持续地检测一个变量，直到为1才执行下面的代码。这种等待为忙等待。一个适用于忙等待的锁称为自旋锁（spin lock）。 仔细观察以上代码，两个进程互相依靠对方提供的turn变量才能继续下去。若一个进程的noncritical_region() 很长，另一个必须等它完成后才停止while循环。因此，即使其代码在非临界区中，也会阻塞其他进程。 因此，该方案违反了条件3：进程被一个临界区之外的进程阻塞，所以不能作为一个很好的方案。 peterson解法 结合了锁变量和轮换法的思想： #define N 2 #define FALSE 0 #define TRUE 1 int turn; int interest[N]={FALSE};//所有值初始为0 void enter_region(int process){ interest[process] = TRUE; turn = process; int other = 1-process; while(turn == process && interest[other] == TRUE); } void leave_region(int process){ interest[process] = FALSE; } 我们主要关注enter_region可能发生的情况： 一个进程进入后，没有进程中断它，那么一直执行，不会发生空转； 若在turn = process;之后执行了下一个线程，那么下一个线程不会空转，直接执行； 可以这样理解条件判断语句： 若turn == process不满足，则说明另一个进程一定处于等待中（本进程的interest为TRUE），因此可以进入临界区。 若turn == process满足而 interest[other] == TRUE不满足，则说明这时候没有其他进程在等待进入，因此可以进入临界区。 TSL上锁 如果能有一种硬件解决方案，使得我们拿到了变量值，就不间断的更改这个值（原子操作），那将会是更有效的方法。 现在的计算机都支持这种方式，并有一个特殊的指令TSL。 TSL RX, LOCK 将一个存储器字读到寄存器中，然后在该内存的地址上存一个非零值。 读数和写数操作保证是不可分割的，即该指令结束之前其他处理机均不允许访问该存储器字。 使用这条指令来防止两个进程进入临界区的方案如下： 程序将LOCK原来的值复制到寄存器中，并将LOCK值置为1，随后这个原先的值与0比较。若非0，则说明之前已经上锁，从而程序一直空转。 并且，在现代操作系统中规定，拿到锁的进程即使没有时间片也要立即执行，这样会防止CPU的效率进一步下降。 优先级反转问题 例如H进程优先级高，L进程优先级低 ，假设L处于临界区中，H这时转到就绪态想进入临界区，H需要忙等待直到L退出临界区，但是H就绪时L不能调度，L由于不能调度无法退出临界区，所以H永远等待下去。 因此，我们想知道，是否有其他方法，既能使CPU效率提高，也能解决优先级反转问题。 睡眠等待 考虑通信原语（primitive）：sleep 和 wakeup。 sleep系统调用会引起进程阻塞，直到另一进程将其唤醒。 wakeup调用即将被唤醒的进程。 生产者消费者问题 两个进程共享一个公共的固定大小的缓冲区，其中一个是生产者，负责将信息放入缓冲区；一个是消费者，负责从缓冲区中读取信息。但如果我们使用常规的count变量记录缓冲区数量时，还是会出现两个进程永远睡眠的情况： #define N 100 int count = 0; void producer(void) { int item; while(TRUE) { item = produce_item(); if(count == N) //如果缓冲区满就休眠 sleep(); insert_item(item); count = count + 1; //缓冲区数据项计数加1 if(count == 1) wakeup(consumer); } } void consumer(void) { int item; while(TRUE) { if(count == 0) //如果缓冲区空就休眠 sleep(); item = remove_item(); count = count - 1; //缓冲区数据项计数减1 if(count == N - 1) wakeup(producer); consume_item(item); } 一种解决方案是增加一个唤醒等待位，当一个清醒的进程发送一个唤醒信号时，将该位置设为1；当程序要睡眠时，如果唤醒等待位为1，则清零，但不会睡眠。 信号量 引入一个整型变量来累计唤醒次数，称为信号量（semaphore）。一个信号量为非负数。 常用的为binary semaphore：down 和 up。 down 操作是检查其值是否大于0，若为真，则减一，若为0，则进程将睡眠，并且，检查数值，改变数值以及可能发生的睡眠操作是单一的原子操作（atomic action）。 up 操作是递增信号量的值。对于一个进程，若有睡眠的进程，则信号量执行一次up操作后，信号量依然为0，但在其上的睡眠进程减少一个（唤醒一个）。 #define N 100 typedef int semaphore; semaphore mutex = 1; semaphore empty = N; semaphore full = 0; void producer(void) { int item; while(TRUE) { item = produce_item(); down(&empty); //空槽数目减1，相当于P(empty) down(&mutex); //进入临界区，相当于P(mutex) insert_item(item); //将新数据放到缓冲区中 up(&mutex); //离开临界区，相当于V(mutex) up(&full); //满槽数目加1，相当于V(full) } } void consumer(void) { int item; while(TRUE) { down(&full); //将满槽数目减1，相当于P(full) down(&mutex); //进入临界区，相当于P(mutex) item = remove_item(); //从缓冲区中取出数据 up(&mutex); //离开临界区，相当于V(mutex) up(&empty); //将空槽数目加1 ，相当于V(empty) consume_item(item); //处理取出的数据项 } } 我们使用两种不同的方法来使用信号量。 信号量mutex用于互斥。保证任意时刻只有一个进程读写缓冲区和相关的变量 信号量full与empty用于保证一定的事件顺序发生或不发生。用于同步。 互斥（mutex） 若不需要信号量的计数能力，可以用于互斥：是一个处于两种变量之间（解锁和加锁）的变量。 适用于两个过程： 当一个进程需要进入临界区时，调用mutex_lock，如果此时互斥是解锁的，那么调用进程可以进入临界区。 若该互斥已经加锁，调用者被阻塞，等待在临界区中的进程完成操作并调用mutex_unlock退出为止。 多线程实现 这里以银行汇款为例子，讲解在竞争条件或互斥下的不同状态。若A和B都有10000元，考虑同时汇款的情形（thread1、thread2），我们可以写出以下代码： #include #include #include #include int sharedi = 0; int A = 10000; int B = 10000; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; void thread1() { int i = 0; for (i = 0; i 若直接运行，我们会得到很奇怪的答案： 会发现每一次汇款后，钱的总数不再等于20000，因此发生了竞争条件。 我们使用POSIX提供的mutex函数加锁后： 这样就得到了我们想要的答案。 参考资料 忙等待的互斥 Operating System:Design and Implementation,Third Edition 多线程的同步和互斥 "},"notes/storage.html":{"url":"notes/storage.html","title":"存储管理中的设计问题","keywords":"","body":" 光了解Page的基本原理还不够，还需要知道如何设计存储才能达到一个更好的性能。 页式存储管理 工作集模型 在虚拟页存储管理中，当一个进程被启动，其所有页面都还在外存。当CPU取第一条指令时，就会引发缺页中断。因此，在程序启动一开始，很容易发生缺页中断，工作一段时间后再维持稳定，如图所示： 这种工作方式被称为demand paging：页面不是预先被装入内存，而是根据需要随时调整。 访存的局部性与工作集 访存的局部性（locality）：在进程运行的任何阶段，它都只访问它的页面中较小的一部分 工作集（working set）：一个进程当前使用的页的集合 抖动：分配给进程的物理页面数太小，无法包含其工作集，频繁地在内存和外存间换页 工作集模型：页式存储管理系统跟踪进程的工作集，并保证在进程运行以前它的工作集就已经在内存中了。在进程运行之前预先装入页面也叫做预先调页（prepaging）。 分配策略 当发生缺页时，页面置换算法作用的范围不同，对应不同的分配策略： 局部页面置换算法：在进程所分配的页面范围内选取将被置换的页面 每个进程分配固定大小的内存空间 全局页面置换算法：在内存中所有的页面范围内选取被置换的页面 所有进程动态共享系统的物理页面，分配给每个进程的页面数动态变化 一般来说，全局算法的性能更好。这是因为在进程运行期间，工作集可能发生较大的变化；而局部算法可能浪费空间，也更容易造成抖动。 物理页面的分配 那么，如何来分配不同进程的物理页面呢？ 在全局算法下，当一个进程刚开始运行时，可以先根据进程的大小给它分配一定数量的物理页面，然后在进程的运行过程中，再动态调整内存空间的大小。 可以采用缺页率（Page Fault Frequently）算法： 缺页率：一秒钟内出现的缺页数(统计) 定义进程缺页率的上下界，使得进程的缺页率在其范围之内 负载控制（load control）：系统内运行的进程过多，无法使所有进程的缺页率都低于A，则需要将一些进程换出至外存，这里的交换是为了减少潜在的内存需求 这种算法的前提假设是：当分配给进程的物理页面增多时，缺页率将会下降。 页面大小 页面大小需要权衡多方互相矛盾的因素： 内碎片、空间利用率 从统计的规律看，内碎片的大小一般是半个页面；页面越小、内碎片也会越小、浪费越少 例，内存被分配n段，页面大小为p, 则总内碎片大小为np/2 页表项数、页表装入时间 同一程序，页面大小越小，需要的页表项会越多 传送不同大小页面所花的时间相差不多，同一程序，页面越小、页面数会越多、故时间会越长 一般来说，页面大小为512字节到4KB之间。 虚拟存储接口 通常虚拟存储器对进程和程序员是透明的，即所能看到的全部是在一个带有较小的物理存储器之上一个大的虚地址空间 允许程序员对内存映射进行某些控制，可以实现两个或多个进程共享同一段内存空间，即页面共享 可用来实现高性能消息传递系统 分布式共享存储器 允许在网络上的多个进程共享一组页面，这些页面可以组成一个共享的线性地址空间 段式存储管理 页式管理是把内存视为一维线性空间；而段式管理是把内存视为二维空间。 很多时候，拥有两个或多个独立的虚拟地址空间可能要比单个空间好得多。 将程序的地址空间划分为若干个段(segment)，程序加载时，分配其所需的所有段(内存分区)，这些段不必连续；物理内存的管理采用动态分区。 程序通过分段(segmentation)划分为多个模块，如代码段、数据段、共享段。 可以分别编写和编译 可以针对不同类型的段采取不同的保护 可以按段为单位来进行共享，包括通过动态链接进行代码共享 优点 没有内碎片。 便于改变进程占用空间的大小。 易于实现代码和数据共享，如共享库 引入新的问题 存在外碎片，需要通过内存紧缩来消除。 与页式存储系统的不同：页面是定长的而段不是。 当进行段调度时，可能会出现很多的外碎片（external fragmentation） 参考资料 Operating System:Design and Implementation,Third Edition Linux 内存映射函数 mmap（）函数详解 "},"notes/file system.html":{"url":"notes/file system.html","title":"文件系统","keywords":"","body":"文件系统的基本概念 文件系统的基本要求 必须能够存储大量的信息。 在使用信息的进程终止时，信息必须保存下来。 多个进程可以并发地存取信息。 文件 文件命名 文件是一个抽象机制，它提供了一种把信息保存在磁盘上而且便于以后读取的方法。它必须这样来实现，使用户不必了解信息存储的方法、位置以及磁盘实际运作方式等细节。 文件结构 文件是一个无结构字节序列，Unix采用这种方式 文件是一个固定长度记录的序列，每条记录都有内部结构 文件由一棵记录树构成，每条记录长度不等。在记录的固定位置包含一个关键字域。记录树按关键字域进行排序，这便于对特定关键字进行快速查找。 文件类型 常规文件(regular file)中包含有用户信息。 是ASCII文件或者二进制文件。 ASCII文件由多行文本组成。 ASCII文件的最大优点是可以原样地显示和打印，也可以用通常的文本编辑器进行编辑。 二进制文件，无法直接查看，但对于使用它的程序而言，其具有一定的内部结构。 目录(directory)是管理文件系统结构的系统文件。 字符设备文件(character special file)和输入/输出有关，用于处理串行I/O设备。 块设备文件(block special file)则用于处理磁盘。 文件访问 顺序访问(sequential access) 进程可以从文件开始处顺序读取文件中所有字节或者记录，但不能够略过某些内容，也不能够非顺序读取。 顺序存取文件可以重绕，只要需要，可以多次读取该文件。 主要用于磁带 随机访问(random access) 可以非顺序地读取文件中的字节或记录，或者根据关键字而不是位置来存取记录 主要用于磁盘 文件属性 每个文件除了文件名和数据本身之外，操作系统还给文件赋以其他信息，比如，文件创建日期、文件长度等等。 目录 为了记录文件，文件系统通常需要用到目录，在许多系统中，目录本身也是文件。 一个目录通常包含多个目录项，每个目录项代表一个文件 目录项包含了文件名字、属性和文件数据存储地址等信息 目录项仅包含文件名字、以及一个指向另一个数据结构的指针 目录系统 每个系统的目录数目各不相同，最简单的设计方案是维护一个单独的目录，其中包含所有用户的全部文件 对于整个系统中使用单独一个目录管理所有文件的想法的改进是，每个用户拥有一个目录 这种设计消除了不同用户之间的文件名冲突，但仍然难以使那些有许多文件的用户感到满意（需要子目录）。 更进一步，需要的是一般的层次结构(即目录树)。 使用层次结构，每个用户可以拥有所需的多个目录，以便自然地组织他们的文件。 路径名 使用目录树来组织文件系统时，需要相应的方法指定文件名 每个文件都赋予一个绝对路径名(absolute path name)，它由从根目录到文件的路径组成。 另一种文件名是相对路径名(relative path name)。它常和工作目录(也称作当前目录)的概念一起使用。用户可以指定一个目录作为当前的工作目录。这时，所有的路径名，如果不是从根目录开始，都是相对于工作目录的。 文件系统实现 文件系统布局 主引导记录(MBR)：磁盘的扇区0，用于启动计算机。 在MBR未尾有一个分区表，里面记录了每个分区的起始地址和结束地址，其中有一个活动分区。 机器启动后，BIOS读入并执行MBR中的代码。 MBR程序确定活动分区，并读入它的第一个磁盘块，即引导块，然后执行之。 引导块把保存在该分区中的操作系统装入内存并运行。 在类UNIX中，文件系统由超级块管理，它包含了关于文件系统的所有关键参数，当文件系统第一次被加载时，超级块的内容被装入内存。其后，是空闲空间管理，记录文件系统中的空闲物理块信息。之后是索引节点，每个索引节点对应于一个文件，记录了文件的属性信息及在磁盘上的存储地址。 文件实现 连续分配法 把每个文件作为连续数据块存储在磁盘上。例如，在具有1K大小块的磁盘上，50K的文件要分配50个连续的块。 优点 简单、容易实现，记录每个文件用到的磁盘块仅需记住一个数字即可，也就是第一块的磁盘地址。 性能较好，在一次操作中，就可以从磁盘上读出整个文件。 缺点 首先，除非在文件创建时就知道了文件的最大长度，否则这一方案是行不通的。 该分配方案会造成磁盘碎片 链表分配法 为每个文件构造磁盘块的链接表，每个块的第一个字用于指向下一块的指针，块的其他部分存放数据。 优点 每个磁盘块都可以被利用，不会因为磁盘碎片而浪费存储空间；目录项中只需记录一个整数(起始块号) 缺点 尽管顺序读取文件非常方便，但是随机存取却相当缓慢。 此外，因为指针占去了一些字节，每个磁盘块存储数据的字节数不再是2的幂。可能造成性能损失 文件分配表法（FAT） 如果取出每个磁盘块的指针字，把它放在内存的表或索引中，就可以消除链接表法的两个不足，即文件分配表法（FAT） 优点 整个磁盘块都可以存放数据；随机存取容易；目录项中只需记录一个整数(起始块号) 。MS-DOS就使用这种方法进行磁盘分配。 缺点 主要缺陷是必须把整个链表都存放在内存中，占用较多的存储空间。 索引节点法 给每个文件赋予一张称为i-node(索引节点)的数据结构，其中列出了文件属性和各块在磁盘上的地址。 目录实现 在读文件前，必须先打开文件。打开文件时，操作系统利用用户给出的路径名找到相应目录项，目录项中提供了查找文件磁盘块所需的信息 由于系统不同，这些信息可能是整个文件的磁盘地址(连续分配方案)、第一个块的块号(对于两种链接表分配方案)或者是i-节点号。 共享文件 提供文件共享的方法：利用多个目录中的不同文件名来描述同一共享文件（即文件别名，该方法的访问速度快，但会影响文件系统的树状结构，适用于经常访问的文件共享，同时存在一定的限制）。 硬链接 基于改进的多级目录结构，将目录内容分为两部分：文件名和索引结点。 前者包括文件名和索引结点编号，后者包括文件的其他内容（包括属主和访问权限）。 例如： ln source target ; rm source 通过多个文件名链接(link)到同一个索引结点，可建立同一个文件的多个彼此平等的别名。别名的数目记录在索引结点的链接计数中，若其减至0，则文件被删除。 限制：不能指向另一个文件系统中的i-node。 软链接 一种特殊类型的文件，其内容是到另一个目录或文件路径名。建立符号链接文件(软链接)，并不影响原文件，实际上它们各是一个文件。可以建立任意的别名关系，甚至原文件是在其他计算机上。 ln -s /user/a /tmp/b \"cd /tmp/b ; cd ..\"是进入目录\"/user\"而不是\"/tmp\"； 当一个文件被删除时，相应的所有链接都无效。 磁盘空间管理 存储n个字节的文件可以有两种策略：分配n个字节的连续磁盘空间，或者把文件分成许多个(并不一定要)连续的块。 几乎所有的文件系统都把文件分割成固定大小的块来存储，各块不必相邻。 块大小 书中P352给出了块大小与访问速率、磁盘空间利用率的关系，可以发现，性能与空间利用率是相互冲突的。 空闲块管理 使用磁盘块的链接表 磁盘块中包含尽可能多的空闲磁盘块号 使用位图 n个块的磁盘需要n位位图。 在位图中，空闲块用1表示，分配块用0表示(或者反之)。 文件系统的可靠性 备份 备份整个文件系统、还是部分备份 增量备份、常规备份 是否采取数据压缩 快照技术 存储介质的物理安全 备份策略 物理转储 当将磁盘的内容备份至磁带上时，从磁盘的第0个块开始，按照顺序把所有的磁盘块依次写到输出磁带中。 优点：简单快捷 缺点：备份了一些无用的信息(空闲块、坏块)，不支持增量备份、不能根据需要恢复特定的数据 逻辑转储 从一个或多个指定目录开始，对该目录下的每个文件和目录，进行备份，或以某个时间基点备份其文件和目录的修改数据 优点：支持增量备份、避免备份无效的数据 不足：相对物理转储，需要一定的技巧，以避免引入错误 文件系统的一致性 分为数据块和文件的一致性。 数据块 对于数据块，可能出现快丢失（不严重），重复块（严重）。 文件 检验程序从根目录开始，沿着目录树递归下降，检查文件系统中的每个目录。对每个目录中的文件，其i节点对应的计数器加1。 当全部检查完成后，得到一张表，对应于每个i节点号，表中给出了指向这个i节点的目录数目。 i节点的链接数大于指向i节点的目录项个数 这一错误并不严重，可是却浪费了磁盘空间。即使所有的文件都被删除，文件链接数仍然为非0值，该i节点不会被删除。 措施：把i节点中的文件链接数设置成正确的值。 i节点的链接数小于指向i节点的目录项个数 该错误具有严重的潜在问题。如果两个目录项都链接到同一个文件，但其i节点的文件链接数只为1，如果删除任何一个目录项，i节点链接数变为0。文件系统将该i节点标志为“未使用”，并释放该文件的所有磁盘块。这将导致另一个文件数据丢失 措施：把i节点中的链接数设置为目录项的实际数目 文件系统性能 高速缓存 减少磁盘访问次数最常用技术是块高速缓存，其中，高速缓存是一些块，它们逻辑上属于磁盘，但基于性能的考虑而保存在内存中。 一般来说，使用一个哈希表查找需要的数据块，而使用LRU算法将所有块用双向链表连接起来。 高速缓存向磁盘的写入 直写，即当数据块被修改，写高速缓存时亦立即写入磁盘中 写回，当数据块被修改，只将其写到高速缓存中，之后再根据需要(需要被换出、关系一致性问题而特意保存、定时强制被保存)再写回到磁盘中 块预读 在数据块被访问之前，预先把它们读入高速缓存，从而提高高速缓存的命中率 适用于顺序访问文件，不适用于随机访问 减少磁头臂移动技术 将可能顺序访问的块存放在一起，最好在同一个柱面上，从而减少磁头臂的移动次数 对于位图法管理空闲块的情况，在分配新的数据块时，尽量找与顺序访问时前一个块(已分配了)最邻近的空闲块 对于链表法管理空闲块的情况，在分配新的块时，一次分配一组连续的块，在顺序访问亦可减少寻道时间 控制信息与数据信息的存放位置 在使用i节点或者与i节点等价结构的系统中，另一个性能瓶颈在于，即使读取一个很短的文件也要访问两次磁盘：一次是读取i节点，另一次是读取文件块 改进方法一：把i节点放在磁盘中部，在i节点和第一块之间的平均寻道时间减为原来的一半 改进方法二：把磁盘分成多个柱面组，每个柱面组有自己的i节点、数据块和空闲表，在创建文件时，可以选取任一个i节点，然而分配块时，在该i节点所在的柱面组上进行查找 文件系统的安全性 安全环境 数据的机密性 确保敏感数据处于机密状态下，保证未被授权的用户无法看到这些数据 数据的完整性 未被授权的用户不能去修改任何数据，防止数据被篡改 系统可用性 确保系统的正常运行，防止拒绝服务攻击 恶意程序 病毒 拒绝服务（大量消耗计算机资源） 蠕虫 独立的程序，通过网络来传播 特洛伊木马 逻辑炸弹 保护机制 采用机制与策略分离 使用参照监视器(reference monitor) 保护域 保护矩阵 访问控制列表（按列存储保护矩阵） 主体：一个主动的实体，通常是用户和进程 客体(对象)：一个被动的实体，通常是文件和资源 权能表(capability list)或称C表（按行表存储保护矩阵） 秘密通道 调节CPU使用强度 调节页面率、文件锁 申请和释放专用资源 参考资料 Operating System:Design and Implementation,Third Edition "},"projects/":{"url":"projects/","title":"Projects","keywords":"","body":""},"projects/minix.html":{"url":"projects/minix.html","title":"Minix 安装及配置指南","keywords":"","body":" 这学期的操作系统课我们使用Minix3.3进行教学。折腾了一上午，在此记录下自己安装和配置Minix的过程。 系统介绍 Minix是一种基于微内核架构的类UNIX系统，与最受欢迎的Linux系统的最大区别就是：Linux是巨内核，Minix是微内核。Minix是由Andrew S. Tanenbaum大神发明的，其最初设想就是为了教学。由于Minix内核代码只有几千行，因此我们这学期也用它来学习操作系统。 Minix3.3已经增加了图形界面，但由于有不少bug，且从学习的角度，本文依然采用命令行的方式进行安装和使用。 环境配置 本文为Windows下的环境配置，Mac OS下的配置类似。 需要先从Minix官网上下载iso镜像文件。 下载VMware等其他虚拟机软件。 下载MobaXterm等其他远程终端软件，便于从物理机上开多个窗口访问虚拟机。 安装Minix 打开VMware，选择Create a New Virtual Machine，点击Typical,选择I will install the Operating System later，再1. 操作系统类型和版本都设置为 other/unknown，将将虚拟光驱路径设置为Minix镜像文件。设置内存大于512MB，硬盘大于4GB（确保足够资源），确保网络模式为NAT/网络地址转换(便于访问外网)。 启动虚拟机，按照提示一路回车（使用默认配置）。 输入shutdown -h now，关闭虚拟机。 将虚拟机移除Minix镜像文件（否则每次启动都需要重新配置），重新启动。 通过输入一些基本命令如ls，ps指令测试是否安装正确。 安装开发环境 在线更新软件仓库元数据，输入 pkgin update 在线安装git版本控制器,输入 pkgin install git-base 在线安装SSH,输入 pkgin install openssh 在线安装VIM,输入 pkgin install vim 在线安装clang编译器， 输入 pkgin install clang 在线安装运行链接库，输入 pkgin install binutils 通过SSH设置远程控制 直接在虚拟机中使用Minix中不太方便，一方面不能很好的与物理机进行交互，另外一方面是不能打开多个命令行窗口。因此，本文使用SSH进行连接和文件交换。 将VMware中Minix的虚拟机的网络连接改为桥接（bridge）模式，这一步骤是为了让虚拟机拥有自己的IP地址。 打开Minix，输入ifconfig，查看本机的IP地址。 在命令行中输入passwd root，设置账号为root的密码（很奇怪为什么Minix没有初始密码）。注意，只有设置了密码后才能使用SSH。 打开MobaXterm，选择使用SSH连接，输入账号和密码即可进入。 可以使用MobaXterm方便的进行文件传输和远程控制。 使用FTP配置文件共享 虽然说使用了MobaXterm就没有必要再专门配置文件共享了，但我们最开始是使用FTP进行文件传输，既然掉进了这个坑，就还是记录下心得吧。 下载fiezilla等ftp服务器。 在fiezilla中，选择Edit - Users，添加账号，选择一个文件夹传输文件，配置好后点击ok完成。 在Windows下打开命令行使用命令ipconfig查看当前电脑的IP地址，在Windows文件框中输入ftp://user：password@IP地址，若没有设置密码可以不填写。看是否能访问设置文件传输的文件夹。 在Minix虚拟机中，登陆ftp客户端，输入ftp 物理机ip。 输入lcd 下载路径选择文件传输后的下载路径。 使用ls，cd等命令移动到物理机中所需的文件目录。 输入get + 文件名，下载当前文件。 使用exit退出ftp客户端，查看文件是否下载。 测试 到此时，Minix的开发环境就已经设置好了。你可以新建一个hello.c文件，放到Minix中进行测试。注意，Minix3已经不支持GCC，因此我们必须用Clang进行编译，使用clang hello.c –o hello看是否能成功编译。再输入./hello进行执行，查看结果。 "},"projects/pipeline.html":{"url":"projects/pipeline.html","title":"Pipeline","keywords":"","body":"管道是什么 首先来看一个命令： cat file1 file2 | sort cat表示读取file1、file2中的数据，然后使用管道 |，将这些内容作为输入，使用sort函数作为输出，最后输出在屏幕上。 管道做了什么事 熟悉类UNIX系统的朋友一定经常使用管道，其实它就是用来做进程通讯的。 我们很多时候需要将一个文件中的内容作为另一个文件的输入，或者将一个程序运行的结果作为另一个程序的输入，这时候管道就派上用场了。我们这里先只考虑无名管道。 无名管道 只能用于具有亲缘关系的进程之间，父子进程，兄弟进程之间通信，因为只有子进程才能继续父进程的文件描述符。 半双共通信（同一时刻只能对管道进行一种操作（读操作或者写操作）），具有读端口和写端口。 管道是一种特殊的文件，可以使用文件I/O函数（read,write...）来操作，但不能使用lseek函数来定位操作。 管道是在内存中，不用我们主动去删除。 管道是基于队列实现的，有大小限制。 管道实现原理 相关概念与函数 文件描述符(File Descriptor) 对于内核而言，所有打开文件都是由文件描述符引用。文件描述符（fd）是一个非负整数。 当打开一个现存文件或者创建一个新文件时，内核向进程返回一个文件描述符。fd可以理解为一个文件的标识，系统调用中的open和creat都返回fd，并将其作为参数传给read或write。 通常情况，UNIX shell使文件描述符0与进程的标准输入相结合，文件描述符1与标准输出相结合，文件描述符2与标准出错输出相结合。 因此，文件描述符可以看成是文件描述符表的一个下标，我们可以通过这个fd访问文件的信息（fstate），也可以使用write或read对文件进行修改，具体细节可参考这篇文章。 总之，文件描述符是标识每一个文件及状态的重要标识，而UNIX默认使用0,1,2作为标准输入输出以及错误输出，因此，我们如果想要改变标准输出，就需要将0,1对应的标准输入输出改成我们需要的文件，这样，就可在程序本身不知情的情况下对其进行操作。 fork() fork()可以用来新建进程，实际上是创建一个原进程的副本，包括文件描述符、寄存器值等，子进程和父进程互不相关，如果一个进程的变量发生变化，并不会影响另一个进程。 由于我们是无名管道，需要知道进行传输的两个进程之间的文件描述符，因此fork()必不可少。 dup() dup(fd)为复制文件操作符的系统函数，可以定向目前未被使用的最小文件操作符到fd所指的文件（回忆文件操作符其实只是一个下标）。 例如，如果我们想用一个程序使用一个普通文件作为标准输出，怎么做？可以先关闭文件描述符1，再打开一个新文件（open系统调用函数返回的fd从0开始寻找未被使用的最小文件描述符），这时候，文件描述符1就被定向到那个我们需要进行输出的普通文件。但当我们完成输出后，标准输出已经无法恢复。 因此，我们需要使用dup来将多个文件描述符对应到标准输出，这样我们就可以进行恢复。 下面是主要操作方法： fd = dup(1) 该操作将标准输出（1）分配一个新的文件描述符fd，并使之对应于标准输出文件（屏幕）。也就是说，现在也可以使用fd进行标准输出了，效果与默认的标准输出一样。 然后，我们可以将标准输出（1）关闭，打开一个新文件，这时候，新文件的文件描述符就为1，因此这个文件就作为了标准输出。 当需要恢复原来的标准输出时，先关闭文件操作符1（使之空闲），然后执行： n = dup(fd) 这时候，dup自动找到最小的空闲文件操作符（1），并被定向到fd所指的文件，也就是标准输出。 pipe() pipe(&fd[0])系统调用创建一个管道并返回两个文件描述符，一个用于写，一个用于读。 一般来说，在本条语句之后会调用一个fork来创建一个子进程，然后父进程关掉用于读的文件描述符，子进程关掉用于写的文件描述符，这样便可以做到一个进程向管道中写数据，一个进程向管道中读数据了。 execlp() execlp()函数属于exec()函数族，会从PATH环境变量所指的目录中查找符合参数file的文件名，找到后便执行该文件，然后将第二个以后的参数当做该文件的argv[0]、argv[1]……，最后一个参数必须用空指针(NULL)作结束。（具体用法见后面示例） 实现过程 有了以上的知识，我们就知道如何让两个进程进行通讯了。 使用pipe建立一个管道。 使用fork建立一个子进程，他们共同享有管道的读和写。 将一个进程的标准输入改为管道的读，另一个进程的标准输出改为管道的写。 使用exec()函数族运行所需要的程序。 具体示例 我们想自己实现一个管道，可以将number.txt中的数字读取出来，并使用sort函数进行排序，最后将排序结果输出在Shell中。 原始number.txt中为： 99 123 892 12 1342 89 32 76 实现源码 int main(int argc, char *argv[], char **environ) { int fd[2]; pipe(fd); if (fork() != 0) { /*this is the father, need to read*/ close(fd[1]); close(0); dup(fd[0]); close(fd[0]); // dup2(fd[0], 0); // close(fd[1]); execlp(\"sort\", \"sort\", \"-n\", NULL); exit(0); } else { /*this is the child, need to write*/ close(fd[0]); close(1); dup(fd[1]); close(fd[1]); // dup2(fd[1], 1); // close(fd[0]); execlp(\"cat\", \"cat\", \"numbers.txt\", NULL); exit(0); } exit(0); return 0; } 编译运行 笔者使用Minix3.3进行编译，其他类UNIX也可同样进行。即可将排好序的数字输出到Shell： 心得 在UNIX中，标准输入输出也是一个文件，只是默认用文件标识符0,1与之对应。 需熟练掌握UNIX系统调用的使用方法，以及进程的管理。 参考资料： 进程通信之无名管道 在linux上 重定向 管道实现 对stdin，stdout 和STDOUT_FILENO，STDIN_FILENO的学习 Operating System:Design and Implementation,Third Edition "},"projects/pipeline1.html":{"url":"projects/pipeline1.html","title":"UNIX 管道及 Shell 实现（一）主体框架","keywords":"","body":" 操作系统的第一个大作业是做一个简单的Shell，实现重定向、管道等功能。奋战了好几天终于基本搞定了= = 基本要求 Shell能够解析的命令行法如下： 带参数的程序运行功能。 program arg1 arg2 … argN 重定向功能，将文件作为程序的输入/输出。 “>”表示覆盖写 program arg1 arg2 … argN > output-file “>>”表示追加写 program arg1 arg2 … argN >> output-file “ program arg1 arg2 … argN 管道符号“|”，在程序间传递数据(最后也可用重定向符号) programA arg1 … argN | programB arg1 … argN | programC … 后台符号& ,表示此命令将以后台运行的方式执行 program arg1 arg2 … argN & 工作路径移动命令cd Shell退出命令exit history显示开始任务后执行的命令；history n显示最近执行的n条指令 基本思路 很明显本次实验主要是以考察Shell基本功能以及管道的实现为主。之前已经详细讲解了管道的实现，可以参考这篇文章。 熟悉命令 首先我们先在UNIX自带的Shell下实现重定向和管道功能，示例命令可以参考如下： # ps & # cat numbers.txt | sort > temp.txt # sort a.txt # ps -ef | grep -sh # cd .. 我们不难发现： “>”，“>>”重定向命令只能在命令中出现一次，一旦出现后，之后还有什么命令也是无效的。 “ “|”管道命令可以出现多次，且管道之后还可以使用重定向符号。 实际上所有命令进入程序之后都是一串字符串，因此对字符串的解析是最重要的。 对于ps，ls，cd等命令，可以使用exceve命令进行操作，并不需要我们自己实现。 如果注意，可以发现系统Shell在实现后台进程时，可能会出现如下情况： 我们让ls的结果在后台运行，但为什么会在结果前多一个“#”呢？ 原因是因为后台运行的子进程和前台运行的父进程同时进行，谁先谁后不能确定，图中就是父进程先运行，打印了“#”，子进程再打印ls的结果，因此出现了这种情况。 难点 管道的实现以及fork()的使用。 子父进程进行信号交互，以及回收僵尸进程。 多文件的协调和编译。 大体框架 主函数入口 由于我们在Windows下写这个Shell无法编译，每次必须在UNIX下编译，因此必须在写之前就想好模块布局，不然很难debug和进行单元测试。 一个Shell其实就是一个while(1)的死循环，每次输出提示符到屏幕，然后执行输入的字符串命令。因此不难写出大体框架： int main() { /*Command line*/ while (1) { printf(\"cmd >\"); /*set buf to empty*/ memset(buf, 0, sizeof(buf)); /*Read from keyboard*/ fgets(buf, MAXLINE, stdin); /*The function feof() tests the end-of-file indicator for the stream pointed to by stream, returning non-zero if it is set. */ if (feof(stdin)) exit(0); /*update the command history*/ UpdateHistory(); /*command exceve*/ command(); } return 0; } 主程序的确很简单，就是每次用buf读取输入的字符串，然后更新输入列表（为了 history功能的实现），然后再解析命令（command）即可。 字符串命令存储方式 Shell主要就是对得到的命令进行操作，因此命令如何存储是至关重要的。最简单的想法就是用一个char*[]字符串数组存储，但是我们后面对命令解析需要 命令的下标等其他信息，因此这里选择用struct进行存储更为方便。 定义结构体如下： struct CommandInfomation { char* argv[512]; /*store the command after Parsing*/ int argc; /*the number of argv,split with space*/ int index; /*store the index of special character*/ int background; /*whether it is a background command*/ enum specify type[50]; int override; /* in case after 初始化函数为： void initStruct(struct CommandInfomation* a) { a->argc = 0; a->index = 0; a->background = 0; a->override = 0; a->file = NULL; memset(a->type, 0, sizeof(a->type)); } 特殊字符命令 对于重定向\">\"，管道\"|\"等特殊命令，我们需要使用额外的标识来注明，方便后面的操作。这里使用eunm实现。 /*the enum stand for different command*/ enum specify {NORMAL, OUT_REDIRECT, IN_REDIRECT, OUT_ADD, PIPE}; 主要函数详解 pipe(fd2) 此函数用于实现无名管道，将fd2数组中的两个文件描述符分别标记为管道读（fd[0]）和管道写（fd[1]）。 dup(fd) 为复制文件操作符的系统函数，可以定向目前未被使用的最小文件操作符到fd所指的文件。相类似的函数还有dup2[fd1,fd2],意思是 未被使用的文件描述符fd2 作为fd1的副本，进过此函数后，fd1和fd2都可访问同一个文件。 execlp(const char *file, const char *arg, ...) 属于exec()函数族，会从PATH环境变量所指的目录中查找符合参数file的文件名，找到后便执行该文件，然后将第二个以后的参数当做该文件的argv[0]、argv1……，最后一个参数必须用空指针(NULL)作结束。 命令中的ls，ps等内置系统命令都可以由此函数进行解析。要注意，此函数一经调用就不会再返回。 chdir(const char * path) 改变当前的工作路径以参数path所指的目录，使用比较简单，支持常用的改变路径的方式，例如退回上一级：cd .. ，也支持绝对路径。 执行命令 由主函数可知，我们得到了命令需要进行解析，由于我们知道exceve函数一旦调用就不会返回，因此要使用fork()函数对其子进程进行处理。 这里需要注意的是，由于子进程一定要比父进程先结束，因此我们需要将执行的命令放到子进程中，父进程进行等待或者执行后面的命令，否则会出现父进程结束子进程还在运行的错误。 父子进程进行通讯 需要注意的是，Shell支持后台程序运行，因此，父进程不一定要等待子进程运行结束才做后面的事情，但这就涉及到子进程结束后，父进程需要回收僵尸进程。那么，如何做到这一点呢？ Linux上进行信号屏蔽 在Linux系统上，我们可以使用signal(int signum, sighandler_t handler)函数来设置某一类的信号处理或者屏蔽。我们知道，子进程要exit()之前，会发送SIGCHLD信号给父进程，提醒父进程来回收子进程的退出状态和其他信息。 在这里，我们可以使用一个特殊的技巧： signal(SIGCHLD, SIG_IGN) 这里是让父进程屏蔽子进程的信号，为什么这样就可以做到回收僵尸进程的作用呢？原来是因为在Linux中，当我们忽略SIGCHLD信号时，内核将把僵尸进程交由init进程去处理，能够省去大量僵尸进程占用系统资源。因此，屏蔽了子信号后，子程序在要结束时发送信号没人应答，内核就会认为这是一个孤儿进程，因此被init进程去回收，可以很好的解决我们面临的问题。 BSD系统上的信号处理 而笔者使用的是Minix3.3的系统，经过实测，内核并不会在父进程屏蔽信号后主动回收孤儿进程，因此不能使用这种方法。 那怎么办呢？因此只能自己写一个handler，规定父进程在收到子进程结束的信号后再wait，这样也可以实现此功能。但缺点就是wait函数需要阻塞父进程直到子进程结束为止，对于并发要求较高的并发服务器，可能就不是很适用。 我们使用这种方法完成后台程序的运行： void SIG_IGN_handler(int sig) { waitpid(-1, NULL, 0); return; } 在主程序中install这个handler： signal(SIGCHLD, SIG_IGN_handler); 这样就完成了后台进程的功能。 history功能实现 查找前n个命令是比较简单的功能，我们可以使用队列进行实现，在这里笔者就稍微偷懒一点，直接使用定长的字符串数组进行。 /*update command history*/ void UpdateHistory() { char *temp; if (strcmp(buf, \"\\n\") == 0) return; if (HistoryIndex > MAXLINE) HistoryIndex = 0; temp = (char *)malloc(sizeof(buf)); strcpy(temp, buf); CommandHistory[HistoryIndex++] = temp; return; } /*print the command with n lines*/ void PrintCommand(int n) { int i,j=0; if (n == -1) { for (i = 0 ; i HistoryIndex) { printf(\"Warning: the argument is too large.\\n\"); return; } for (i = HistoryIndex - n; i 参考资料 linux信号函数signal Operating System:Design and Implementation,Third Edition Computer Systems: A Programmer's Perspective, 3/E "},"projects/pipeline2.html":{"url":"projects/pipeline2.html","title":"UNIX 管道及 Shell 实现（二）命令解析","keywords":"","body":" 接上一篇，本篇主要介绍字符串处理和命令的解析。 命令解析 完成一个命令的解析，最重要的步骤就是字符串的解析。我们如何对拿到的字符串进行分解呢？笔者的思路如下： 使用fgets()等函数将输入的命令存放在缓存区中。 对其用空格对其进行分割（使用strtok等字符串处理函数），解析出特殊命令符（重定向\">\"，管道\"|\"，后台程序\"&\"等） 识别出特殊命令：例如history，回车，exit，cd等，这些命令不能使用exceve函数进行解析和运行，需要单独处理。 如果字符串中有特殊命令符，则需要对命令两边分别进行操作。 分割字符串 /* Parse the command line with space and get the argv array */ void parseline() { initStruct(&CommandInfo); buf[strlen(buf) - 1] = ' '; /*Replace trailing '\\n' with space*/ /*split buf with space*/ char* token = strtok(buf, \" \"); while (token) { CommandInfo.argv[CommandInfo.argc++] = token; token = strtok(NULL, \" \"); } /*set the last command with NULL*/ CommandInfo.argv[CommandInfo.argc] = NULL; /*empty command line*/ if (CommandInfo.argc == 0) return; /*indicate whether its background Command*/ CommandInfo.background = (*(CommandInfo.argv[CommandInfo.argc - 1]) == '&'); if (CommandInfo.background) CommandInfo.argv[--CommandInfo.argc] = NULL; return; } 特殊命令处理 针对空格、history、cd等特殊命令，可以先做预处理。 /*if return 1, ignore the command*/ int IgnoreCommand() { /*if no command,continue*/ if (CommandInfo.argc 1) { if (chdir(CommandInfo.argv[1]) == -1) { printf(\"error directory!\\n\"); } } return 1; } /*wrong command*/ if (strcmp(CommandInfo.argv[CommandInfo.argc - 1], \"\") == 0 || strcmp(CommandInfo.argv[CommandInfo.argc - 1], \"|\") == 0) { printf(\"Error:command error\\n\"); return 1; } return 0; } 解析命令操作符 对于“>”，“>”操作符，不需要进行管道操作，因此直接先读取文件名。 int ReviseCommand() { /* if the command is empty or exit or cd or history, should ignore the command; */ if (IgnoreCommand()) return -1; int i, override = 0; /*search the command with special charactors,and store the file and type*/ for (i = 0; i \") == 0) { /* if > is not the first command, should not set the file */ CommandInfo.argv[i] = NULL; if (!override) CommandInfo.file = CommandInfo.argv[i + 1]; CommandInfo.type[CommandInfo.index++] = OUT_REDIRECT; break; } else if (strcmp(CommandInfo.argv[i], \">>\") == 0) { CommandInfo.argv[i] = NULL; if (!override) CommandInfo.file = CommandInfo.argv[i + 1]; CommandInfo.type[CommandInfo.index++] = OUT_ADD; break; } /*multi - PIPE*/ else if (strcmp(CommandInfo.argv[i], \"|\") == 0) { CommandInfo.type[CommandInfo.index++] = PIPE; CommandInfo.argv[i] = NULL; } } return 1; } 命令主题框架 我们首先使用parseline()对得到的命令按照空格进行解析，之后再使用ReviseCommand()提取关键命令字符，识别回车键等，最后再对进程进行fork()，子进程（ChildCommand）执行命令，父进程根据是否有“&”选择等待子进程结束或者继续执行。 void command() { pid_t pid; int indicator = 0; parseline(); /*re-edit command and get the file*/ indicator = ReviseCommand(); if (indicator == -1) return; pid = fork(); if (!pid) { /*the background process should not be disturbed by CTRL+C and CTRL+\\*/ /*sigaction(SIGINT, SIG_IGN, NULL); sigaction(SIGQUIT, SIG_IGN, NULL);*/ ChildCommand(); exit(0); } else { if (!CommandInfo.background) waitpid(pid, NULL, 0); else { /*if background process, the father should ignore the signal let init to reap it */ printf(\"there is a background process\\n\"); } } return; } 子进程命令框架 对于fork出来的子进程，如果只有重定向这种简单的命令，我们通过解析到的字符串和文件名就可以直接进行操作，如果涉及到多个管道的操作，那就要小心了。 void ChildCommand() { int fd; switch (CommandInfo.type[0]) { case NORMAL: Execvp(CommandInfo.argv[0], CommandInfo.argv); break; case IN_REDIRECT: /* command*/ fd = open(CommandInfo.file, O_WRONLY | O_CREAT | O_TRUNC, 0666); dup2(fd, STDOUT_FILENO); Execvp(CommandInfo.argv[0], CommandInfo.argv); break; case OUT_ADD: /* >> command*/ fd = open(CommandInfo.file, O_RDWR | O_APPEND, 0666); dup2(fd, STDOUT_FILENO); Execvp(CommandInfo.argv[0], CommandInfo.argv); break; case PIPE: /* | command*/ pipe_command(); break; } } 这样，除了多管道以外的其他命令和要求我们基本上都实现了，管道的操作略微复杂，我专门写一篇来增强理解。 参考资料： Linux shell的实现 Operating System:Design and Implementation,Third Edition Computer Systems: A Programmer's Perspective, 3/E "},"projects/pipeline3.html":{"url":"projects/pipeline3.html","title":"UNIX 管道及 Shell 实现（三）多管道实现","keywords":"","body":" 本篇主要介绍多管道实现，自己也写得不好，希望大家多多指点。 思路 我在这篇文章中较详细的讲解了管道的实现，但当时只涉及到一个管道，因此只需要关心对管道的read和write，并不需要关心read到什么地方去。 首先，我们在使用pipe创建管道后，需要fork一个进程，子进程用于向管道写，父进程用于向管道读（注意，顺序不能颠倒）。很有趣的一个问题是，当我们使用fork命令时，子父进程的执行顺序是不能确定的，那么是让父进程向管道读还是子进程向管道读呢？ 我的理解是，由于父进程不能先于子进程结束，而如果管道中没有东西，从管道读的操作会被堵塞，可以利用这个性质让子进程先于父进程结束。具体做法就是：让父进程向管道读，子进程向管道写。由于“向管道写”操作总是先于“向管道读”操作，因此可以做到父进程结束前回收子进程的工作。 那么，我们怎么做到多管道进行操作呢？其实也不难，我们可以先把所需要的所有管道建立好，然后当子进程要进行execv操作之前，把它的输出fd指向下一个管道的输入，这样重复进行就能实现多个管道进行通讯了。 要注意的是，当进行到最后一个命令，这时候我们需要判断：若最后一个命令就是“|”，则我们需要将管道中的数据输出到屏幕即可；若最后一个命令时\">\",则需要将管道中的命令写入对应的文件中。 实现 总体来说对于管道的操作有三种情况： 最开始有“ 一开始就是多个管道进行传输，最后输出到屏幕。 通过多个管道传输后，最后重定向到指定文件。 其实这三种情况都可以写成一个函数，因为只需要对第一个命令和最后一个命令进行特殊处理即可。由于笔者很蠢，最开始没想到第一种情况，因此后面只能用修改字符串的方法曲线救国了，代码很丑，将就看吧。 pipe_command： /*take care of pipe*/ void pipe_command() { /*pointerindex is the index of each Command*/ int i = 1, j = 0, pointerindex[20], commandnumber = CommandInfo.index; int pipenumber = 0, pid, pipefd[20][2]; char** P_temp; pointerindex[0] = 0; /*the first command location*/ /*get all command's index*/ while (i or >>*/ for (i = 0; i 对于多管道进行循环操作： /*special run for mult-pipes*/ void next_pipe(int pipefd[20][2], int pipenumber, int pointerindex[]) { char** P_temp; char buffer[MAXLINE]; int commandnumber = CommandInfo.index; /*get the all command number*/ int i = 1, pid, fd, run_index = 2; /*refer to the index of command to run*/ int flag = !(pipenumber + 1 == commandnumber); int lastCommand = 0; /*if only one pipe and no other command, print it*/ if (commandnumber == 1) { read(pipefd[1][0], buffer, MAXLINE); printf(\"%s\", buffer); return; } /*loop to connect the pipe*/ while (pipenumber--) { pid = fork(); if (pid == 0) { /*this is the child, to run the command*/ dup2(pipefd[i][0], 0); /*read data*/ close(pipefd[i][1]); /*no need to write*/ dup2(pipefd[i + 1][1], 1); /*write to the next pipe*/ /*get the command*/ P_temp = CommandInfo.argv + pointerindex[run_index]; Execvp(P_temp[0], P_temp); } else { /*wait child completes the command*/ waitpid(pid, NULL, 0); i++; /*next pipe*/ run_index++; /*next command*/ } } /*if the last command is > or >>*/ if (flag) { if (CommandInfo.override) lastCommand = CommandInfo.type[commandnumber]; else lastCommand = CommandInfo.type[commandnumber - 1]; /*if the command is >*/ if (lastCommand == OUT_REDIRECT) { fd = open(CommandInfo.argv[pointerindex[commandnumber]], O_WRONLY | O_CREAT | O_TRUNC, 0666); } else { /*the command is >>*/ fd = open(CommandInfo.argv[pointerindex[commandnumber]], O_RDWR | O_APPEND, 0666); } read(pipefd[i][0], buffer, MAXLINE); /*read from pipe*/ write(fd, buffer, strlen(buffer)); /*write into file*/ } else { read(pipefd[i][0], buffer, MAXLINE); /*read from pipe*/ fprintf(stdout,\"%s\", buffer); /*print into screen*/ } return; } 对第一种情况进行曲线救国： void EditInfo() { int i, location; CommandInfo.index--; /* find the first command -- NULL */ for (i = 1; i 结果展示 总结 至此，终于完成了一个简单Shell的实现。虽然实现中碰到了不少的问题，最后的代码也不够优美，但这次实验让自己认识到了不少的问题。 C语言使用还不够熟练，特别是对于UNIX的各种系统调用。 没有想清楚了再动笔，代码组织结构有问题，模块化不够。 多文件的协调和编译还不够熟练，编译顺序？makefile文件？还不太会用。 很多小bug没有意识到，比如说直接输入回车，子父进程的管理和回收等等。 单元测试还不太会。 ToDo 虽然把project要求完成了，但前前后后改得面目全非，导致自己都不愿意再看代码了。先挖个坑，等有时间了再重新理理思路，定个小目标，用两百行左右代码写好。 参考资料 [Linux shell的实现][1] Operating System:Design and Implementation,Third Edition Computer Systems: A Programmer's Perspective, 3/E "},"projects/fs.html":{"url":"projects/fs.html","title":"文件系统","keywords":"","body":" 最后的大作业是实现一个文件系统，我以UNIX的文件系统为标准，实现了简单的文件系统和API接口。 本文的所有代码已经上传我的Github。 要求 设计一个文件系统，最多可以容纳5000个文件，设备容量为250MB,单个文件最大容量为50MB,提供目录树功能，文件名最长为50个字符，每块大小1KB。 本实验采用文件来模拟磁盘，采用dd命令创建文件，例如：dd if=/dev/zeroof=simulated_device bs=1024 count=250000将创建一个包含250000块文件名为simulated_device的文件。(这个文件可以满足测试程序中所有测试程序的空间需要) 本实验已经给出测试文件，最大测试文件为50M。 思考 实验要求很简单，就是实现一个普通的文件系统，而且实现方式不限，使用提供的write_block等接口来模拟低层的磁盘操作。 设计一个文件系统，最主要的是思考如何布局。无论什么文件系统，都要包含目录树、文件信息等功能。 文件的实现书上介绍了几种常见的方法： 连续分配 最简单的分配方案，将每个文件存放在连续的磁盘数据块中。 易于实现，性能不错，但会造成大量外碎片（在多个小文件的时候经常发生） 带有文件分配表的链表结构 把每一个磁盘块中的链表指针抽取出来，单独组成一个表格，放在内存中。 这样的坏处是整个文件分配表必须都放在内存，太占用空间。 I-Node 大名鼎鼎的i-node登场啦。此i-node节点列出了文件的属性和各个数据库的磁盘地址，在给定一个i-node之后，就能找到该文件的所有信息。 只有当一个文件被打开时，才需要把它的i节点装入内存。 当i-node存储的磁盘地址不够时，我们还可以使用多级间接块（indirect block）来描述更多的磁盘地址。 目录 相对来说，目录的实现就简单多了。目录也可以理解为一种特殊的文件，UNIX中的目录非常简单，每一项（entry）只包含文件名和i-node节点号两个信息。 空闲块管理 如何迅速知道磁盘中的空闲块以及剩余容量呢？ 一种方法是使用链表，但会占用大量空间。 更常用的方法是使用位图（bitmap）来管理，已经分配的块用1表示，未分配的用0表示，每个块只占1个byte。 SuperBlock 我们还需要一个SuperBlock作为文件系统的初始块。它应该包含文件系统初始化信息、位图地址、根目录地址等等，以便让系统将文件系统加载进内存。 实现 本项目使用了SuperBlock、Bitmap，以及i-node来实现文件系统。 Superblock 是否初始化 磁盘剩余空间（用于快速访问，了解该文件是否能放入磁盘） bitmap信息（每个位图的使用情况） 存储在第一块block中，当初始化时自动加载。 Bitmap 按理来说，Bitmap中的每一个byte来代表一个块。但用byte操作不太直观，因此本项目使用short类型代替（会多浪费不少空间，但总占比空间依然不多） 由于我们由250000个块，本项目设计每个Bitmap包含500个块的位图信息，其余地址用于存储起始磁盘块地址、剩余块多少。 因此，我们需要500个Bitmap，存储在第2~501个磁盘块中。 Root目录 Root目录也必须在文件系统初始化时加载和初始化，因此我们将它分配在502磁盘块上。 i-node 在每个i-node中，我们设计了以下属性： 文件大小 创建、修改时间 直接块（200个，可以存储200KB的信息） 一级间接块（1个，可以存储256KB的信息--一条地址4bytes） 二级间接块（1个，可以存储256*256KB的信息，完全足够我们用了） 总结下来，我们的文件系统大体框架如下图所示： 缓存 解决了文件系统的大体框架问题，接下来我们就要想缓存的问题了。因为我们不可能每次写都直接写到磁盘、每次读都直接从磁盘中读，这样一个block（1KB)一个block的读实在是太慢了。因此我想出了以下几个方法： 每次write只写到缓存，只有当文件close的时候才真正写到内存。这种方法的好处是无论如何读写都很快，但当文件很大的时候非常占用内存。 给内存分配一块专门用作文件读写的缓冲区，当文件大小小于缓冲区时，就直接将文件存储在缓存区中，当文件大于此大小，就将多余的部分存储在磁盘中。 理论上来说，第二种方案肯定是更好的，因为作为操作系统的一部分，肯定不希望占用过多的内存。但本项目为了简单，只采用了第一种方案。 代码逻辑 结构设计 因为文件系统涉及的结构层次较多，为了方便阅读代码，我整理了函数的逻辑如下： 可以看见，对于块操作来说，主要涉及到块操作的读写、查看文件、新建空闲块、查找空闲块等等。这些函数作为接口像上一层调用。 函数声明 首先我们需要进行声明全局变量的结构体，这些变量有助于我们更方便的访问文件信息。 所有的全局变量以及函数声明都在p5.h文件中： #ifndef P5_H #define P5_H #include #define MAX_FILE_NAME_LENGTH 200 #define MAX_OPEN_FILES 10 /* file API */ extern int my_open(const char *path); extern int my_creat(const char *path); extern int my_read(int fd, void *buf, int count); extern int my_write(int fd, const void *buf, int count); extern int my_close(int fd); extern int my_remove(const char *path); extern int my_rename(const char *old, const char *new); extern int my_mkdir(const char *path); extern int my_rmdir(const char *path); extern void my_mkfs(); /* provided by the lower layer */ #define BLOCKSIZE 1024 /* not used in any declaration, just a reminder that each block is 1KB */ /* and may be useful inside the code. */ typedef char block[BLOCKSIZE]; extern int dev_open(); extern int read_block(int block_num, char *block); extern int write_block(int block_num, char *block); /* provided by block function */ #define MAX_PER_BITMAP 500 /* max block covered of one bit map */ #define MAX_DIRENTRY 18 /* max directionary entry each block */ #define BITMAP_NUM 500 /* number of bit map needed*/ #define ROOT_DIR_BLOCK 502 /* number of bit map needed*/ #define BITMAP_START 2 /* where bitmap store in disk */ #define INODE_DIRECT_MAX 200 /* inode direct block max 200 */ #define INODE_DIRECT1_MAX 256 /* inode direct block max 200 */ /* super block struct, 1020 KB */ typedef struct SuperBlk { int is_format; /* is this file system init? */ short bitmap_usage[BITMAP_NUM + 5]; /* usage of each bit map ,begin with index 2 */ int free_space; /* free space */ } SUPERBLK; /* each Dictionary Entry has 56 bytes, a block can have 18 entry */ typedef struct DirEntry { char name[50]; /* file name max length */ int i_node; /* the i-node of file */ } DIRENTRY; /* each Dictionary has 18 entry, overall 1012 bytes */ typedef struct Dir { int in_use; /* how many dir is using */ DIRENTRY entry[MAX_DIRENTRY]; } DIR; /* inode size: 820 bytes */ typedef struct inode { time_t ctime; /* last change time (size : 8 bytes)*/ int i_size; /* file size:(bytes) */ int dir_block[INODE_DIRECT_MAX]; /* direct block */ int indir_block_1; /* indirect block 1 */ int indir_block_2; /* indirect block 2 */ } INODE; /* need 500 bitmap block for 250000 block * each bitmap 1008 btytes */ typedef struct bitmap { int start_block; /* start block of the bit map */ int free_block; /* free block in this bitmap */ short bitmap[MAX_PER_BITMAP]; /* bit map */ } BITMAP; typedef int INDIR_BLOCK[INODE_DIRECT1_MAX]; /* indirect block, a block can fit 256 block pointer */ extern int Write_Superblk(SUPERBLK sb); extern int Write_Dir(int block_num, DIR dir); extern int Write_Bitmap(int block_num, BITMAP btmp); extern int Write_Inode(int block_num, INODE i_node); extern int Write_Inode_block(int block_num, INDIR_BLOCK block1); extern void clean_pathname(); extern int parse_path(const char *Path); extern int find_file(int dir_num); extern int bitmap_search_block(BITMAP *tmp); extern int find_free_block(); extern int mk_new_dir(int parent_dir_disk_num); extern int mk_new_inode(); extern void free_space(int free_block_num); extern void free_indirect_block1(int indirect_block1_location); extern void free_inode(int inode_block_num); extern void read_file(int disk_num, void *buf, int length); extern int read_indir_block1(int block1_disk_num, void *buf, int left); extern int read_from_fpBuf(int fp_index, int count, void *buf); extern int read_to_fpBuf(INODE inodeTmp, int fd_index); extern void write_file(int disk_num, void *buf, int length); extern int write_indir_block1(int block1_disk_num, void *buf, int left); extern int write_fpBuf_to_disk(int fd, INODE InodeTmp, int fd_index); /* global variables */ extern char PathName[5][20]; /* globel Path Name parsed */ extern SUPERBLK SuperBlock; /* superblock will be used frequently */ extern DIR RootDir; /* Root Dir will be used frequently, max 18 entry */ extern INODE tmpInode; extern int OpenFP[50]; /* at most 50 fp */ extern char *OpenFP_buffer[50]; /* the buffer of fp */ extern char *OpenFP_buffer_old[50]; /* the buffer of fp,the fp position unchanged */ extern char TmpBuf[BLOCKSIZE]; /* used for read/wirte block from disk */ #endif /* P5_H */ 磁盘操作接口 因为我们是模拟在磁盘上操作，因此我们需要一个提供的接口，来模拟直接对于磁盘的操作，这些函数定义在block.c中，函数实现十分的简单： #include #include #include #include #include #include \"p5.h\" #define BLOCKSIZE 1024 /* only open the file once */ static int fd = -1; static int devsize = 0; /* returns the device size (in blocks) if the operation is successful, * and -1 otherwise */ int dev_open () { struct stat st; if (fd = devsize) { printf (\"block number requested %d, maximum %d\", block_num, devsize - 1); return -1; } if (lseek (fd, block_num * BLOCKSIZE, SEEK_SET) = devsize) { printf (\"block number requested %d, maximum %d\", block_num, devsize - 1); return -1; } if (lseek (fd, block_num * BLOCKSIZE, SEEK_SET) 块函数实现 对于处理块函数，我们单独使用一个blkFun.c文件进行处理，同时，这里也定义了之后会使用的全局变量。 由于我写了比较详细的注释，这里就不再赘述，请移步我的Github进行查看。 API实现 最后就是实现要求的read、write等接口，这一部分并没有那么的困难，但要注意的是，要及时将更新过的bitmap等信息写到磁盘中去。 测试函数 本项目有一个专门的测试函数，此测试函数将文件从几kb到50M都测试了一遍，而且通过不同的方式，看读写操作是否成功，测试函数如下： #include #include #include #include \"p5.h\" char buffer0[] = \"hello world\"; char buffer1[1000]; /* one thousand */ char buffer2[10000]; /* ten thousand */ char buffer3[100000]; /* a hundred thousand */ char buffer4[1000000]; /* a million */ char buffer5[50 * 1024 * 1024]; /* max size, 50MB */ static int test_file(char *path, char *buffer, int size, int max_size); static void close_remove_file(char *path, int fd); int main(int argc, char **argv) { int first_test = 1; int fd0, fd1, fd2, fd3, fd4, fd5; int i; int max_size = sizeof(buffer5); if ((argc > 1) && (atoi(argv[1]) > 0)) max_size = atoi(argv[1]); printf(\"testing files up to %d bytes\\n\", max_size); my_mkfs(); if (my_mkdir(\"/foo\") = 0) { /* file should not exist */ printf(\"error, opened nonexistent file /foo/bar, aborting\\n\"); exit(1); } printf(\"my_open correctly failed to open non-existent file /foo/bar\\n\"); fd0 = test_file(\"/foo/bar0\", buffer0, sizeof(buffer0), max_size); if (fd0 >= 0) if (my_close(fd0) max_size) /* skip larger tests */ return -1; large = (size > 20); /* small file is \"hello world\" */ /* create a file, check that it was saved */ if (large) { for (i = 0; i 1025) buffer[1025] = 0x99; /* change a value after the first block */ if (size / 2 > 1024 * 256 + 21) buffer[1024 * 256 + 21] = 0x42; /* after first block of blocks */ } if ((fd = my_creat(path)) 1025) buffer[1025] = 1025 % 128; if (size / 2 > 1024 * 256 + 21) buffer[1024 * 256 + 21] = (1024 * 256 + 21) % 128; } /* now read and write */ if ((fd = my_open(path)) = 0) { if (my_close(fd) C语言 通过本实验，发现自己对于C语言很多东西还是掌握的不够好，总结如下： 结构体变量名不是指针 读取数据，只需要将char *类型转换为所需要的类型，即可正确读写（例如结构体） 可变参数 使用strtok切分字符串，注意是对原字符串进行处理，因此不能使const char *类型。 字符串测长度，strlen与sizeof的区别 https://blog.csdn.net/kangroger/article/details/20653255 数组名不完全等于指针 每一次都记得要清空Path_name中的值 注意creat之后，i-node没有初始化，不能读，可以通过block_num判断（若没有初始化，则为0） 读文件，直接将其全部缓存到内存，然后保存一个fd偏移量。 ToDo 总的来说本次实验自己花了将近20个小时，写的还是比较顺利，没有出现过多的bug。但当我写完之后，发现很多细节自己还是没想清楚。本来1000多行的代码量也不大，只是需要自己在写代码之前把框架搭好，这比写代码实现更重要。 缓存的实现方式有问题，需要改成将缓存区大小有限制，同时，在write时候，需要将文件完全写到磁盘中。 寻找空闲块的操作太浪费时间。我目前实现的是查找一个空闲块的操作，但是这样很低效，应该实现一次可以申请多个空闲块的操作。 同时，在寻找空闲块时，不应该从头开始找，而是使用二次匹配等算法。当然，助教说工业界常用的方法是使用线性hash，可以尝试一下，应该速度会提升不少。 使用C++重构代码，可以避免很多代码冗余的现象（函数指针、template的使用） 参考资料 Operating System:Design and Implementation,Third Edition "}}